import { ASTMgr } from "./astmgr.js";
import { FSCmd } from "./cmd.js";
import { iniSysFnList, initFormalSystem } from "./initial.js";
import { FormalSystem } from "./formalsystem.js";
import { TR } from "../lang.js";
import { ListDragger } from "./itemdragger.js";
const astmgr = new ASTMgr();
export class FSGui {
    skipRendering = true;
    formalSystem = new FormalSystem();
    actionInput;
    hintText;
    omitNfFn = false;
    italicItem = false;
    propositionList;
    deductionList;
    metaRuleList;
    sysFnList;
    sysfns;
    cmdBtns;
    displayDs = new Set();
    deductions = [];
    metarules = [];
    autoGenerateDeduction = true;
    unlockedMacro = false;
    unlockedHyp = false;
    unlockedRename = false;
    unlockedFolder = false;
    unlockedSysRulePanel = false;
    enableMIFFT_RP = false;
    onStateChange = () => { };
    onchangeOmitNF = () => { };
    draggerD = new ListDragger(document.getElementById("deduct-list"));
    draggerM = new ListDragger(document.getElementById("meta-list"));
    draggerP = new ListDragger(document.getElementById("prop-list"));
    isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);
    cmd;
    constructor(propositionList, deductionList, metaRuleList, sysFnList, actionInput, hintText, displayPLayerSelect, cmdBtns, creative, skipRendering) {
        this.skipRendering = skipRendering;
        this.propositionList = propositionList;
        this.metaRuleList = metaRuleList;
        this.deductionList = deductionList;
        this.sysFnList = sysFnList;
        this.actionInput = actionInput;
        this.hintText = hintText;
        this.cmdBtns = cmdBtns;
        this.cmd = new FSCmd(this);
        const { fs, arrD } = initFormalSystem(creative);
        this.formalSystem = fs;
        this.deductions = arrD;
        this.sysfns = iniSysFnList();
        cmdBtns.forEach(btn => {
            btn.addEventListener("click", () => {
                if (this.cmd.cmdBuffer.length)
                    return;
                this.cmd.cmdBuffer.push(btn.innerText.replace(/.+\((.+)\)/g, "$1"));
                this.cmd.execCmdBuffer();
            });
        });
        document.querySelectorAll("label.before-list-wrapper").forEach(v => {
            const div = v.nextElementSibling;
            v.addEventListener("click", () => {
                div.classList.toggle("hide-animation");
            });
        });
        const simplSysFn = document.getElementById("simpl-sysfn");
        const italicItemBox = document.getElementById("italic-item");
        const onchangeOmitNF = () => {
            this.omitNfFn = document.getElementById("wrap-simpl-sysfn").classList.contains("hide") ? false : simplSysFn.checked;
            this.italicItem = document.getElementById("wrap-italic-item").classList.contains("hide") ? false : italicItemBox.checked;
            this.updateSysFnList();
            this.updateMetaRuleList(true);
            this.updateDeductionList();
            this.updatePropositionList(true);
        };
        this.onchangeOmitNF = onchangeOmitNF;
        simplSysFn.addEventListener("change", onchangeOmitNF);
        italicItemBox.addEventListener("change", onchangeOmitNF);
        document.querySelectorAll(".footer .right button").forEach((btn) => {
            btn.addEventListener("click", () => {
                if (btn.innerText === "OK") {
                    this.cmd.actionInputKeydown({ key: "Enter" });
                }
                else if (btn.innerText === "Esc") {
                    this.cmd.actionInputKeydown({ key: "Escape" });
                }
            });
        });
        this.draggerD.onExecute = (src, dst) => {
            const mv = (src, dst) => {
                const srcPos = this.deductions.indexOf(src);
                let dstPos = this.deductions.indexOf(dst);
                if (dstPos > srcPos)
                    dstPos--;
                if (srcPos === -1)
                    return false;
                if (dstPos === -1 && dst !== " ")
                    return false;
                const moved = this.deductions.splice(this.deductions.indexOf(src), 1)[0];
                if (dstPos === -1)
                    this.deductions.push(moved);
                else
                    this.deductions.splice(dstPos, 0, moved);
                return true;
            };
            const idx = this.deductions.indexOf(dst);
            const prevDst = idx === -1 ? this.deductions[this.deductions.length - 1] : (this.deductions[idx - 1] ?? "");
            const table = this.scanDeductionFolderScope([src, prevDst]);
            table[src] ??= [];
            table[prevDst] ??= [];
            let moved = 1;
            const movedSrcs = [src];
            let src_uuid = null;
            if (src.startsWith("< f >")) {
                const [_, srcCount, srcuuid] = src.split("::");
                src_uuid = srcuuid;
                moved += Number(srcCount);
                if (table[prevDst].find(e => e[0] === srcuuid)) {
                    return; // cannot move into itself
                }
                const srcidx = this.deductions.indexOf(src);
                const end = srcidx + 1 + Number(srcCount);
                for (let i = srcidx + 1; i < end; i++) {
                    movedSrcs.push(this.deductions[i]);
                }
            }
            for (const [fuuid] of table[src]) {
                if (src_uuid !== fuuid) {
                    this.setDeductionFolderCount(fuuid, (fcount) => fcount - moved);
                }
            }
            for (const [fuuid] of table[prevDst]) {
                const dir = this.deductions.find(d => d.startsWith("< f >") && d.split("::")[2] === fuuid);
                if (dir.endsWith("+"))
                    break;
                this.setDeductionFolderCount(fuuid, (fcount) => fcount + moved);
            }
            if (dst.startsWith("< f >")) {
                const uuid = dst.split("::")[2];
                dst = this.deductions.find(d => d.startsWith("< f >") && d.split("::")[2] === uuid);
            }
            if (src !== dst)
                for (const s of movedSrcs)
                    mv(s, dst);
            this.updateDeductionList();
        };
        this.draggerM.onExecute = (src, dst) => {
            src = src.slice(1);
            dst = dst.slice(1);
            const srcPos = this.metarules.indexOf(src);
            let dstPos = this.metarules.indexOf(dst);
            if (dstPos > srcPos)
                dstPos--;
            if (srcPos === -1)
                return;
            if (dstPos === -1 && dst !== " ")
                return;
            const moved = this.metarules.splice(this.metarules.indexOf(src), 1)[0];
            if (dstPos === -1)
                this.metarules.push(moved);
            else
                this.metarules.splice(dstPos, 0, moved);
            this.updateMetaRuleList(true);
        };
        this.draggerP.queryAllowDrag = () => this.cmd.cmdBuffer.length === 0;
        this.draggerP.onExecute = (src, dst) => {
            const pl = this.formalSystem.propositions.length;
            try {
                const s = Number(src.slice(1));
                const d = dst === " " ? -1 : Number(dst.slice(1));
                this.formalSystem.moveProposition(s, d);
                this.updatePropositionList(true);
            }
            catch (e) {
                if (pl !== this.formalSystem.propositions.length) {
                    this.updatePropositionList(true);
                }
                this.hintText.innerText = e;
            }
        };
        if (creative) {
            this.initCreative();
        }
        this.updateMetaRuleList();
        this.updateDeductionList();
        this.updateSysFnList();
        onchangeOmitNF();
    }
    reload() {
        this.formalSystem.fastmetarules = "";
        this.enableMIFFT_RP = false;
    }
    initCreative() {
        this.metarules = Object.keys(this.formalSystem.metaRules);
        this.formalSystem.fastmetarules = "cvuqe><:#";
        document.getElementById("metarule-subpanel").classList.remove("hide");
        document.getElementById("macro-btns").classList.remove("hide");
        this.unlockedHyp = true;
        this.unlockedRename = true;
        this.unlockedFolder = true;
        this.unlockedSysRulePanel = true;
        this.unlockedMacro = true;
        this.enableMIFFT_RP = true;
        document.getElementById("hyp-btn").classList.remove("hide");
        document.getElementById("ach").classList.add("hide");
        document.getElementById("wrap-simpl-sysfn").classList.remove("hide");
        document.getElementById("wrap-italic-item").classList.remove("hide");
        document.getElementById("stat").classList.add("hide");
        document.getElementById("creer").classList.remove("hide");
        document.getElementById("dir-btn").classList.remove("hide");
        document.getElementById("rename-btn").classList.remove("hide");
    }
    prettyPrint(s) {
        return s.replace(/>=/g, "≥").replace(/<=/g, "≤").replace(/<>/g, "↔").replace(/>/g, "→").replace(/</g, "⊂").replace(/@/g, "∈")
            .replace(/U/g, "∪").replace(/I/g, "∩").replace(/\*/g, "×").replace(/X/g, "×").replace(/\//g, "÷").replace(/-/g, "−")
            .replace(/\|/g, "∨").replace(/÷∨/g, "|").replace(/&/g, "∧").replace(/~/g, "¬").replace(/V/g, "∀").replace(/E/g, "∃").replace(/omega/g, "ω");
    }
    addSpan(parentSpan, text, parseHTML) {
        const span = document.createElement("span");
        if (parseHTML)
            span.innerHTML = text;
        else
            span.innerText = text;
        parentSpan.appendChild(span);
        return span;
    }
    ast2HTML(idx, ast, isItem, scopes = []) {
        const varnode = document.createElement("span");
        const astStr = this.cmd.astparser.stringify(ast);
        varnode.setAttribute("ast-string", astStr);
        if (ast.type === "rule") {
            this.addSpan(varnode, '"');
            varnode.appendChild(this.tree2HTML(this.formalSystem.getDeductionTokens(ast.name)));
            this.addSpan(varnode, '"');
        }
        else if (ast.type === "meta") {
            this.addSpan(varnode, "(");
            let firstTerm = true;
            for (const n of ast.nodes[0].nodes) {
                if (firstTerm) {
                    firstTerm = false;
                }
                else {
                    this.addSpan(varnode, ", ");
                }
                varnode.appendChild(this.ast2HTML(idx, n, false, scopes));
            }
            if (ast.name === "⊢M") {
                this.addSpan(varnode, ` ⊢<sub>M</sub> `, true);
            }
            else {
                this.addSpan(varnode, ` ${ast.name} `);
            }
            firstTerm = true;
            for (const n of ast.nodes[1].nodes) {
                if (firstTerm) {
                    firstTerm = false;
                }
                else {
                    this.addSpan(varnode, ", ");
                }
                varnode.appendChild(this.ast2HTML(idx, n, false, scopes));
            }
            this.addSpan(varnode, ")");
        }
        else if (ast.type === "fn") {
            if (ast.name === "{") {
                this.addSpan(varnode, "{");
                let firstTerm = true;
                for (const n of ast.nodes) {
                    if (firstTerm) {
                        firstTerm = false;
                    }
                    else {
                        this.addSpan(varnode, ", ");
                    }
                    varnode.appendChild(this.ast2HTML(idx, n, true, scopes));
                }
                this.addSpan(varnode, "}");
            }
            else {
                // todo: add show/hide #nf/vnf
                const omitNfFn = (ast.name.match(/^#(v*)nf$/) || ast.name.match(/^#rp$/)) && this.omitNfFn;
                if (!omitNfFn) {
                    if (ast.name !== "(") {
                        const fnName = this.addSpan(varnode, ast.name);
                        if (ast.name.startsWith("#"))
                            fnName.classList.add("sysfn");
                        if (this.formalSystem.fns.has(ast.name))
                            fnName.classList.add("fn");
                        if (this.formalSystem.verbs.has(ast.name))
                            fnName.classList.add("verb");
                    }
                    this.addSpan(varnode, "(");
                }
                const fonts = []; // 0 for mormal, 1 for sup, -1 for sub
                for (const [nidx, n] of ast.nodes.entries()) {
                    let subIsItem = ast.name.match(/^##match/) ? nidx === 3 : ast.name.match(/^#((v*)nf|#?rp)/) ? nidx === 0 ? isItem : true : true;
                    let font = 0;
                    const node = this.ast2HTML(idx, n, subIsItem, scopes);
                    if (ast.name.match(/^#(v*)nf/)) {
                        font = (nidx > ast.name.length - 3) ? -1 : 1;
                    }
                    if (ast.name.match(/^#(#match)?rp/)) {
                        if (nidx === 0)
                            varnode.classList.add("rp");
                        font = nidx === 2 ? -1 : nidx === 1 ? 1 : 0;
                    }
                    if (!nidx) {
                        font = 0;
                    }
                    else {
                        if (ast.name.match(/^#(v*)nf/))
                            node.setAttribute("ast-string", astStr);
                    }
                    fonts.push(font);
                    const noComma = (nidx >= 1);
                    if (nidx && !font && !fonts[nidx - 1])
                        this.addSpan(varnode, ", ");
                    if (omitNfFn && !nidx)
                        varnode.classList.add("omit-nf");
                    if (font) {
                        const wrappedNode = document.createElement(font === 1 ? "sup" : "sub");
                        wrappedNode.classList.add("omit-nf");
                        varnode.appendChild(wrappedNode);
                        if (ast.name.match(/^#(v*)nf/) && nidx > ast.name.length - 3)
                            wrappedNode.classList.add("nf");
                        if (ast.name.match(/^#(v*)nf/) && nidx === 1 && nidx <= ast.name.length - 3) {
                            wrappedNode.prepend(this.addSpan(wrappedNode, "∀"));
                        }
                        if (ast.name.match(/^#(#match)?rp/)) {
                            if (nidx === 2) {
                                const span = document.createElement("span");
                                node.before(span);
                                span.innerText = "↘";
                                wrappedNode.before(span);
                            }
                        }
                        if (nidx && font === fonts[nidx - 1])
                            wrappedNode.appendChild(this.addSpan(wrappedNode, ","));
                        wrappedNode.appendChild(node);
                    }
                    else {
                        varnode.appendChild(node);
                    }
                    if (ast.name.match(/^#(#match)?rp/)) {
                        if (nidx === 3) {
                            const span = document.createElement("span");
                            node.before(span);
                            span.innerText = ",";
                            node.classList.add("rp-nth");
                        }
                    }
                }
                if (!omitNfFn)
                    this.addSpan(varnode, ")");
            }
        }
        else if (ast.type === "replvar") {
            const printForm = {
                "omega": "ω",
                "N": "ℕ",
                "Z": "ℤ",
                "Q": "ℚ",
                "R": "ℝ",
            };
            const el = this.addSpan(varnode, printForm[ast.name] ?? ast.name);
            if (isItem && this.italicItem)
                el.classList.add("item");
            const scopeStack = scopes.slice(0);
            if (this.formalSystem.assert.isConst(ast.name)) {
                el.classList.add("constant");
            }
            else if (ast.name.replace(/^\.\.\./, "").match(this.formalSystem.deductionReplNameRule)) {
                el.classList.add("replvar");
            }
            else {
                el.classList.add("freeVar");
            }
            if (scopeStack[0]?.type === "quantvar") {
                // quantvar is only aimed for mark css style
                if (!el.classList.contains("replvar")) {
                    el.classList.remove("freeVar");
                    el.classList.add("boundedVar");
                }
                scopeStack.pop();
            }
            do {
                if (scopeStack[0] && (scopeStack[0]?.nodes[0]?.name === ast.name) || (scopeStack[0]?.nodes[0]?.nodes?.[0]?.name === ast.name)) {
                    varnode.setAttribute("ast-scope", this.cmd.astparser.stringify(scopeStack[0]));
                    if (!el.classList.contains("replvar")) {
                        el.classList.remove("freeVar");
                        el.classList.add("boundedVar");
                    }
                    break;
                }
            } while (scopeStack.shift());
        }
        else {
            switch (ast.name) {
                case "~":
                case "!":
                    this.addSpan(varnode, this.prettyPrint(ast.name));
                    varnode.appendChild(this.ast2HTML(idx, ast.nodes[0], ast.name === "!", scopes));
                    break;
                case "{|":
                case "|}":
                case "V":
                case "E":
                case "E!":
                    const outterLayers = [];
                    outterLayers.push(this.addSpan(varnode, (ast.name === "{|" || ast.name === "|}") ? "{" : ("(" + this.prettyPrint(ast.name))));
                    const varast = this.ast2HTML(idx, ast.nodes[0], true, [{ type: "quantvar", name: "quantvar" }]);
                    varast.classList.add("boundedVar");
                    if (ast.name === "{|") {
                        outterLayers.push(varnode.appendChild(varast));
                        outterLayers.push(this.addSpan(varnode, this.prettyPrint("@")));
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[1], true, scopes));
                        outterLayers.push(this.addSpan(varnode, "|"));
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[2], false, [ast, ...scopes]));
                        outterLayers.push(this.addSpan(varnode, "}"));
                    }
                    else if (ast.name === "|}") {
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[2], true, [ast, ...scopes]));
                        outterLayers.push(this.addSpan(varnode, "|"));
                        outterLayers.push(varnode.appendChild(varast));
                        outterLayers.push(this.addSpan(varnode, this.prettyPrint("@")));
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[1], true, scopes));
                        outterLayers.push(this.addSpan(varnode, "}"));
                    }
                    else {
                        outterLayers.push(varnode.appendChild(varast));
                        outterLayers.push(this.addSpan(varnode, ":"));
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[1], false, [ast, ...scopes]));
                        outterLayers.push(this.addSpan(varnode, ")"));
                    }
                    // hightlight constrained vars
                    const constrainedVars = Array.from(varnode.querySelectorAll("span")).filter(node => node.getAttribute("ast-scope") === astStr);
                    for (const node of constrainedVars) {
                        node.addEventListener('mouseover', ev => {
                            for (const node of outterLayers) {
                                node.classList.add("highlighted");
                            }
                        });
                        node.addEventListener('mouseout', ev => {
                            for (const node of outterLayers) {
                                node.classList.remove("highlighted");
                            }
                        });
                    }
                    outterLayers[1].addEventListener('mouseover', ev => {
                        for (const node of constrainedVars) {
                            node.classList.add("highlighted");
                        }
                    });
                    outterLayers[1].addEventListener('mouseout', ev => {
                        for (const node of constrainedVars) {
                            node.classList.remove("highlighted");
                        }
                    });
                    break;
                default:
                    this.addSpan(varnode, "(");
                    const subIsItem = "@<=+*UIX/\\".includes(ast.name) || ast.name === "/|" || ast.name === ">=";
                    varnode.appendChild(this.ast2HTML(idx, ast.nodes[0], subIsItem, scopes));
                    this.addSpan(varnode, ast.name.startsWith("$$") ? ` ${ast.name} ` : this.prettyPrint(ast.name));
                    varnode.appendChild(this.ast2HTML(idx, ast.nodes[1], subIsItem, scopes));
                    this.addSpan(varnode, ")");
            }
        }
        // clicks and hovers in this layer
        const spans = Array.from(varnode.childNodes).filter(node => (node.getAttribute && !node.getAttribute("ast-string")));
        for (const node of spans) {
            node.addEventListener('mouseover', ev => {
                for (const node of spans) {
                    node.classList.add("highlighted");
                }
            });
            node.addEventListener('mouseout', ev => {
                for (const node of spans) {
                    node.classList.remove("highlighted");
                }
            });
            node.addEventListener('click', ev => {
                ev.stopPropagation();
                this.cmd.onClickSubAst(idx, varnode.getAttribute("ast-string"));
            });
        }
        return varnode;
    }
    _convert(d) {
        let str = this.cmd.astparser.stringifyTight(d.value);
        let steps = d.steps?.map(step => [step.deductionIdx, step.conditionIdxs, step.replaceValues.map((v, i) => this.cmd.astparser.stringifyTight(v, this.formalSystem.assert.expand(v, d.replaceTypes[i])))]);
        if (d.tempvars?.size) {
            console.log(JSON.stringify([str, "内置宏", steps, Array.from(d.tempvars)]));
            return [str, JSON.stringify(steps), Array.from(d.tempvars)];
        }
        console.log(JSON.stringify([str, "内置宏", steps]));
        return [str, JSON.stringify(steps)];
    }
    updateGuiList(prefix, logicArray, list, filter, setInfo, refresh, customIdx) {
        this.onStateChange();
        if (refresh) {
            while (list.lastChild) {
                list.removeChild(list.lastChild);
            }
            list.setAttribute("total", "0");
        }
        let listLength = Number(list.getAttribute("total")) || 0;
        const values = Object.values(logicArray);
        const keys = Object.keys(logicArray);
        const targetLength = values.length;
        list.setAttribute("total", String(targetLength));
        for (; listLength > targetLength; listLength--) {
            const p = values[listLength];
            if (!filter(p, keys[listLength]))
                continue;
            for (let i = 0; i < 8; i++)
                list.removeChild(list.lastChild);
        }
        for (; listLength < targetLength; listLength++) {
            const p = values[listLength];
            const pname = customIdx ? customIdx[listLength] : prefix + listLength;
            if (!filter(p, keys[listLength]))
                continue;
            const itIdx = document.createElement("div");
            list.appendChild(itIdx);
            itIdx.classList.add("idx");
            itIdx.innerText = pname;
            const itVal = document.createElement("div");
            list.appendChild(itVal);
            itVal.classList.add("val");
            itVal.appendChild(this.ast2HTML(pname, p.value, false));
            const infoArr = [];
            for (let i = 0; i < 6; i++) {
                const itInfo = document.createElement("div");
                list.appendChild(itInfo);
                itInfo.className = "info";
                infoArr.push(itInfo);
            }
            setInfo(p, infoArr, itVal, pname);
            itVal.addEventListener("click", () => {
                const inserted = this.cmd.astparser.stringify(p.value);
                this.cmd.onClickSubAst(pname, inserted);
            });
        }
        list.scroll({ top: list.scrollHeight });
    }
    clearPListMasked() {
        this.propositionList.querySelectorAll("div.p-match-failed").forEach(e => e.classList.remove("p-match-failed"));
    }
    getProps() {
        return this.cmd.cmdBuffer[0] === "entr" ? this.cmd.cmdBuffer[2] ?? this.formalSystem.propositions : this.formalSystem.propositions;
    }
    updateSysFnList() {
        if (this.skipRendering)
            return;
        if (this.unlockedSysRulePanel)
            this.sysFnList.parentElement.parentElement.classList.remove("hide");
        let i = 0;
        this.updateGuiList("m", this.sysfns.map(e => ({ value: e[0] })), this.sysFnList, (p) => true, (p, itInfo, it, pname) => {
            let node;
            let isItem = false;
            let errmsg = "";
            const [ast, info] = this.sysfns[i++];
            let sf = astmgr.clone(ast);
            try {
                this.formalSystem.assert.expand(sf, true);
                node = sf;
            }
            catch (e) {
                sf = astmgr.clone(ast);
                try {
                    this.formalSystem.assert.expand(sf, true);
                    isItem = true;
                    node = sf;
                }
                catch (e) {
                    errmsg = e;
                }
            }
            this.addSpan(it, " ⟹ ");
            const html = node ? this.ast2HTML("d", node, isItem) : this.addSpan(it, errmsg).classList.add("error-color");
            if (html)
                it.appendChild(html);
            itInfo[0].innerText = info;
        }, true, this.sysfns.map(e => e[2]));
    }
    updatePropositionList(refresh) {
        if (this.skipRendering)
            return;
        this.updateGuiList("p", this.formalSystem.propositions, this.propositionList, (p) => true, (p, itInfo, it, pname) => {
            itInfo[0].addEventListener("click", () => {
                if (this.cmd.cmdBuffer.length === 0) {
                    this.cmd.clearCmdBuffer();
                    this.hintText.innerText = TR("命令：");
                }
                else if (this.cmd.cmdBuffer[0] !== "entr")
                    return;
                const from = p.from;
                const cmd = (from ?
                    ["d", from.deductionIdx, ...from.conditionIdxs,
                        ...from.replaceValues.map(v => this.cmd.astparser.stringifyTight(v))
                    ].join(" ")
                    : ("hyp " + this.cmd.astparser.stringifyTight(p.value)));
                this.cmd.replaceActionInputFromClick(cmd);
            });
            if (!p.from) {
                itInfo[0].innerText = TR("假设");
                return;
            }
            this.stringifyDeductionStep(itInfo[0], p.from);
            it.addEventListener("mouseover", () => {
                p.from.conditionIdxs.forEach(idx => {
                    const el = document.querySelector(`#prop-list .idx:nth-child(${(idx + 1) * 8 - 7})`);
                    if (el)
                        el.classList.add("p-highlighted-before");
                });
                const pidx = Number(pname.slice(1));
                for (let i = pidx + 1; i < this.formalSystem.propositions.length; i++) {
                    const from = this.formalSystem.propositions[i]?.from;
                    if (!from)
                        continue;
                    if (!from.conditionIdxs.includes(pidx))
                        continue;
                    const el = document.querySelector(`#prop-list .idx:nth-child(${(i + 1) * 8 - 7})`);
                    if (el)
                        el.classList.add("p-highlighted-after");
                }
            });
            it.addEventListener("mouseout", () => {
                for (let i = 0; i < this.formalSystem.propositions.length; i++) {
                    const el = document.querySelector(`#prop-list .idx:nth-child(${(i + 1) * 8 - 7})`);
                    if (!el)
                        continue;
                    el.classList.remove("p-highlighted-before");
                    el.classList.remove("p-highlighted-after");
                }
            });
        }, refresh);
        const usedPs = new Set();
        for (let pidx = this.deductions.length - 1; pidx >= 0; pidx--) {
            const from = this.formalSystem.propositions[pidx]?.from;
            if (!from)
                continue;
            for (const cidx of from.conditionIdxs) {
                usedPs.add(cidx);
            }
        }
        for (let i = 0; i < this.formalSystem.propositions.length; i++) {
            if (!usedPs.has(i)) {
                for (let j = 1; j < 8; j++) {
                    const el = document.querySelector(`#prop-list div:nth-child(${(i + 1) * 8 - 7 + j})`);
                    if (el)
                        el.classList.add("p-unused");
                }
            }
            else {
                for (let j = 1; j < 8; j++) {
                    const el = document.querySelector(`#prop-list div:nth-child(${(i + 1) * 8 - 7 + j})`);
                    if (el)
                        el.classList.remove("p-unused");
                }
            }
        }
        this.draggerP.attachIdxListener();
    }
    updateDeductionList() {
        if (this.skipRendering)
            return;
        const types = new Set;
        const ds = this.deductions.map(d => d.startsWith('< f >') ? null : this.formalSystem.deductions[d] || this.formalSystem.generateDeduction(d));
        for (const d of ds) {
            if (!d)
                continue;
            types.add(d.from);
            if (d.from.endsWith("*"))
                types.add("添加的规则");
        }
        document.querySelectorAll("input[name='show-d']").forEach((sd) => {
            const from = sd.parentNode.getAttribute("data-tr");
            if (types.has(from))
                sd.parentElement.classList.remove("hide");
            else
                sd.parentElement.classList.add("hide");
        });
        const from = this.deductionList.offsetHeight;
        this.drawDeductionList(ds, this.deductionList, (p, itInfo, it) => {
            itInfo[0].innerText = TR(p.from).replace(/s$/, "").replaceAll("<", "&lt;").replaceAll(">", "&gt;") + (p.steps?.length ? TR("[宏]") : "");
        }, this.deductions);
        const to = this.deductionList.offsetHeight;
        if (to > from) {
            this.deductionList.style.height = from + 'px';
            requestAnimationFrame(() => {
                this.deductionList.style.height = to ? to + 'px' : "auto";
            });
            const reset = () => {
                this.deductionList.style.height = 'auto';
                this.deductionList.removeEventListener('transitionend', reset);
            };
            this.deductionList.addEventListener('transitionend', reset);
        }
        this.draggerD.attachIdxListener();
    }
    updateMetaRuleList(refresh) {
        if (this.skipRendering)
            return;
        this.updateGuiList("m", Object.fromEntries(this.metarules.map(e => [e, this.formalSystem.metaRules[e]])), this.metaRuleList, (p, idx) => this.metarules.includes(idx), (p, itInfo, it) => {
            itInfo[0].innerHTML = TR(p.from).replaceAll("<", "&lt;").replaceAll(">", "&gt;");
        }, refresh, this.metarules.map(e => "m" + e));
        this.draggerM.attachIdxListener();
    }
    scanDeductionFolderScope(targets) {
        const fStack = [];
        const res = {};
        for (let i = 0; i < this.deductions.length; i++) {
            while (true) {
                const last = fStack.pop();
                if (!last)
                    break;
                if (last[2] >= i) {
                    fStack.push(last);
                    break;
                }
            }
            const name = this.deductions[i];
            if (name.startsWith("< f >")) {
                const [fname, flength, fuuid, fstate] = name.slice(5).split("::");
                fStack.push([fuuid, Number(flength), i + Number(flength)]);
            }
            if (targets.includes(name)) {
                res[name] = fStack.slice(0);
            }
        }
        return res;
    }
    setDeductionFolderCount(fuuid, count) {
        const idx = this.deductions.findIndex(d => d.startsWith("< f >") && d.split("::")[2] === fuuid);
        if (idx === -1)
            return false;
        const n = this.deductions[idx].split("::");
        n[1] = String(count(Number(n[1])));
        this.deductions[idx] = n.join("::");
    }
    drawDeductionList(logicArray, list, setInfo, customIdx) {
        this.onStateChange();
        while (list.lastChild) {
            list.removeChild(list.lastChild);
        }
        const fStack = [];
        const values = Object.values(logicArray);
        const targetLength = values.length;
        for (let listIdx = 0; listIdx < targetLength; listIdx++) {
            const p = values[listIdx];
            const pname = customIdx[listIdx];
            let skipRendering = false;
            while (true) {
                const last = fStack.pop();
                if (!last)
                    break;
                if (last[2] >= listIdx) {
                    fStack.push(last);
                    break;
                }
            }
            for (const s of fStack) {
                if (s[0] === "+") {
                    skipRendering = true;
                    break;
                }
            }
            if (!skipRendering) {
                const itIdx = document.createElement("div");
                list.appendChild(itIdx);
                itIdx.classList.add("idx");
                itIdx.innerText = pname;
                const itVal = document.createElement("div");
                list.appendChild(itVal);
                this.addSpan(itVal, "│".repeat(fStack.length)).className = "dir-bar";
                if (p) {
                    itVal.classList.add("val");
                    itVal.appendChild(this.ast2HTML(pname, p.value, false));
                    const infoArr = [];
                    for (let i = 0; i < 6; i++) {
                        const itInfo = document.createElement("div");
                        list.appendChild(itInfo);
                        itInfo.className = "info";
                        infoArr.push(itInfo);
                    }
                    setInfo(p, infoArr, itVal, pname);
                    itVal.addEventListener("click", () => {
                        const inserted = this.cmd.astparser.stringify(p.value);
                        this.cmd.onClickSubAst(pname, inserted);
                    });
                }
                else {
                    itIdx.classList.add("dir-idx");
                    itVal.classList.add("dir-val");
                    const [fname, flength, fuuid, fstate] = pname.slice(5).split("::");
                    const dir = this.addSpan(itVal, fname.startsWith("#") ? TR(fname.slice(1)) : fname);
                    dir.classList.add(fstate === "+" ? "dir-close" : "dir-open");
                    dir.classList.add("dir-val");
                    for (let i = 0; i < 6; i++) {
                        const itInfo = document.createElement("div");
                        itInfo.classList.add("dir-val");
                        itInfo.classList.add("dir-info");
                        list.appendChild(itInfo);
                        if (i)
                            continue;
                        this.addSpan(itInfo, "➕").addEventListener("click", e => {
                            if (!this.cmd.cmdBuffer.length) {
                                for (let i = this.deductions.indexOf(pname), j = 0; j < Number(pname.split("::")[1]); i++, j++) {
                                    const d = this.deductions[i];
                                    if (d.startsWith("< f >") && d.endsWith("-")) {
                                        this.deductions[i] = d.slice(0, -1) + "+";
                                    }
                                }
                            }
                            this.updateDeductionList();
                        });
                        this.addSpan(itInfo, "➖").addEventListener("click", e => {
                            if (!this.cmd.cmdBuffer.length) {
                                for (let i = this.deductions.indexOf(pname), j = 0; j < Number(pname.split("::")[1]); i++, j++) {
                                    const d = this.deductions[i];
                                    if (d.startsWith("< f >") && d.endsWith("+")) {
                                        this.deductions[i] = d.slice(0, -1) + "-";
                                    }
                                }
                            }
                            this.updateDeductionList();
                        });
                        this.addSpan(itInfo, "✏️").addEventListener("click", e => {
                            if (!this.cmd.cmdBuffer.length) {
                                this.cmd.cmdBuffer.push("op-dir", "rename", fuuid);
                                this.cmd.execCmdBuffer();
                            }
                        });
                        this.addSpan(itInfo, "🗑️").addEventListener("click", e => {
                            if (!this.cmd.cmdBuffer.length) {
                                if (!confirm(TR("该操作将删除文件夹，并将里面的内容散列在上级目录中，确定要删除<") + (pname.slice(5).split("::")[0]) + TR(">吗？")))
                                    return;
                                const scope = this.scanDeductionFolderScope([pname]);
                                this.deductions.splice(this.deductions.indexOf(pname), 1);
                                for (const [uuid] of scope[pname]) {
                                    this.setDeductionFolderCount(uuid, c => c - 1);
                                }
                            }
                            this.updateDeductionList();
                        });
                    }
                    itVal.addEventListener("click", () => {
                        if (this.deductions[listIdx].endsWith("+")) {
                            this.deductions[listIdx] = this.deductions[listIdx].slice(0, -1) + "-";
                        }
                        else {
                            this.deductions[listIdx] = this.deductions[listIdx].slice(0, -1) + "+";
                        }
                        this.updateDeductionList();
                    });
                }
            }
            if (!p) {
                const [fname, flength, fuuid, fstate] = pname.slice(5).split("::");
                fStack.push([fstate, listIdx, listIdx + Number(flength)]);
            }
        }
        list.scroll({ top: list.scrollHeight });
    }
    tree2HTML(tree) {
        const span = document.createElement("span");
        span.classList.add("rule-node");
        if (tree.length === 1) {
            span.textContent = tree[0];
            span.classList.add("rule-token");
            if (tree[0].startsWith("$$")) {
                span.classList.add("replvar");
                span.classList.remove("rule-token");
            }
        }
        else if (tree[0][0] === "#") {
            const hash = document.createElement("span");
            hash.textContent = tree[0];
            span.appendChild(hash);
            for (let i = 1; i < tree.length; i++) {
                const comma = document.createElement("span");
                comma.textContent = ",";
                span.appendChild(comma);
                span.appendChild(this.tree2HTML(tree[i]));
            }
        }
        else if (tree[0] === ":") {
            for (let i = 1; i < tree.length; i++) {
                const sep = document.createElement("span");
                sep.textContent = i === tree.length - 1 ? "," : ":";
                span.appendChild(sep);
                span.appendChild(this.tree2HTML(tree[i]));
            }
        }
        else if (tree.length === 2) {
            const first = document.createElement("span");
            first.textContent = tree[0];
            span.appendChild(first);
            span.appendChild(this.tree2HTML(tree[1]));
        }
        const spans = Array.from(span.childNodes);
        for (const node of spans.filter(n => (!n.classList) || !n.classList.contains("rule-node"))) {
            node.addEventListener('mouseover', ev => {
                for (const node of spans) {
                    node.classList.add("rule-highlighted");
                }
            });
            node.addEventListener('mouseout', ev => {
                for (const node of spans) {
                    node.classList.remove("rule-highlighted");
                }
            });
        }
        return span;
    }
    stringifyDeductionStep(dom, step) {
        if (!dom)
            return `&nbsp;${step.deductionIdx} ${step.conditionIdxs.join(",")}`;
        const span = this.addSpan(dom, "&nbsp;", true);
        const didx = this.tree2HTML(this.formalSystem.getDeductionTokens(step.deductionIdx));
        span.appendChild(didx);
        this.addSpan(span, " ");
        let firstTerm = true;
        for (const p of step.conditionIdxs) {
            if (!firstTerm)
                this.addSpan(span, ",");
            firstTerm = false;
            const sp = this.addSpan(span, String(p));
            sp.classList.add("rule-cond");
            sp.addEventListener("mouseover", ev => {
                const el = document.querySelector(`#prop-list .idx:nth-child(${(p + 1) * 8 - 7})`);
                if (el)
                    el.classList.add("p-highlighted-before");
            });
            sp.addEventListener("mouseout", ev => {
                const el = document.querySelector(`#prop-list .idx:nth-child(${(p + 1) * 8 - 7})`);
                if (el)
                    el.classList.remove("p-highlighted-before");
            });
        }
    }
    addToDeductions(name, after) {
        const oldpos = this.deductions.indexOf(name);
        // delete
        if (oldpos !== -1) {
            if (after === name)
                return; // x=S(x), aborted
            if (after === this.deductions[oldpos - 1])
                return; // identity
            this.deductions.splice(oldpos, 1);
        }
        // insert
        if (!after) {
            this.deductions.push(name);
            this.updateDeductionList();
            return;
        }
        const pos = this.deductions.indexOf(after);
        if (pos === -1) {
            this.deductions.push(name);
        }
        else {
            this.deductions.splice(pos + 1, 0, name);
        }
        this.updateDeductionList();
    }
    getDeduction(id) {
        if (id === ".")
            return this.getDeduction(this.cmd.lastDeduction);
        // if cuv is locked, can't use cmp and vmp
        if ("cuv".includes(id[0]) && !this.formalSystem.fastmetarules.includes(id[0])) {
            if (id[0] === "v" && this.formalSystem.fastmetarules.includes("q")) {
                if (id.match(/^v*mp$/))
                    return null;
            }
            else
                return null;
        }
        const tokens = [];
        this.formalSystem.getAtomDeductionTokens(id, tokens);
        for (const it of tokens) {
            if (this.deductions.includes(it))
                continue;
            // if .XX is locked, can't use it
            if (it[0] === "." && !(this.formalSystem.fastmetarules.includes("#") && (this.formalSystem.generateNatLiteralOp(it) || this.formalSystem.generateNatLiteralIsNat(it))))
                return null;
            if (it[0] === "a" || it[0] === "d")
                return null;
        }
        try {
            return this.formalSystem.generateDeduction(id);
        }
        catch (e) {
            return null;
        }
    }
}
//# sourceMappingURL=gui.js.map