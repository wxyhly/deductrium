export const mapData = `

// 游戏大厅

@欢迎来到游戏[n]Deductrium![n]按WASD或[n]拖动画面进行移动
5$[[zh-en]]Toggle Language:[n]English
1@
3@这是一个形式系统推理结合[n]双曲空间解谜小游戏[n]游戏作者：Hqak(wxyhly)
    :%,4;5;5;5;0;5@
    :%,3$获取1µg推理素
    4,1,3,1,3@
    :%,4;2;3;4;4;2@
    :%,2#前面的区域[n]以后再来探索吧？
    :%,2;2;2;2;2;5@
1,1#[[w]]未解锁的闸门无法通过[n]请寻找线索解开闸门[n]#ω
2@
3,2@
:%,4$[[progL]]解锁进度层

2,2$[[dL]]解锁推理层[n]与符号“→”（>）
1,3#通过此门需消耗推理素1kg
1,3,1$获取50kg推理素

// a>a 与推理宏引导

:dL,3@#p闸门开启方法：[n]当推理层的定理列表中[n]包含闸门上的字符串时[n]才能通过闸门
:dL,4#[[aa]][n]a>a[n]#p
:%,4#[n]b>b[n]#p
:%*,1$获取1µg推理素
:%,5#[n](a>b)>(a>b)[n]#p
:%,5$获取1µg推理素
:aa,2@[[否定/宏分路]]
:%,1#[[宏门]]通过此门需消耗推理素1µg
:%,2$[[macro]]解锁使用推理宏[n]（即“录制宏”按钮）[n]提示：前往⊢($0>$0)[n]后方以解锁假设
:%*,4#[n]⊢$0>(($0>$1)>$0)[n]#d
:%*,4,1$获取2µg推理素
:%,1@[[nd]]#d闸门开启方法：[n]当推理层的推理规则列表中[n]包含闸门上的字符串时[n]才能通过闸门
:%*,3$获取1µg推理素
:aa,1#[n]a>(c>(b>a))[n]#p
:%,2$获取8µg推理素
:dL,2#[n]a>(a>a)[n]#p
:%*,3#[[preord]]健身俱乐部会员：[n]进度层中累计的[n]总方块步数达到[n]256步才能通过此门
:%*,3,1$[[omega]]拆除门#ω
:%,4@提示：解锁符号“~”后[n]才能开这些门[n]另外：[n]大写字母为系统保留[n]建议输入小写字母
:%,4@向前走，有推出[n]a>a[n]的提示
:%,5@
:%,5#[n]a>((a>a)>a)[n]#p
:%,4@要想推出a>a[n]尝试使用a2公理看看[n]a>((a>a)>a)[n]能推出什么[n]然后再尝试使用[n]两次推理规则mp
:%,3$获取1µg推理素
:omega,4;3;1;4;5;3;1;3;3;1;4;2;3;2;3@
:omega,4;3;1;4;5;3;2;2;3;4;5;5;4;3@
:omega,4;3;1;2;3;4;2;4;3;4;5@
:%,3$[[base-1]]获得奖励：[n]若序数进位基底大于5[n]则将基底减1
:omega,4;3;3;4;3;4;2;4;3;4;5@
:omega,4;3;3;4;3;4;2;2;1;2;1;2;3;3;4@
:omega,4;3;1;2;3;4;2;4;3;4;5;4;3;4;5;2;3@
:omega,4;3;1;2;3;4;2;4;3;4;5;4;3;4;5;4;5;5;0@
:omega,4;3;1;2;3;4;2;4;3;2;3;2;3;2;1;2;5;3;3@
:%,2$[[cmpss]]获取指南针
:omega,4;3;1;2;3;4;2;4;3;2;3;1;3;2;1;2;5;3;3@
:omega,4;3;1;2;3;4;2;4;3;2;3;2;3;2;3;4;5;3;2@
:omega,4@向前走寻找指南针
:否定/宏分路,2;1;2;1;1;1@
:否定/宏分路,4#[[否定门]]通过此门需消耗推理素2µg
:%,5$[[neg]]解锁否定公理a3[n]即符号“¬”（~）
:%,2;1;1;1;1;1;1@

// 引导 a>b,b>c > a>c

:否定/宏分路,3#[n]($0>($1>$2)),($0>$1)⊢($0>$2)[n]#d
:%*,3$获取1µg推理素
:macro,5#[[.i]][n]⊢($0>$0)[n]#d
:%*,2@提示：录制宏会将[n]整个定理列表[n]保存到推理规则表中[n]“$xxx”可被任意替换使用
:%,5#[n](~$0>~$1)⊢($1>$0)[n]#d
:%*,5$获取1µg推理素
:%,0#[n]($0>($1>$2))⊢(($0>$1)>($0>$2))[n]#d
:%*,5$获取1µg推理素

:.i,4$[[hyp]]解锁假设[n]注意：定理表中若有假设[n]不可开启对应门#p[n]假设是用来录制宏的
:%*,3@将定理列表清空后添加假设[n]录制成宏后假设将作为[n]推理条件出现在[n]推出符号“⊢”前
:%*,3,3$获取1µg推理素
:否定门,1$[[delgate]]解锁拆门技能[n]通过门后将其拆除[n]提示：考虑逆否命题[n]（建议推出否定爆炸后[n]再探索前方系列谜题）

// 一些l7z8的元定理，可挣分买演绎定理

:nd,1;1@
:%,1#[n]⊢($0>(($0>$1)>$1))[n]#d
:%*,2$获取5µg推理素

// iff门, m1, m2

:delgate,3#[n]~($0>$1)⊢~$1[n]#d
:delgate,4#[n]$0,~$1⊢~($0>$1)[n]#d
:%*,3$[[del<>]]拆除门#<>(↔)[n]提示：该门后才解锁相应符号
:%*,3,3$[[base-7]]获得奖励：[n]若序数进位基底大于5[n]则将基底减1
:%,1#[n]~($0>$1)⊢$0[n]#d
:%*,3$[[andor]]解锁逻辑符号[n]“∧”（&）与“∨”（|）
:%*,3,2#[[lem]][n](p|~p)[n]#p
:%*,3,2,2$[[base-8]]获得奖励：[n]若序数进位基底大于5[n]则将基底减1
:%*,3,2,4$获取9µg推理素
:%*,3,2,3#[[contra]][n]~(p&~p)[n]#p
:%*,3,2,3,2$[[base-9]]获得奖励：[n]若序数进位基底大于5[n]则将基底减1
:%*,3,2,3,3$获取18µg推理素
:%*,3,3@提示：需解锁[n]“<>”(↔)符号[n]才能使用逻辑符号
:%*,3,3,4#[[pierce]][n]((p>q)>p)>p[n]#p
:%*,3,3,4,5$获取50µg推理素

:%*,3,3,1#通过此门需消耗推理素20µg
:%*,3,3,1,5$[[highlightd]]高亮显示[n]仅奖励推理素的方块

// <>基本定理

:del<>,1#[n]($0>$1),($1>$0)⊢($0<>$1)[n]#d
:%*,3$获取10µg推理素
:%,2#[n](a<>a)[n]#p
:%*,2$获取10µg推理素
:%,1#[n]($0<>$1)⊢$0>$1[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0<>$1)⊢$1>$0[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0<>$1)⊢($1<>$0)[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0<>$1)<>($1<>$0)[n]#p
:%*,2$获取10µg推理素
:%,1#[n]($0<>$1),($1<>$2)⊢($0<>$2)[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0<>~~$0)[n]#p
:%*,2$获取10µg推理素
:%,1#[n]($0<>$1)⊢(~~$0>$2)<>($1>$2)[n]#d
:%*,3$获取100µg推理素

// or
:andor,1#[n]($0|$1)>(~$0>$1)[n]#p
:%*,3$获取10µg推理素
:%,2#[n](~$0>$1)>($0|$1)[n]#p
:%*,2$获取10µg推理素
:%,1#[n]$0⊢($0|$1)[n]#d
:%*,2$获取10µg推理素
:%,1#[n]$1⊢($0|$1)[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0|$0)⊢$0[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0|$1)⊢($1|$0)[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0|$1)|$2⊢$0|($1|$2)[n]#d
:%*,2$获取10µg推理素
:%,1#[n]~$0,~$1⊢~($0|$1)[n]#d
:%*,2$获取10µg推理素
:%,0#[n](~$0|~$1)<>~($0&$1)[n]#p
:%*,1$获取10µg推理素

//and
:andor,5#[n]($0&$1)>~($0>~$1)[n]#p
:%*,2$获取10µg推理素
:%,5#[n]~($0>~$1)>($0&$1)[n]#p
:%*,2$获取10µg推理素
:%,0#[n]$0,$1⊢($0&$1)[n]#d
:%*,2$获取10µg推理素
:%,5#[n]($0&$1)⊢$0[n]#d
:%*,2$获取10µg推理素
:%,0#[n]($0&$1)⊢$1[n]#d
:%*,2$获取10µg推理素
:%,5#[n]($0&$1)⊢($1&$0)[n]#d
:%*,2$获取10µg推理素
:%,0#[n]($0&$1)&$2⊢$0&($1&$2)[n]#d
:%*,2$获取10µg推理素
:%,5#[n]~$0⊢~($0&$1)[n]#d
:%*,2$获取10µg推理素
:%,0#[n]~$1⊢~($0&$1)[n]#d
:%*,3$获取10µg推理素

// 自动推理

:%,5#通过此门需消耗推理素130µg
:%,2$[[delL]]拆除门#L
// :%,2$[[mcpt]]解锁完备性元定理[n]（命题逻辑自动推理）
:delgate,2;5;5;0@
:delgate,5;2;2;1@

// mct

:hyp,5;5;0;5;0;4;1;2@
:%,1@条件演绎元定理[n]将自动帮你生成[n]带条件的推理宏
:%,0#[[ccmp]][n]($0>($1>$2)),($0>($1>($2>$3)))⊢($0>($1>$3))[n]#d
:%,3$[[mct]]解锁条件演绎元定理
:%,5#[n]($0>~~$1)⊢($0>$1)[n]#d
:%*,5$获取5µg推理素
:mct,1,1$获取10µg推理素

// mdt后好证的从#p门含义出来的岔路：

:ccmp,1#[[mct2mdt]]通过此门需[n]1.解锁条件演绎元定理[n]2.消耗推理素20µg
:%*,2$[[mdt]]解锁演绎元定理[n]解锁演绎元定理[n]解锁演绎元定理
:%,1@重要的元定理说三遍[n]重要的元定理说三遍[n]重要的元定理说三遍
:%,4#[n]($0>($1>$2))>(($0>($1>($2>$3)))>($0>($1>$3)))[n]#p
:%*,3$获取1µg推理素
2,2,3,2#[n]($0>($1>$2))>($1>($0>$2))[n]#p
:%,1$获取20µg推理素

// 否定逻辑词

:neg,0#[[.dne]][n]~~a>a[n]#p
:%*,5@提示：要证a>~~a[n]需先证~~~a>~a
:%*,5,0$[[base-6]]获得奖励：[n]若序数进位基底大于5[n]则将基底减1
:%,3#[n]a>~~a[n]#p
:%*,5$[[dniM]]获取5µg推理素
:%*,1@提示：[n]门a>(a>a)[n]后有些关于双重否定[n]推理的提示
:%*,1,3#[n](~a>~~a)>(~a>a)[n]#p
:%*,1,4#[n](~a>~a)>(a>a)[n]#p
:%*,1,4,5$获取1µg推理素
:%*,1,4,1$获取1µg推理素
:%*,1,3,1$获取2µg推理素
:%,2#[n]($0>$1)⊢(~$1>~$0)[n]#d
:%*,2,1$获取10µg推理素
:%*,3$获取3µg推理素
:%*,5@提示：这里继续深入[n]前进可拆除门#K
:%,2#[n]($0>$1)>(~$1>~$0)[n]#p
:%,5#[n]($0>~$1)>($1>~$0)[n]#p
:%,5#[n](~$0>$1)>(~$1>$0)[n]#p
:%,4$[[delK]]拆除门#K
:%,2$获取15µg推理素
    2,2,2,4,2#[n]~~a>(~~~~a>~~a)[n]#p
    :%*,3$获取1µg推理素
    :%*,3,3@提示：先从a2公理出发证明[n]($0>$1),($0>($1>$2))⊢($0>$2)
    :%*,3,3,3@提示2：通过a1公理可以证明[n]($1>$2)⊢($0>($1>$2))
    :%*,1#[n](~~~~a>~~a)>(~a>~~~a)[n]#p
    :%*,1,5@提示：证明规则[n]($0>$1),($1>$2)⊢($0>$2)[n]后使用它
    :%,2#[n]~~a>(~a>~~~a)[n]#p
    :%*,5#[n]($0>$1),($1>$2)⊢($0>$2)[n]#d
    :%*,5,5$获取9µg推理素
    :%,2#[n]~~a>(~~a>a)[n]#p
    :%*,3@提示：~~a>(~~a>a)[n]与a2公理
    :%,2#[n](~~a>~~a)>(~~a>a))[n]#p
    :%,2$获取5µg推理素
    :%,1$[[base-10]]获得奖励：[n]若序数进位基底大于5[n]则将基底减1
:neg,3#[[exfalso2]][n]$0⊢(~$0>$1)[n]#d
:%*,2$获取4µg推理素
:%,1#[n]$0>($0>$1)⊢$0>$1[n]#d
:%*,2$获取4µg推理素
:neg,4#[[exfalso1]][n]a>(~a>b)[n]#p
:%*,2$获取8µg推理素
:%*,1@提示：证否定爆炸须先证a>~~a[n]关键步骤：[n]a⊢~b>a[n]~b>a⊢~a>b
:%*,1,2#[n]$0,~$0⊢~$1[n]#d
:%*,1,2,3$获取2µg推理素
:%*,1,4#[n]~$0,$0⊢~$1[n]#d
:%*,1,4,3$获取2µg推理素

2,1#通过此门需消耗推理素101µg
:%*,3$[[base-5]]获得奖励：[n]若序数进位基底大于5[n]则将基底减1
:%,4$[[.prop]]获得常见[n]命题逻辑定理[n]大礼包！可直接使用！
:%*,2#通过此门需消耗推理素1mg
:%*,3#通过此门需消耗推理素500µg
:%*,2,1$[[renameD]]解锁直接重命名[n]推理规则的能力
:%*,3,5$[[mkdir]]解锁建立文件夹[n]整理规则列表的能力
// 门k及之后: a3/T互推，自动推理

2,2,3,4,4#[[K]][n]未解锁的闸门无法通过[n]请寻找线索解开闸门[n]#K
:%,5@
    // 提示门K在哪
    :.i,3;4;3;2@
    :%,3@门#K在离[n]#p闸门开启方法说明[n]直线距离2格远的地方[n]
    :%,1@要解锁门#L[n]需要从“解锁拆门技能”[n]方块旁经过
:K,1#[n](b>c)>((~b>c)>c)[n]#p
:%,1#[n](~b>c)>((b>c)>c)[n]#p
:%,1#[n](~b>~c)>((~b>c)>b)[n]#p
:%,1#[n](~b>c)>((~b>~c)>b)[n]#p
:%,1#[[L]][n]未解锁的闸门无法通过[n]请寻找线索解开闸门[n]#L
:%,1$[[mcpt]]解锁完备性元定理[n]（命题逻辑自动推理）

// 一阶逻辑与iff的引子

:dL,1@解锁拆门技能奖励方块前方[n]可解锁<>、&、|逻辑符号[n]然后有很多推理素奖励
:dL,1,4#通过此门需消耗推理素100µg
:dL,1,3#[[port-iff]][n]未解锁的闸门无法通过[n]请寻找线索解开闸门[n]#<>(↔)
:dL,1,4,5$[[1st]]解锁一阶逻辑[n]量词公理a4、a5、a6[n]与公理模式元规则mq[n]建议先前往介绍[n]量词、公式那条路[n]后面再来公理a4相关关卡
:dL,1,3,1$[[iff]]解锁当且仅当（互推）[n]逻辑符号“↔”（<>）
:%,5#[n](~(a>~b)>c)<>(a>(b>c)))[n]#p
:%,5$获取20µg推理素
:1st,4#通过此门需消耗推理素50µg
:%,4$[[italic-item]]解锁用斜体区分[n]显示项与公式

// idt和cmt元定理、快速元定理教程

:iff,2,4#通过此门需消耗推理素49µg
:%*,1$[[midt]]解锁逆演绎元定理
:%*,5$[[mcmt]]解锁组合元定理
:%*,4@逆演绎元定理其实就是[n]相应公理与mp规则的简单组合[n]但组合后的条件自动匹配[n]如推理规则“<a1”为[n]$1⊢$2>$1
:%*,2@组合元定理将两个[n]带条件的推理规则a与b[n]自动匹配组合成[n]一条规则“:a,b”[n]比如推理规则[n]“:a7,<a1”将自动得到[n]⊢ $1 > ($0=$0)
:%*,2,3@往前走，还有更高级的[n]组合元定理用法[n]（仅限快捷执行元规则）
:%*,2,3,3#通过此门需消耗推理素50µg
:%*,2,3,3,3#通过此门需消耗推理素100µg
:%*,2,3,3,3,3@组合元定理可以嵌套[n]如::a,b,c相当于[n]令m = :a,b[n]则::a,b,c = :m,c
:%*,2,3,3,3,3,1@第二个参数同理[n]如:a,:b,c相当于[n]令m = :b,c[n]则:a,:b,c = :a,m
:%*,2,3,3,3,3,2@第二个参数规则[n]也可以有多个条件[n]如:a:b,c表示[n]先执行推理规则a与b[n]然后把它们的结论[n]分别作为规则c的条件[n]再执行c
:%*,2,3,3,3,3,3@条件之间用“:”分隔[n]条件与结论之间用“,”分隔[n]“#”为放入默认条件[n]条件没写够则默认为“#”
:%*,2,3,3,3,3,4@你可以输入这几个规则体会一下：[n]:<a1,c.t[n]:<a1:#,c.t[n]:#:<a1,c.t
:%*,2,3,3,3,3,5@定理.t($a>$b,$b>$c⊢$a>$c)[n]可以输入规则名直接生成：[n]<:<a1,<a2[n](虽然两个条件顺序反了)
:%*,3@快捷执行元规则：[n]可输入元规则名字前方括号内[n]的字符前缀加上推理规则名[n]来执行元规则。该方式生成的新规则[n]不列入推理规则表中
// 一阶逻辑断言函数教程

:1st,5#[n](V$2:$0)>((V$2:$1)>(V$2:$0))[n]#p
:%,0#[n]V$2:($0>($1>$0))[n]#p
:%*,2@提示：对某个[n]命题逻辑的公理使用[n]元推理规则mq[n]来打开这扇门
:%,5#[n](V$2:$0) > V$2:($1>$0)[n]#p
:%,0@公理a6解读：[n]#nf($0,$1)的值为$0[n]外加验证变量$1不在[n]表达式$0中自由出现[n](nf为not free缩写)
:%,5@若$0中没有一阶逻辑量词[n]则自由出现指$0中含有$1[n]
:%,5@验证#nf(Vx:$0,$1)[n]有两种情况：[n]1.若x为$1，则[n]$1不在Vx:$0中自由出现[n]若$0中有x,我们说[n]x被量词约束
:%,0@2.若x不是$1[n]则#nf(Vx:$0,$1)=[n]Vx:#nf($0,$1)[n]即$1在Vx:$0中是否自由出现[n]取决于$1在$0中是否自由出现
:%,5@若#nf函数验证成功[n]则系统自动删去#nf函数[n]若验证失败系统将报错
:%,0@由于$开头的公式或项[n]在录制宏后可替换成任意值[n]无法确定时[n]#nf函数将保留
:%,0#[[nf]][n](Vx:$1)>(Vx:(Vx:$1))[n]#p
:%*,5@Vx:$1中x被量词约束[n]不会自由出现[n]因此可使用公理a6
:%,0#[n](Vx:$1)>(Vy:(Vx:$1))[n]#p
:%*,3,1#[n](Vx:x@y)>(Vy:(Vx:x@y))[n]#p
:%*,3$你永远别想拿到这个奖励！
:%,2@Vx:$1中y没被量词约束[n]可能在$1中自由出现[n]因此无法使用公理a6
:%,4#[n](Vx:#nf($1,y))>(Vy:(Vx:#nf($1,y)))[n]#p
:%,5#[n](Vx:x=z)>(Vy:(Vx:x=z))[n]#p
:%,2$获取10µg推理素

// 可替换教程
:1st,3@公理a4解读：[n]#rp($0,$1,$2)的值[n]为将$0中自由出现的$1[n]全替换为$2后的新值[n](即replace)
:%*,5@假设中若有未化简的#rp函数[n]会导致匹配机制失效[n]因此会被系统禁止
:1st,2@[[crp]]公理a4解读：[n]#rp($0,$1,$2)执行替换前[n]还会外加验证$0中[n]可将$1替换为$2
:%,2@若本来自由出现的变量[n]替换后被量词约束[n]则不可替换
:%*,2#[n]Vx:(~Vy:(x=y)) > ~Vy:(y=y)[n]#p
:%*,2,1$你永远别想拿到这个奖励！
:%,3@例如#rp(~Vy:(x=y),x,y)[n]系统将验证失败[n]
:%*,1#[n]~(Vx:(~Vy:(x=y)) > ~Vy:(y=y))[n]#p
:%*,2,1$[[sysrule]]获取关于系统函数#nf、#rp[n]自动化简规则的提示
:%*,3@道理是这个道理[n]但否定挪进去后[n]真相就又变了[n](这边是附加题)
:%*,2#[n]Vx:(Vy:~(x=y)) > Vy:~(y=y)[n]#p
:%*,2,5#[n]~(Vx:(Vy:~(x=y)) > Vy:~(y=y))[n]#p
:%*,1,4$获取30µg推理素
:%*,3,1,5$你永远别想拿到这个奖励！
:1st,3,1#[[rp]][n](V$0:$1)>$1[n]#p
:%,4@带第四个参数的[n]#rp函数可部分替换[n]输入数字指定仅替换[n]第几个出现的变量[n]数字0表示全部替换[n]负数代表倒数第几个出现的变量
:%,1$[[a8]]解锁等词公理a8

// 谓词、变量、项教程

:1st,5@“∀”(V)叫做量词[n]量词后紧跟的叫变量[n]冒号后的公式叫[n]该量词的管辖范围[n]整个V$0:$1是公式
:%*,5@注意：变量都是“项”[n]不能说某项为真或假[n]只有公式才能讨论其真假[n]纯命题逻辑都是公式[n]即都可判断真假
:%*,0,3#[n](V$2:($0<>$1))>((V$2:$0)<>(V$2:$1))[n]#p
:%*,0,3,5$[[I1]]解锁门#I1
:%*,3#[n]Vx:x@y > Vx:x@y[n]#p
:%*,2#[[vx=x]][n]Vx:x=x[n]#p
:%,4@谓词属于“∈”（@）与[n]相等“=”只能连接项[n]连接后的整体是公式[n]如x@y与x=y都是公式[n]它们都能谈论真假
:%*,1@所有命题逻辑连词符号[n]即>、<>、~、&、|[n]都只能连接公式[n]不能直接连接项[n]连接后的整体也是公式
:%*,1,4@比如输入Vx:x>x[n]系统会报错[n]因为x出现在V后[n]就判定x为变量[n]而“>”不能连接变量
// :%,4@

:vx=x,5$[[a7]]解锁等词公理a7
:vx=x,4$获取10µg推理素

// 等词性质

:a8,1#[n]$0=$1⊢$1=$0[n]#d
:%*,4,5@a8公理使用提示1[n]若想把$a=$b中的$b替换成$c[n]写“#rp($a=$b,$b,$c,0)”[n]会发现系统无法计算#rp函数[n]因为$a的值不确定，[n]不能判断是否会[n]也包含$b并参与替换。
:%*,4@a8公理使用提示2[n]若想把$a=$b中的$a替换成$c[n]写“#rp($a=$b,$a,$c,1)”[n]则没问题，因为$a第一个出现[n]是一定要被替换的。因此[n]让系统只替换第一个变量[n]不再管后面的变量即可
:%*,2$获取30µg推理素
:%,1@导航提示：[n]1.这里离解锁皮亚诺公理[n]ZFC公理与类型层[n]仅有三个方块距离了，[n]2.旁边有着#nf与<>的门后[n]可解锁一阶逻辑大礼包
:%*,2#[[terr1]](E$0:($1|#nf($2,$0))) <>[n] ((E$0:$1)|#nf($2,$0))[n]#p
:%*,3#[[terr2]](V$0:($1&#nf($2,$0))) <>[n] ((V$0:$1)&#nf($2,$0))[n]#p
:%*,2,5#$a1=$a2,$b1=$b2 ⊢[n]$a1@$b1 <> $a2@$b2[n]#d
:%*,2,5,2#[[elV1]]Vx:Vy:f(x)=f(y)[n]⊢ f($x)=f($y)[n]#d
:%*,2,5,2,1@连续消除两个量词[n]需要局部变量机制：[n]由“#”开头的叫局部变量[n]它保证与一切“$XX”的值都不同[n]ZFC集合论后不远的包含符号[n]周围有详细介绍使用方法
:%*,2,5,2,5@
:%*,2,5,3#(V$0:($1>#nf($2,$0))) <>[n] ((E$0:$1)>#nf($2,$0))[n]#p
:%*,2,5,4#(V$0:($1|#nf($2,$0))) <>[n] ((V$0:$1)|#nf($2,$0))[n]#p
:%*,2,5,3,5$[[.1st]]解锁一阶逻辑大礼包
:%*,4;1;2;1;1;1;1;1;1;2;2;1;1;1;1;1;1@
:%*,4,1,2,1,1,1,1,1,1#通过此门需消耗推理素5mg
:%,1#[n]$0=$1,$1=$2⊢$0=$2[n]#d
:%*,3#(Vx:Ey:f(x)=g(y)) <>[n](Vm:En:f(m)=g(n))[n]#p
:%*,3,5$[[mnt]]拆除门#rp
:%*,3,4$获取333µg推理素
:%,2#通过此门需消耗推理素100µg
:%*,5$[[type]]解锁类型层
:%*,3$[[peano]]解锁皮亚诺公理[n]apn1 - apn5[n]与10以内数字定义
:%,1$[[aExt]]解锁ZFC集合论[n]外延公理(aExt)
:%,2@卡住了？可交钱绕行
:%,1#通过此门需消耗推理素100µg
:%,2;1;1@
:%,1@其实若解锁了[n]互推替换元定理[n]就可直接生成：[n]先证( ⊢ (~(($0>$1) > ~($1>$0)) <> ($0<>$1)))[n]然后使用元定理[n]把aExt的内容作为$$2[n]$$3填0（意思为全部替换）
:%,1@如果用不惯或未解锁元定理[n]也可使用一阶逻辑大礼包中的[n]“.<>rxx”系列推理宏规则[n]结合“.<>s”、“.<>t”、“.<>1”等[n]手动等价代换得到
:%,1#通过此门需消耗推理素66µg
:%,1@
:1st,5,3,4$[[dE]]解锁量词符号[n]“∃”(E)
:%*,2#[n](E$0:($1|$2)) <> ((E$0:$1)|(E$0:$2))[n]#p
:%*,2,5$获取123µg推理素
:%,5#[n]E$0:$0=$1[n]#p
:%,5$获取30µg推理素

// mcvt, mvt, vxvy = vyvx
:1st,3,3#通过此门需消耗推理素100µg
:%*,4$[[base-3]]获得奖励：[n]若序数进位基底大于5[n]则将基底减1
:%*,5$[[mcvt]]解锁条件概括元定理[n]并拆除门#V[n](门#V后解锁概括元定理)
:%,1#通过此门需消耗推理素100µg
:%*,4$[[base-4]]获得奖励：[n]若序数进位基底大于5[n]则将基底减1
:%*,2#[[V]]该门后可解锁概括元定理[n]#V
:%*,2,5$[[mvt]]解锁概括元定理
:%,1#[n](V$0:V$1:$2)>$2[n]#p
:%,4#[n](V$0:V$1:$2)>(V$1:V$0:$2)[n]#p
:%,4#[n](E$0:E$1:$2)>(E$1:E$0:$2)[n]#p
:%*,2$获取60µg推理素
:%,4#[n](E$0:V$1:$2)>(V$1:E$0:$2)[n]#p
:%,5$获取70µg推理素
:mcvt,0#(V$0:($1&$2)) <> ((V$0:$1) & (V$0:$2))[n]#p
:%,2$获取40µg推理素
:mcvt,3@条件概括元定理可把[n]定理的所有条件和结论[n]都加上相同的量词
:mvt,0@概括元定理是说[n]若定理的所有条件[n]都没自由出现$0[n]则可单独在结论中[n]加上量词V$0
// 分离公理与空集

:aExt,1#[n]Vx:Vy:((Vz:z@x<>z@y)>(x=y))[n]#p
:%,1$[[aSep]]解锁ZFC集合论[n]分离公理(aSep)
:%*,2#[[ext<]]Vx:Vy:((x<y)>((y<x)>(x=y)))[n]#p
:%*,2,3#[[elV2]](($x<$y)&($y<$x)) > ($x=$y)[n]#p
:%*,2,2$获取150µg推理素
:%*,2,3,5$获取198µg推理素
:%*,2,3,1@看似直接使用两次[n]“<a4”规则即可消去量词[n]但$x或$y可能是y或x[n]因此可能一个变量被替换两次
:%*,2,3,1,5@解决方法：先把x、y替换成[n]与$x、$y永不相同的[n]#x、#y，然后用概括定理[n]加上量词V#x:V#y:[n](也可先用a6公理加量词[n]再用“vv<a4”消内部量词[n]并同时将x/y替换为#x/#y）
:%*,2,3,2@然后再使用两次[n]“<a4”规则消去量词[n]这时由于$x、$y不可能是[n]#x、#y，不再出现循环替换问题

:%*,2,5@受够了自由出现[n]的条件#nf了吗？[n]快试用“#”开头的局部变量[n]在录制宏的过程中[n]它将视为与一切“$”开头[n]的符号都不同[n]摆脱#nf的困扰

:%*,3#(x<y)>((y<z)>(x<z))[n]#p
:%*,3,2$获取50µg推理素
:%,1@尝试把分离公理中的$0[n]替换为~(z=z)[n]以证明空集存在
:%*,1#通过此门需消耗推理素5mg
:%*,5$[[d<]]解锁谓词包含符号“⊂”(<)
:%,2#[[empty]][n]Ey:Vz:~(z@y)[n]#p
:%*,5#[n]Vx:Vy:~Va:~Vz:[n](z@a<>(z@x & z@y))[n]#p
:%*,5,2$获取10µg推理素
:%*,5,0#[n]Vx:Vy:E!a:Vz:[n](z@a<>(z@x & z@y))[n]#p
:%*,5,0,5$[[dI]]解锁交集运算符[n]“∩”(I)
:%*,5,0,5,0#通过此门需消耗推理素5mg
:%,1@
:%,1@提示:配对公理大概说的是[n]任意两个集合x,y[n]都存在集合{x,y}
:%,1#[[beforePair]]通过此门需消耗推理素500µg
:%*,3#[[port-rp]]未解锁的闸门无法通过[n]请寻找线索解开闸门[n]#rp
    :%,2#V$x:($1 <> $2) ⊢[n](E!$x: $1) <> (E!$x: $2)[n]#d
    :port-rp,1;2;1@
    :%,1#V$x:($1 <> $2) ⊢ [n]#rp($1,$x,$y)<>#rp($2,$x,$y)[n]#d
    :%,1@
    :%,1#通过此门需消耗推理素4mg
    :%,1$[[ifft-EU]]解锁替换元定理中[n]可跨越量词E!进行替换
    :port-rp,1@后方解锁替换元定理中[n]可跨越量词E!进行替换
    :port-rp,3@特称元定理可给[n]任何带一个条件的规则[n]的条件和结论都加上[n]相同的存在量词
    :port-rp,2@尝试执行规则">veve.Vcn"[n]试试一键证明[n]“解锁特称元定理”方块[n]旁边的定理
    :port-rp,5#V$4:E$3:V$2:E$0:V$x:#nf($1,$z) >[n]V$4:E$3:V$2:E$0:V$z:#rp(#nf($1,$z),$x,$z)[n]#p
    :port-rp,4#通过此门需消耗推理素10mg
    :%,5$[[met]]解锁特称元定理
:d<,4@向前走，有更多关于证明[n]空集存在性的提示
:%,3@首先把分离公理[n]通过互推替换化简为[n]正常人类使用的形式：[n]Vx:Ey:Vz:[n](z@y <> (z@x & ~z=z))
:%,3@由于我们通过a7公理[n]知道z=z是对的，因此[n]~z=z是错的，[n]继而有z@x & ~z=z是错的[n]则与之等价的z@y也是错的
:%,3@具体做法：先证明$zz ⊢ [n]($zy<>($zx&~$zz)) <> ~$zy[n](提示：命题逻辑自动推理[n]元规则可一键完成该证明)[n]然后将$XXX代入具体值[n]使用互推替换即可
:d<,2#[[.<i]]$0<$0[n]#p
:%,5$获取30µg推理素

:crp,3#通过此门需消耗推理素19µg
:%,5$[[dE!]]解锁唯一存在量词[n]“∃!”(E!)
:%,5#[n](E!x:Vy:~y@x)<>[n]((Ex:Vy:~(y@x))&(Vx:Vz:(((Vy:~(y@x))&Vy:~(y@z)) > x=z)))[n]#p
:%,5$获取49µg推理素
:%,0@
:%,5#[n]E!x:Vy:~y@x[n]#p
:%,2#通过此门需消耗推理素501µg
:%,5$[[d{}]]解锁空集常量符号[n]“{}”
:dE!,2#(Ex:Ey:(#nf($a,y)&#nf($b,x)))<>(Ex:#nf($a,y)&Ey:#nf($b,x))[n]#p
:%,5$获取399µg推理素
:dE!,4#通过此门需消耗推理素2mg
:%,1$[[omit-fn]]解锁简化显示#nf等系统函数
// 配对公理、正规公理

:beforePair,4$[[aPair]]解锁ZFC集合论[n]配对公理(aPair)
:%*,4#[n]Vx:Vy:Ez:(x@z & y@z)[n]#p
:%,5#[n]Vx:Vy:E!z:Va:[n](a@z <> (a=x | a=y))[n]#p
:%,2#通过此门需消耗推理素1mg
:%,5@
:%,0$[[d{..}]]解锁配对集合构造符号[n]“{#0,#1}”
:%,5#[n]{$0,$1}={$1,$0}[n]#p
:%*,2$[[d{.}]]解锁一元集合构造符号[n]“{#0}”
:%,0#[n]$0@{$0,$1}[n]#p
:%*,3$获取99µg推理素
:%,5#[n]Va:((Ex:x@a) > ~(a@{{},{}}))[n]#p
:%*,3$获取188µg推理素
:%,0#[n]a@{b} <> a=b[n]#p
:%*,0#通过此门需消耗推理素5mg
:%*,0,5$[[.zfc]]解锁ZFC简化大礼包[n]即用更方便的[n]人类习惯的符号[n]重新书写ZFC所有公理
:%,5#[n]{a}={b} <> a=b[n]#p
:%*,3#$c\\($aU$b)=($c\\$a)I($c\\$b)[n]#p
:%*,3,1@提示：解锁差集符号“\\”[n]需要先解锁有序数对[n]或重新证明皮亚诺公理
:%*,3,2$获取4.4mg推理素
:%*,5#[[a@a]][n]~(a@{{a}})[n]#p
:%*,5,2@集合论中直接定义：[n]0={}，S(x)=xU{x}[n]若皮亚诺公理此时[n]不限制只对数推理的话[n]会推出矛盾
:%*,5,2,1@若apn5中去掉$0中[n]不自由出现x的条件[n]也能推出矛盾。
:%*,5,2,1,3@[[apn5-err-in]]向前走获得错误的[n]apn5公理apn5x[n]该公理只能在前方[n]门后的区域中使用
:%*,5,2,1,1@分离公理中的[n]不自由出现条件[n]取消掉后也能推出矛盾。
:%*,5,2,1,1,5@[[asep-err-in]]向前走获得错误的[n]asep公理asepx[n]该公理只能在前方[n]门后的区域中使用
:%*,5,3$获取42mg推理素
:%*,5,5$[[aChoice]]解锁ZFC集合论[n]选择公理(aChoice)
:%,0#[n]{a,b}={b,c} <> a=c[n]#p
:%*,2$[[aReg]]解锁ZFC集合论[n]正规公理(aReg)
    :%*,3#[n]{{$a},{$a,$b}}={{$c},{$c,$d}}[n] ⊢ ($a=$c) & ($b=$d) [n]#d
    :%*,3,4$[[d()]]解锁有序数对符号[n] (a, b)
    :%*,4#通过此门需消耗推理素0.1mg
    :d(),2#通过此门需消耗推理素20mg
    :d(),4#通过此门需消耗推理素20mg
    :d(),3@整个{..|..}是项[n]其中z(x)中的x被[n]广义量词“x@y”约束[n]注意y中的x（如果有）是自由的
    :d(),4,5$[[d{@|}]]解锁分离公理[n]构造集合符号
    :d(),3,5@{x@y|z(x)}的意思是[n]把集合y中满足条件z(x)[n]的元素拿出来[n]构成新集合。[n]z是谓词，z(x)是公式
    :d(),3,1@{z(x)|x@y}的意思是[n]把集合y的所有元素x[n]通过函数z映射到z(x)[n]构成新集合。[n]z是函数，z(x)是项
    :d(),2,1$[[d{|@}]]解锁替换公理[n]构造集合符号
    :d(),0,0,5#[[.pn1]]{}@omega[n]#p
    :d(),3,4# #nf($x,$z) I #nf($y,$z) = [n]{$z@#nf($x,$z)||$z@#nf($y,$z)}[n]#p
    :%,1$[[dsub]]解锁差集运算符[n]“\\”
    :d(),3,2#~0@(N\\{0})[n]#p
    // :d(),3,2#($a\\$b)U$b=$aU$b[n]#p
    :d(),3,2,5$获取5mg推理素
    
    :d(),1# Vx:Vy:E!d:Va:Vb:[n]((a@x&b@y)>(a,b)@d)[n]#p
    :d(),1,2$[[dX]]解锁集合[n]笛卡尔积运算[n]“×”(X)
    :dX,1#(1,2)@NXN[n]#p
    :%,1;1;1@..........
    :%,1#Va:Vb:Vx:(x@aXb > [n]E!m:E!n:x=(m,n))[n]#p
    :%,1@
    :%,1$[[d()pr]]解锁有序数对投影函数[n]Pr1与Pr2
    :%,1#x = Pr1((x,y))[n]#p
    :%,1#y = Pr2((x,y))[n]#p
    :%,2#Vx:(x@(N\\{0})>Ey:x=S(y))[n]#p
    :%,1#Vx:(x@NX{0,1}>[n](Pr2(x)=0|Pr2(x)=1))[n]#p
    :%,1@ZFC中把整数a-b看成(a,b)[n]其中a与b是自然数
    :%,1$[[dfZ]]解锁整数等价类生成函数“Z”
    :%,1@若a+d=b+c，则[n](a,b)跟(c,d)表示同一个整数[n]因此ZFC中把整数[n]定义为整个等价类的集合
    :%,1$[[dZ]]解锁整数集合(Z)
    :%,1#Z((0,0))=Z((1,1))[n]#p
    :%,1#Z((1,2))=Z((0,1))[n]#p
    :%*,3@有难度？绕行的路上给些提示
    :%*,3,1#[[.Zr]]$x@N,$y@N,$z@N[n]⊢Z(($x,$y))=Z(($x+$z,$y+$z))[n]#d
    :%,2#x1a@N,x2a@N,x1b@N,x2b@N,[n]y1a@N,y2a@N,y1b@N,y2b@N,[n]Z((x1a,x2a))=Z((x1b,x2b)),[n]Z((y1a,y2a))=Z((y1b,y2b))[n]⊢Z((x1a+y1a,x2a+y2a))[n]=Z((x1b+y1b,x2b+y2b))[n]#d
    :%,1$[[dZ+]]解锁整数加法运算
    :%,1#$1@Z>($2@Z>($1+$2)@Z)[n]#p
    :%,1#$1@Z>($2@Z>($1+$2)=($2+$1))[n]#p
    :%,1$[[dZ<=]]解锁整数序关系谓词
    :%,1#($x@Z&$y@Z&$x<=$y&$y<=$x)[n]>$x=$y[n]#p
    :%,2$[[dZ*]]解锁整数乘法运算

    :.Zr,5$[[dZn]]解锁整数常数定义[n]如dZ0/dZ-1/dZ2[n]将引入整数+0/-1/+2
    :.Zr,2$获取5mg推理素
    :%,1#$x@N,$y@N,$z@N[n]⊢Z(($x,$y))=Z(($z,0))[n]<>$x=$y+$z[n]#d
    :%,1$获取5mg推理素
    :%,1#$x@N,$y@N,$z@N[n]⊢Z(($x,$y))=Z((0,$z))[n]<>$y=$x+$z[n]#d
    :%,1$获取5mg推理素
    :%,1#$x@N,$y@N[n]⊢$x<=$y|$x>=$y[n]#d
    :%,1#通过此门需消耗推理素0.1g

    // :dX,1#~(1,0)@NX(N\{0})[n]#p


    :.pn1,3@我们将在集合论框架下[n]实现皮亚诺公理系统
    :%,1;2;1@
    :%,1@空集相当于0[n]后继S(x)相当于xU{x}
    :%,1@要将ω与ℕ两者等同[n]就要重新“证明”5个公理
    :%,1@
    :%,1#[[.pn2]]Vn:(n@omega > nU{n}@omega)[n]#p
    :%,2;1;1;@oma
    :%,1@提示：证明序数ω2的存在性[n]需要使用替换公理
    :%,1;1;1@
    :%,1#[[.pn3]]Vx:~xU{x}={}[n]#p
    :%,2;1;1;1;1;1@..........
    :%,1@旁边付费看提示
    :%,1#[[.pn4]]Vx:Vy:(xU{x}=yU{y}>x=y)[n]#p
    :%,2;1;1;1;1;1;1@...............
    :%,1#[[.pn5]]#rp(#nf($0,x),$1,{})>[n](Vx:(x@omega>(#rp(#nf($0,x),$1,x)>[n]#rp(#nf($0,x),$1,xU{x})))[n]>Vx:(x@omega>#rp(#nf($0,x),$1,x)))[n]#p
    :%,2;1;1;1@................
    :%,1$[[del-pn]]拆除门#pn
    :%,1#[[.pn]]未解锁的闸门无法通过[n]请寻找线索解开闸门[n]#pn
    :%,4$获取10mg推理素
    :.pn,3$[[dSd0]]解锁自然数与[n]后继函数[n]的集合论定义
    
    :.pn4,5,5#通过此门需消耗推理素3mg
    :%,3@
    :%*,3@从前提易得x@yU{y}[n]因此要么x=y要么x@y[n]正规公理可证x@y不可能[n]因此x=y得证
    :%,2@提示还不够？[n]没事，继续付费嘛！
    :%,2#通过此门需消耗推理素3mg
    :%,3@
    :%,3@因为x跟y的地位对称[n]所以同样可得到y@x[n]即：若~x=y，有x@y&y@x成立。[n]易证集合{x,y}违背了正规公理[n]说明假设~x=y错误

    :.pn2,5@侧面买提示
    :%,3#通过此门需消耗推理素3mg
    :%,3@
    :%,3@由omega定义可知[n]x属于omega等价于[n]x属于任意一个归纳集S[n]对xU{x}也同理[n]x@omega推出x@S[n]归纳集定义可知[n]x@S能推出xU{x}@S
    :.pn5,5,0@侧面买提示2
    :%,3#通过此门需消耗推理素4mg
    :%,3@
    :%,3@自然数是最小的归纳集[n]因此{x@omega|P(x)}=omega[n]所以P(x)对所有自然数成立
    :.pn5,5@侧面买提示1
    :%,3#通过此门需消耗推理素5mg
    :%,3@
    :%,3@归纳集指满足{}@x且[n]Va:(a@x>aU{a}@x)的集合[n]若已知P(0)、Vx:(P(x)>P(xU{x}))[n]可证{x@omega|P(x)}是个归纳集

    :.pn5,2,2#$x@N,$y@N ⊢[n]($x<=$y&~$x=$y) <> $x@$y[n]#d
    :%,5$获取30mg推理素

:aReg,3#Equiv(omega,omegaU{omega})[n]#p
:%,1@提示：omega、Equiv[n]的定义分别在[n]序数ω^ω+ω^2与[n]序数ω^ω^ω附近
:%,2$获取1.5g推理素
:%,1@提示：利用反证法[n]假设存在双射r，则可[n]通过“对角线法则”[n]构造矛盾
:%,1#~Equiv(omega,Pow(omega))[n]#p
:%,1$[[delAl]]拆除门#א
:%,1$获取12.3456789g推理素
:%,1@提示：门#א在序数的尽头之后
:aChoice,2#[[vwo]]VxEr:WellOrder(x, r)[n]#p
:%*,1@提示：解锁WellOrder(良序)的定义[n]需要到达序数ω^(ω2)[n]（前往该序数需在[n]解锁并集公理的不远处[n]用替代公理证明[n]{ω,ω+1,ω+2,...}[n]的存在性）
:%,2$获取420g推理素
// 并集、幂集、无穷公理、序数之门
:empty,3@卡住了？前往序数[n]ω³+ω²3+ω5+7查看[n]证明并集符号U合法性的提示
:empty,2$[[aUnion]]解锁ZFC集合论[n]并集公理(aUnion)
:%,5#Vx:Vy:Ez:Vw:[n](w@z <> (w@x | w@y))[n]#p
:%*,5$[[dU]]解锁并集公理定义的“Union”函数[n]与二元函数符号“U”
:%,2$[[aPow]]解锁ZFC集合论[n]幂集公理(aPow)
:aUnion,4#Vx:Ey:Vz:[n](z@y <> z<x)[n]#p
:%,1$[[base5]]将序数进位基底[n]降至5[n](提示：到达在#ω门后的[n]序数ω^ω后才能[n]解锁无穷公理)
:base5,1#Ex:(omega@x &[n]Vy:(y@x > yU{y}@x))[n]#p
:%*,3$[[ww2]]到达序数[n]ω^(ω2)
:%,1$[[base4]]将序数进位基底[n]降至4
:%,1#Ex:Vz:(z@x>(z={} | [n]Ey:(y@x & z=yU{y})))[n]#p
// :%,1#Ex:({}@x &[n]Vy:(y@x > yU{y}@x))[n]#p
:%,1$[[w4234]]到达序数[n]ω⁴4+ω³4+ω²4
:%,0#[[UUII]]($aI$b)U$c = ($aU$c)I($bU$c)[n]#p
:%,1$[[aRepl]]解锁ZFC集合论[n]替换公理(aRepl)
// iff定理

:dE,1#[n]V$2:($0<>$1)[n]⊢(E$2:$0)<>(E$2:$1)[n]#d
:%,5$[[I2]]解锁门#I2

:port-iff,2@此处向前有开#I3的钥匙
:port-iff,2,5#[n]$a1<>$a2,$b1<>$b2[n]⊢($a1>$b1)<>($a2>$b2)[n]#d
:%*,4$获取24µg推理素
:port-iff,2,4#[n]$a1<>$a2,$b1<>$b2[n]⊢($a1<>$b1)<>($a2<>$b2)[n]#d
:%*,2$获取24µg推理素
:%,5#[n]~($0<>$1)<>(~$0<>$1)[n]#p
:%*,5#[n]$a1<>$a2,$b1<>$b2[n]⊢($a1&$b1)<>($a2&$b2)[n]#d
:%*,5,4$获取29µg推理素
:%,4#[n]$a1<>$a2,$b1<>$b2[n]⊢($a1|$b1)<>($a2|$b2)[n]#d
:%*,2$获取29µg推理素
:%,5$[[I3]]解锁门#I3
:iff,1#[[I1I2I3]]该门上有三把锁：[n]#I1 #I2 #I3[n](提示：前两把锁在[n]解锁一阶逻辑之后)
:%*,3$[[mifft]]解锁互推替换元定理
:%*,3,5#通过此门需消耗推理素6mg
:%*,2$获取1mg推理素
:%,4;5@

:%,2#[n](b>a),(c>a)⊢[n]((a&b<>a&c)<>(b<>c))[n]#d
:%*,4$获取37µg推理素
:%,1#[n](b>~a),(c>~a)⊢[n]((a|b<>a|c)<>(b<>c))[n]#d
:%*,2$获取37µg推理素

// PeanoAxiom


:peano,1#通过此门需消耗推理素1mg
:peano,4#~1=0[n]#p
:%,5$[[add-mul]]解锁加法与乘法算数
:peano,2#~1=2[n]#p
:%,1#1+0=1[n]#p
:%,2#[[1+1]]1+1=2[n]#p
:%*,3#3+4=7[n]#p
:%*,2#4+3=7[n]#p
:%*,3,1$获取111µg推理素
:%*,4#[[commu+]]$0@N>($1@N>[n]$0+$1=$1+$0)[n]#p
:%*,4,5$获取1.11mg推理素
:%,1#[[2x2]]2*2=4[n]#p
:%,1#Vx:(x@N>x*0=0)[n]#p
:%,1#$0@N>$0*1=$0[n]#p
:%,1#$0@N>$0*3=$0+($0+$0)[n]#p
:%,1#[[commux]]$1@N>($2@N>[n]$1*$2=$2*$1)[n]#p
:%,1#[[xdistr]]$1@N>($2@N>($3@N>[n]($1+$2)*$3=[n]($1*$3)+($2*$3)))[n]#p
:%*,0#[[3<4]]Vx:(x@N>~(4+x=3))[n]#p
    :%,1#Vx:(x@N>~(4+x=0))[n]#p
    :%,1#Vx:(x@N>~(4+x=1))[n]#p
:1+1,3,5@证加法交换律[n]需要用数学归纳法apn5[n]若不会证[n]请向前走看教程
:%,5@首先证明对0成立[n]Vy:(y@N>0+y=y+0)[n]提示：证明该命题[n]也需要数学归纳法
:%,0#Vy:(y@N>0+y=y)[n]#p
:%,5#Vx:Vy:(x@N>(y@N>[n](x+y=y+x >[n]S(x+y)=S(y+x))))[n]#p
:%,0#Vx:Vy:(x@N>(y@N>[n]S(y)+x=S(y+x)))
:%,5@下面是重点：消去量词[n]看似直接使用两次[n]“<a4”规则即可消去量词[n]但$0或$1可能是y或x[n]因此可能一个变量被替换两次
:%,0#[[elV3]]$0@N>($1@N>S($0)+$1=S($0+$1))[n]#p
:3<4,1#[[5R6]]Vx:(x@N>~(x*5=6))[n]#p
:3<4,2$获取3.4mg推理素
:%*,2#Vy:(y@N>Ex:y*(y+1)=2*x)[n]#p
:%*,2,5$获取4.321mg推理素
:%,1#Vx:(x@N>~(x+5=1))[n]#p
:%*,3$[[d<=]]解锁序关系谓词符号[n]“≤”(<=)与“≥”(>=)
    :%*,2#$x@N>$x<=$x[n]#p
    :%*,2,1#通过此门需消耗推理素120mg
    :%*,2,2#($x@N&$y@N&$x<=$y&$y<=$x)[n]>$x=$y[n]#p
    :%*,2,2,5$获取2.1mg推理素
    :%*,2,2,1#($x@N&$y@N&$z@N[n]&$x<=$y&$y<=$z)[n]>$x<=$z[n]#p
    :%*,2,2,1,5$获取2.2mg推理素
    :%*,2,2,1,2#($x@N&$y@N&$z@N[n]&$x<=$y)[n]>$x+$z<=$y+$z[n]#p
    :%*,2,2,1,2,5$获取2.3mg推理素
    :%*,2,2,1,2,1#($x@N&$y@N&$z@N[n]&$x+$z<=$y+$z)[n]>$x<=$y[n]#p
    :%*,2,2,1,2,1,4$获取2.4mg推理素
    :%*,2,2,1,2,1,1#($x@N&$y@N)[n]>$x<=$x*S($y)[n]#p
    :%*,2,2,1,2,1,1,5$获取2.5mg推理素
    :%*,2,2,1,2,1,1,1#($x@N&$y@N&$z@N[n]&$x<=$y)[n]>$x*$z<=$y*$z[n]#p
    :%*,2,2,1,2,1,1,1,4$获取2.6mg推理素
    :%*,2,2,1,2,1,1,1,1#($x@N&$y@N&$z@N[n]&$x*S($z)<=$y*S($z))[n]>$x<=$y[n]#p
    :%*,2,2,1,2,1,1,1,1,1$[[ddiv]]解锁整除谓词“∣”(/|)
    :%*,2,2,1,2,1,1,1,1,1,1#x@N>((1/|x)&(x/|0))[n]#p

:%,1#Vx:(x@N>~(x*5=1))[n]#p
:%*,2#通过此门需消耗推理素5mg
:%*,2,5$[[kit+*]]获得常见[n]加法乘法性质定理[n]大礼包！
:%,1$获取5.1mg推理素
:%*,3#1*2*3*4*5*6*7*8*9 = [n]10*(8+10*(8+10*(2+10*(6+10*3))))[n]#p
:%*,3,5$获取1mg推理素
:%*,4#(-13)*(+23)=(-299)[n]#p
:%*,4,4$[[dZop]]解锁自动计算[n]整数的加减法与乘法[n]如.1*-2生成[n]⊢ +1 * -2 = -2

:%,2#通过此门需消耗推理素5.09mg
:%*,1@解锁后命令行输入.3+4[n]可生成规则⊢3+4=7[n]乘法同理
:%,5$[[natop]]解锁所有正常计算机[n]能表示的自然数常量[n]且可自动计算加法与乘法
:5R6,1$[[dPrime]]解锁谓词“是素数”[n](Prime)
:5R6,2#Prime(2)[n]#p
:%*,4#~Prime(4)[n]#p
:%*,4,5$获取4mg推理素
:%*,4,4#Vz:((z@N&~z=0&z<=3) > z/|6)[n]#p
:%*,4,4,4#[[ex!]]Vx:Ey:(~y=0&Vz:[n]((x@N&z@N&~z=0&z<=x) > (z/|y)))[n]#p
:%*,4,4,4,5$获取123.456mg推理素
:%*,2#[[prm7]]Prime(7)[n]#p
:%*,2,1$获取7mg推理素
:%*,2,2#Vx:Vy:((x@N&~x=0&~x=1)[n]>(x/|y>~(x/|y+1)))[n]#p
:%*,2,2,2#[[infprm]]Vx:(x@N>Ey:(Prime(y) & y>=x))[n]#p
:%*,2,2,2,1$获取999mg推理素


// inconsist axioms

:apn5-err-in,1#退出该门前请[n]清除所有依赖错误公理[n]的定理与规则！[n]然后执行“del apn5x”[n](该门为自动门，且无法被拆)[n]#imm
:%,2$[[apn5-err-out]]获得错误公理apn5x
:%,1#⊢ $1[n]#d
:%,4$获取5mg推理素
:asep-err-in,5#退出该门前请[n]清除所有依赖错误公理[n]的定理与规则！[n]然后执行“del asepx”[n](该门为自动门，且无法被拆)[n]#imm
:%,0$[[asep-err-out]]获得错误公理asepx
:%,5#⊢ $1[n]#d
:%,0$获取5mg推理素

// type theory

:port-iff,5@提示：建议有条件优先解锁[n]距此处两格的一阶逻辑，之后[n]才可能解锁皮亚诺公理[n]或ZFC集合论、类型层
:type,4@值a的类型是A[n]记作a:A
:type,5@#t闸门开启方法：[n]当类型层定理列表中有[n]门上写的类型的值时[n]才能通过闸门
:%*,0;5;0@
:%*,0#U[n]#t
:%*,0,5@类型的类型是U0[n]可简写成U[n]叫“宇宙”或“全类”[n]U0的类型是更大的全类U1
:%*,0,5,0,5#U2[n]#t
:%*,4@开启之门即为真理[n]谬误之门无法通过[n]提示：解锁“+”后继续前进[n]可大量挣钱与解锁ind_eq
    :%*,4,2#Pa:U,(not(not a))->a[n]#t
    :%*,4,3#eq (refl true) (refl true)[n]#t
    :%*,4,4#Pa:U, a + (not a)[n]#t
:%*,5#False[n]#t
:%,3#[[ttrue]]True[n]#t
:%,4@介绍函数符号“λ”（L）[n]与函数类型符号“Π”（P）[n]
    :%*,1@函数表达式为λx:A.b[n]其自变量x类型为A[n]输出(因变量)值为b
    :%*,1,1@若假设x:A能推出b:B[n]则λx:A.b的类型为[n]Πx:A,B
    :%*,1,1,1@注意函数输出类型B[n]可能依赖于x的值[n]以后将看到例子
    :%*,1,1,1,1@λx:A.x的类型是Πx:A,A[n]因为x的类型是A
    :%*,1,1,1,1,1@λx:A.True的类型是Πx:A,U[n]因为True的类型是U
    :%*,1,1,1,1,1,1@函数可以嵌套，如[n]λx:A.λy:B.x其实是[n]λx:A.(λy:B.x)[n]其类型是[n]Πx:A,Πy:B,A
    :%*,3@与量词类似[n]λ后的变量x出现在“.”后的表达式中[n]都是约束变量
    :%*,3,5@类似也有变量[n]在某表达式中[n]“自由出现”的概念
:%,5#Px:True,True[n]#t
:%,5#Px:False,False[n]#t
:%,0#Pa:U,U[n]#t
    :%*,4@不同于传统编程中的函数[n]函数输出值的类型[n]可以依赖于输入的自变量
    :%*,4,5@λx:U.λy:x.y类型为[n]Πx:U,Πy:x,x[n]因为λy:x.y[n]类型为Πy:x,x
:%,5#Pa:U,Px:a,a[n]#t
:%*,4$获取1mg推理素
:%,0#Px:True,Py:False,True[n]#t
:%,5#Pa:U,Pb:U,Px:a,Py:b,a[n]#t
:%,0$[[ttsimplFn]]解锁简写非依赖函数[n]类型符号“→”（->）
    :%*,4@若类型Πx:A,B中[n]x不在表达式B中自由出现[n]则该类型可省去x[n]并记作：A→B
    :%*,4,5@默认符号“→”是右结合的[n]即A→B→C为[n]A→(B→C)
    :%*,4,5,5@例：λx:A→B.x[n]的类型为(A→B)→(A→B)
    :%*,4,5,5,0@α-转换规则：[n]若z不在y中自由出现[n]则λx:A.y等价于λz:A.y'[n]其中y'是将y中自由的x[n]替换为z的结果
    :%*,4,5,5,0,5@α-转换前后的两表达式[n]是“定义相等”的[n]由系统自动判定；[n]函数类型[n]简写前(Π)后(→)[n]也“定义相等”
:%,5#Pa:U,Pb:U,Pc:U,a->b->a[n]#t
    :%*,5@若a:A，f:A->B[n]则函数f可以作用于a[n]记作f a[n]且f a类型为B
    :%*,5,2@下面介绍函数作用[n]
    :%*,5,0@β-归约规则：[n]若a:A，则有[n](λx:A.y) a等价于[n]将y中自由的x替换成a
    :%*,5,0,5,3@注意λx:A.y a的含义是[n]λx:A.(y a)而不是[n](λx:A.y) a
    :%*,5,0,5@计算(λx:A.λy:B.z) y时[n]将z中自由的x替换为y[n]将被λy:B约束[n]系统将自动使用α-等价[n]更改自变量名称来规避
    :%*,5,0,5,0@例：λx:A→B.λy:A.x y[n]的类型为(A→B)→(A→B)[n]因为x y的类型为B
    :%*,5,0,5,0,5@“存在某个值其类型是A”[n]可翻译成“A是定理”[n]那个值就是该命题[n]成立的证据
    :%*,5,0,5,0,5,0@旁边的#t门打不开？[n]付费后给提示
    :%*,5,0,5,0,5,0,3#[[hint-tt-a3]]通过此门需消耗推理素1mg
:%,0#Pa:U,Pb:U,Pc:U,(a->b->c)->(a->b)->(a->c)[n]#t
:%,5$[[ttnotFn]]解锁简写否定符号“not”[n]即，将“A->False”[n]简写为“not A”
    :%*,3$[[ttactic1]]解锁证明策略[n]intro/expand/apply
    :%*,5@由于False为空类型[n]因此若存在函数A->False[n]则若A类型不为空[n]就能推出False也不为空[n]因此A类型只能为空[n]即A是假命题
:%,0#Pa:U,a->(not (not a))[n]#t
:%,5#Pa:U,Pb:U,(a->b)->[n]((not b)->(not a))[n]#t
:%,0@类型论不同于经典逻辑[n]not(not A)仅表明[n]无法提供A为假的证据[n]并不能证明A为真[n]因此有扇相邻的门[n]是永远无法打开的
:%,5#Pa:U,(not (not (not a)))[n]->(not a)[n]#t
:%*,3@除了点击推荐的策略[n]还可直接输入策略点加号[n]比如目标是A[n]你恰好知道值a:A[n]可手动输入“apply a”[n]完成目标
:%*,2@如果觉得写这些函数太晕[n]建议把待证命题写在定理列表中[n]然后点证明策略的加号[n]使用解锁的证明助手
:%,0$[[ttEq]]解锁相等类型
:%*,4@若a与b类型都是A[n]则eq a b是个类型[n]可翻译为命题“a等于b”[n]显然若a与b定义相等[n]则命题“a等于b”一定成立[n]故引入“refl a”表示该事实
:%,5#eq true true[n]#t
:%*,2@注意现在有“定义相等”[n]与“命题相等”两种概念[n]由于是否定义相等[n]直接由系统判定[n]故不引入相等类型[n]就无法表达含假设命题[n]“若两值相等，则...”
:%*,2,5@提示：你可以在定理列表中[n]输入a:b，让系统[n]帮你检查a的类型[n]是否为b
:%*,2,5,0@提示：你可以在定理列表中[n]输入a===b，让系统[n]帮你检查a与b[n]是否定义相等
:%*,2,5,0,5@定义相等一定命题相等[n]反之不一定成立哦
:%,0#eq False False[n]#t
    :%*,2,1@“eq”其实有些隐藏参数[n]故其类型中带问号[n]系统可通过[n]上下文的函数作用[n]智能推断匹配[n]问号开头的类型
    :%*,2,1,0@[n]完整版是多元函数“@eq”[n]它接受以下参数[n]1.全类的下标数字u[n]2.类型a:Uu[n]3.值x:a与值y:a[n]最后得到一个命题(即Uu类型)[n]eq省略了前两个参数
    :%*,3$获取2mg推理素
    :%*,4@提示：一般来说没必要[n]使用“expand eq”将其[n]展开为“@eq”[n]展开前后虽都定义相等[n]但这只会让目标更复杂
:%,5#eq (False->False) (not False)[n]#t
:%*,5$[[ttrfl]]解锁rfl与相应证明策略[n](自动推断定义相等)
:%,0$[[ttNat]]解锁自然数nat类型
:%,5#eq (succ 0) 1[n]#t
:%*,2@自然数“1”定义为[n]succ 0[n]“2”定义为[n]succ (succ 0)[n] ...
:%,0$[[ttBool]]解锁布尔类型Bool
:%,2#eq 0b 0b[n]#t
:%,3$获取1mg推理素

// tt ind_xxx

:ttBool,5$[[ttindTrue]]解锁ind_True[n]提示：后方可解锁[n]ind_eq
:%,0@类型True只有一个值true[n]要证对任意x:True成立[n]其实只需论证对true成立[n]引入ind_True作为[n]该事实的证据
:%*,4@ind_True接受一个[n]关于x:True的命题[n]（命题的类型都是U，[n]因此通过函数True->U定义）[n]和该命题对true成立的证据[n]从而输出该命题对[n]任意x:True成立的证据
:%*,4,5@给些证旁边命题的提示：[n]看看表达式“ind_True [n](Lx:True.eq x true)”的类型
:%*,4,5,5@除了理解为命题[n]ind_True也可用于构造函数：[n]要构造f:True->XXX[n]只需给定f(true)的值即可[n]公理类型列表中[n]ind_True的计算规则[n]表示这一事实
:%,5#[[AllTrue]]Px:True,eq x true[n]#t
    :%,0$[[ttProd]]解锁积类型“X”与[n]有序对构造子“(,)”、[n]依赖值对类型“Σ”(S)与[n]依赖有序对构造子“pair”
    :%,5@对任意a:A与b:B[n]可以构造有序对[n](a,b) : A X B
    :%,0#nat X nat[n]#t
    :%*,3#not (True X False)[n]#t
    :%*,4@对积类型A X B[n]需要同时提供[n]a:A与b:B才能构造[n]因此积类型可[n]理解为命题“A且B”
    :%*,3,1$获取1mg推理素
    :%,5@若(a,b)中，b的类型依赖于[n]a的值，则是依赖值对类型。
    :%,0@即若B:A->U，a:A，b:B(a)，[n]则依赖值对记作[n]pair B a b : Sx:A,B(x)[n]若B是常函数则[n]退化为非依赖的积类型
    :%*,4@要构造类型Sx:nat,eq x 1[n]需要提供一个nat类型的值x[n]和eq x 1类型的值[n]明显我们可以选择1:nat[n]和refl 1 : eq 1 1[n]组成依赖有序对
    :%*,4,5@因此也可把该[n]依赖有序对类型[n]理解为命题“存在x:nat[n]使得eq x 1成立”
    :%,5#Sx:nat,eq x 1[n]#t
    :%*,4#通过此门需消耗推理素2mg
    :%*,4,1$[[ttacticEx]]解锁证明策略[n]“ex”与“case”
    :%*,4,5$[[tthyp]]解锁证明策略“hyp”（假设）[n]通过“hyp XXX”可以引入[n]新的证明子目标XXX[n]完成后将得到值:XXX[n]作为条件供后续证明使用[n]执行“hyp a:A”可将引入的目标[n]证明后得到的变量命名为a
    :%,0$[[ttSum]]解锁和类型“+”
    :%,3@和类型有左(inl)右(inr)[n]两个构造子[n]要构造类型A + B[n]仅需提供a:A或b:B即可[n]可翻译为“A或B”
    :%,5@提示：可以直接在定理列表中[n]写xxx : XXX[n]断言xxx有类型XXX[n]系统类型推断可自动[n]匹配并验证其正确性
    :%,0#True + False[n]#t
    :%,5#False + True[n]#t
    :%,5#通过此门需消耗推理素2mg
    :%,0$[[ttacticLR]]解锁证明策略[n]“left”/“right”
    :ttSum,0#Px:Bool,(eq x 0b)+(eq x 1b)[n]#t
    :%*,3@欲证该命题，需对x:Bool[n]通过ind_Bool分类讨论[n]建议采用“destruct”/“rfl”[n]“left”/“right”等证明策略[n]辅助构造证据
        :%*,3,3@积类型、依赖有序对[n]它们类似Bool、nat、[n]True、False、eq[n]都是归纳类型[n]也有相应的ind_xxx函数[n]和相应的destruct策略
        :%*,3,3,2$[[ttindProd]]解锁ind_Prod
            :ttindProd,5@依赖有序对类型只有唯一[n]的带两个参数的构造子pair[n]因此仅需证明由任意的两值[n]组成的有序对成立，[n]就可证对所有有序对成立
            :%,5#Pa:U,Pb:U,aXb -> a[n]#t
            :%*,2@提示：可通过ind_Prod定义函数[n]f : aXb -> a，[n]使得对任意x:a和y:b[n]有f (x,y) === x
            :%,0$获取3mg推理素
            :%*,4#Pa:U,Pb:U,Pc:U,(a->b->c)->((aXb)->c)[n]#t
            :%*,4,5$获取5mg推理素
            :%*,4,5,2#Pa:U,Pb:U,Pc:U,((aXb)->c)->(a->b->c)[n]#t
            :%*,4,5,2,5$获取5mg推理素
            :%*,5#Pa:U,Pb:U,Px:aXb,eq x (pr0 x, pr1 x)[n]#t
            :%,3$[[ttpr]]解锁投影函数pr0/pr1[n]与依赖投影函数prd1
            :%*,4#Px:U,Pa:U,Pb:U,(x->aXb)->(x->a)X(x->b)[n]#t
            :%*,4,5$获取5mg推理素
            :%*,2#Pa:U,Pb:U,(aXb)->(bXa)[n]#t
            :%*,2,1$获取2mg推理素
            :%,3#eq (pr0 (1,2)) 1[n]#t
            :%,3#eq (pr1 (3,4)) 4[n]#t
            :%,3$获取1mg推理素
        :ttindProd,0,4$[[ttindSum]]解锁ind_Sum
            :ttindSum,1@和类型A+B有两个[n]分别带一个参数的构造子[n]要证对所有A+B的值均成立[n]需分别证明任意a:A对(inl a)成立，[n]且任意b:B对(inr b)成立
            :%*,3#Pa:U,Pb:U,(a+b)->(b+a)[n]#t
            :%*,3,1$获取2mg推理素
            :%*,3,1,2#Pa:U,Pb:U,Pc:U,[n]((a+b)+c)->(a+(b+c))[n]#t
            :%*,3,1,2,5$获取2mg推理素
            :%,2#Pa:U,Pb:U,Pc:U,[n](a->c)->(b->c)->(a+b)->c[n]#t
            :%,1$获取2mg推理素
            :%*,2@不会解可交钱绕行
            :%*,2,1#通过此门需消耗推理素5mg
            :%*,2,1,2@
            :%,1#Pa:U,Pb:U,(a+b)->[n](not((not a) X (not b)))[n]#t
            :%,4;1;1;1;1;1@
        :%,0$[[ttindeq]]解锁ind_eq
            :%*,3#Pa:U,Pb:U,(eq a b)->(a->b)[n]#t
            :%*,2#not (eq True False)[n]#t
            :%*,2,5$获取15mg推理素
        :%,4@类型eq a b只有一个带参数[n]的构造子refl[n]且只能构造出类型eq a a[n]因此要证对任意m:eq a b成立[n]只需证明对refl a成立
            :%*,3#Pa:U,Px:a,Py:a,(eq x y)->(eq y x)[n]#t
            :%*,3,5$[[ttinveq]]解锁相等逆路径运算[n]inveq
        :%,5@注意eq类型本身带参数[n]而不像nat\和\积类型[n]只是构造子带参数[n]因此ind_eq是在对[n]一簇类型使用“归纳法”
            :%*,3#Pa:U,Px:a,Py:a,Pz:a,(eq x y)->(eq y z)->(eq x z)[n]#t
            :%*,3,1$[[ttcompeq]]解锁相等连接路径运算[n]compeq
            
    :ttSum,0,4@然而对任意类型a:U[n]并不是非真即假[n]比如有无法证明的命题[n]还有其它复杂的非命题类型[n]其实排中律Pa:U,a+(not a)[n]在类型论中不可证
    :%,3@若把命题逻辑中a3公理[n](~$0>~$1)>($1>$0)[n]改成($1>$0)>(~$0>~$1)[n]则跟类型论一样[n]无法证明排中律[n]与双重否定消去律[n]还有皮尔士定律
    :%,3$[[ttlazy]]解锁自动抄写技能[n]将上次碰到的门上的命题[n]抄下，以便使用证明助手
    :ttSum,0,5@类型论可引入额外的公理[n]让排中律成立[n]从而可推出双重否定消去[n]然而引入同伦类型论相关公理[n]可以证明刚才对任意[n]类型的排中律是错误的[n]仅能引入公理让[n]排中律对“纯命题”成立
    :%*,3#Pa:U,not(not(a+(not a)))[n]#t
    :%*,3,1#Pa:U,Pc:a->U,[n](not Sx:a,c x)->(Px:a,not(c x))[n]#t
    :%*,3,1,2#Pa:U,Pc:a->U,[n](Px:a,not(c x))->(not Sx:a,c x)[n]#t
    :%*,3,1,2,1#Pa:U,Pc:a->U,[n](Sx:a,c x)->(not Px:a,not(c x))[n]#t
    :%*,3,1,2,1,1#(Pa:U,(not(not a))->a)[n]->(Pa:U,a+(not a))[n]#t
    :%*,3,1,2,1,1,1#(Pa:U,a+(not a))->[n](Pa:U,(not(not a))->a)[n]#t
    :%*,3,1,2,1,1,1,1#[[ttpierce]](Pa:U,a+(not a))->[n](Pa:U,Pb:U,((a->b)->a)->a)[n]#t
    :%*,3,1,2,1,1,1,1,1$获取22mg推理素
    :%*,3,5$获取2mg推理素
    :%,4#[[lemlie]]not Pa:U,a+(not a)[n]#t
    :%,5$获取1g推理素
:ttBool,4$[[ttindFalse]]解锁ind_False
:%,3@类型False没有值[n]要证对任意x:False成立[n]其实都永远成立[n]引入ind_False作为[n]该事实的证据[n]即“从谬误能推出一切”
:%*,1#Pa:U,False->a[n]#t
:%*,1,5$获取2mg推理素
:%,5#False->(eq 0b 1b)[n]#t
:%,2$获取2mg推理素
:ttBool,3$[[ttindBool]]解锁ind_Bool[n]提示：后方可解锁[n]ind_nat与[n]策略destruct
:%,3@类型Bool有值0b和1b[n]要证对任意x:Bool成立[n]只需对0b与1b均成立[n]引入ind_Bool作为[n]该事实的证据
:%*,4@提示：需分别证明[n]1. (not (eq 0b 0b))[n]->(eq 0b 1b)；[n]2. (not (eq 1b 0b))[n]->(eq 1b 1b)。[n]还有困难可交钱给更多提示
:%*,4,5#通过此门需消耗推理素2mg
:%*,4,5,3@ind_Bool函数首先接受[n]一个关于x:Bool的命题[n]然后分别接受对0b与1b[n]成立的命题证据[n]最后返回该命题的证据
:%*,4,5,4@看看值“ind_Bool [n](Lx:Bool.(not (eq x 0b))[n]->(eq x 1b))”的类型[n]它将提醒你还需要[n]提供哪些参数
:%*,4,5,4,5@1.要证关于0b的命题[n]可通过假设“not (eq 0b 0b)”[n]得到一个False类型的值[n]然后用否定爆炸ind_False即可；[n]2.要证关于1b的命题则很简单
:%,5#Px:Bool,[n](not (eq x 0b))[n]->(eq x 1b)[n]#t
:%*,3$获取10mg推理素

// nat 递归函数

:%,5$[[ttindnat]]解锁ind_nat
:%*,5$[[base-2]]获得奖励：[n]若序数进位基底大于5[n]则将基底减1
:%*,2@自然数(nat)类型有两个构造子[n]“0”与“succ”[n]其中“succ”是带一个[n]递归参数的构造子
:%*,2,5@因此要证关于任意自然数的命题[n]要提供命题对0成立的证据[n]和对“succ”成立的证据
:%*,3@带递归参数的“succ”有点复杂[n]类似于积类型、和类型的参数[n]这意味着要证对任意的n:nat[n]命题对succ n都成立
:%*,3,5@然而该参数的递归性[n]却给我们提供了额外信息[n]即由于递归构造，[n]其实已经知道[n]命题对该参数n成立了
:%*,4@因此命题“对构造子succ成立”[n]其实是，对任意的n:nat[n]都有若已知命题对n成立[n]都能推出对succ n成立[n]即等价于数学归纳法
:%,0#eq (ind_nat (Lx:nat.Bool) 0b[n] (Lx:nat.Ly:Bool.1b) 0) 0b[n]#t
:%,5#eq (ind_nat (Lx:nat.Bool) 0b[n] (Lx:nat.Ly:Bool.1b) 1) 1b[n]#t
:%,0#eq (ind_nat (Lx:nat.Bool) 0b[n] (Lx:nat.Ly:Bool.1b) 2) 1b[n]#t
:%,5#eq (ind_nat (Lx:nat.Bool) 0b[n] (Lx:nat.Ly:Bool.1b) 3) 1b[n]#t
:%*,5$[[ttdestruct]]解锁证明策略destruct[n]它将自动引入ind_XXX[n]改写证明目标
:%*,4$[[ttsimpl]]解锁证明策略[n]“simpl”[n]即系统通过定义相等关系[n]自动化简证明目标
:%,0#Sf:nat->Bool,[n](eq (f 0) 0b) X[n](Pn:nat,eq (f (succ n)) 1b)[n]#t
:%*,2@ind_nat还可以理解为[n]递归函数的生成器：[n]构造函数f(x)需要给定f(0)的值，[n]然后对任意自然数n[n]通过n与f(n)的值来给出f(n+1)的值
:%,5$[[ttdbl]]解锁翻倍函数[n]double : nat->nat
:%,0$[[ttadd]]解锁加法函数[n]add : nat->nat->nat
:%,0#[[tt1+1]]eq (add 1 1) 2[n]#t
:%,5#Px:nat,eq (double (succ x))[n](succ (succ (double x)))[n]#t
:%,5#Px:nat,eq (add x 0) x[n]#t
:%*,0@来都来了，[n]这点小钱都出不起吗？[n]赶紧交钱，[n]不然你自己想办法过去
:%*,0,2#通过此门需消耗推理素7.777mg
:%,5#[[0+x]]Px:nat,eq (add 0 x) x[n]#t
:%*,4#Sf:nat->nat,[n](eq (f 0) 0) X[n](Pn:nat,eq (f(succ n)) n)[n]#t
:%*,4,1$[[ttpred]]解锁“前继”函数[n]pred : nat->nat
:%,5$[[ttrw]]解锁相等替换改写策略[n]rw(rewrite)[n]与rwb(rewrite back)
:%*,0@若m: eq a b，则[n]执行策略“rw m”[n]将通过ind_eq把证明目标[n]中的所有a改写成b
:%*,4@若没解锁ind_eq[n]系统会认为ind_eq未定义[n]无法使用该策略完成证明[n]提示：在ind_True的后方[n]可解锁ind_eq
:%,2@若m: eq a b，则[n]执行策略“rwb m”[n]将通过ind_eq把证明目标[n]中的所有b改写成a

:ttindTrue,2#[[x+x]]Px:nat,(eq x 1)->(eq (add x x) 2)[n]#t
:%,2#Pf:nat->nat->nat,[n](eq f add)->(eq (f 1 1) 2)[n]#t
:%,2#Pa:nat,Pb:nat,[n](eq a b)->[n](eq (succ a) (succ b))[n]#t
:%*,1@证succ m=succ n -> m=n 的提示：[n]直接用ind_nat归纳法[n]无法化简证明目标[n]需引入pred函数
:%*,1,4#Pa:nat,eq a (pred (succ a))[n]#t
:%*,1,4,4#Pa:nat,Pb:nat,[n](eq (succ a) (succ b))[n]->(eq (pred (succ a)) (pred (succ b)))[n]#t
:%,2#Pa:nat,Pb:nat,[n](eq (succ a) (succ b))[n]->(eq a b)[n]#t
:%*,5$获取10mg推理素
:%,2#not (eq 0 1)[n]#t
:%,5#[[1neq2]]not (eq 1 2)[n]#t
:%*,5$[[ttap]]解锁常见相等类型证据[n]ap/trans/apd
:%*,5,2@1.ap是x=y推出[n]f(x)=f(y)的证据[n]2.trans是若x=y，则命题对x成立[n]就能推出对y成立的证据[n]3.apd是ap的依赖类型函数版本[n]由于x与y可以不定义相等[n]故若f(x)与f(y)类型不同[n]无法直接用eq比较相等[n]需要通过trans函数转换到[n]同一类型后才能用eq比较
:%*,2$获取11.2mg推理素
:%,0$[[ttS1]]解锁圆周类型[n]S1[n](高阶同伦归纳类型)
:%,0,4#[[S1S1]]eq (refl base)[n](compeq loop (inveq loop))[n]#t
:%,3$[[tteqv]]解锁“等价”关系[n]eqv: U->U->U
:%,1@如果两个类型a与b之间[n]存在可逆的[n]一到一的双射f:a->b[n]则它们等价，记作[n]eqv A B
:%,1@“f是双射”即为[n]存在函数g与h[n]使得f(g x) = x[n]且h(f x) = x
:%,1#eqv True True[n]#t
:%,2#[[eqvid]]Pa:U,eqv a a[n]#t
:%,1#eqv (not True) False[n]#t
:%*,3$[[ttua]]解锁同伦类型论[n]泛等公理[n]ua[n](等价即相等)
:%*,2#[[looprfl]]not (eq (refl base) loop)[n]#t
:%*,2,1@loop不等于rfl的证明思路：[n]通过ind_S1构造映射f:S1->U[n]其中让f(base)=Bool，[n]f(loop)=ua(e)[n]若loop与rfl相等，则[n]ua(e)与rfl相等[n]后者能推出e(x)=x矛盾[n](e在双重否定消去思路中定义)
:%*,2,4$获取999mg推理素
:%,1#Px:True,Py:True,eqv (eq x y) True[n]#t
:%,1@双重否定消去错误[n]的证明思路：[n]设映射e:Bool->Bool[n]且e(0b)=1b，e(1b)=0b[n]可证e是Bool自身到自身的双射[n]即能构造eqv Bool Bool的证据
:%*,2#eqv (eqv Bool Bool) Bool[n]#t
:%*,2,1@则ua(e):eq Bool Bool[n]通过ua(e)使用ind_eq[n]可证明若存在f:Pa:U,~~a->a[n]则能推出e(f Bool x)=f Bool x[n]从而可推出矛盾
:%,1#not Pa:U,(not(not a))->a[n]#t
:%,1$获取999mg推理素
:ttua,5@泛等公理不仅说ua是命题[n]“(eqv a b)->(eq a b)”的证据[n]它还说ua映射与id2eqv[n]映射互为逆映射
:%,0@映射id2eqv为命题[n]“(eq a b)->(eqv a b)”的证据[n]该证据可通过ind_eq得到[n]不需要添加新公理
:ttua,1$[[ttindS1]]解锁ind_S1

:ttindTrue,4#Px:nat,Py:nat,eq (add x y) (add y x)[n]#t
:%,1$[[ttmul]]解锁乘法函数[n]mul : nat->nat->nat
:%,2#Pn:nat,eq (mul 0 n) 0[n]#t
:%,1#Pn:nat,eq (mul 1 n) n[n]#t
:%,1#Pn:nat,eq [n](mul n 2) (double n)[n]#t
:%,1#Px:nat,Py:nat,eq (mul x y) (mul y x)[n]#t
:%,1#Px:nat,Py:nat,Pz:nat,[n]eq (mul x (add y z))[n](add (mul x y) (mul x z))[n]#t
:%,1#Px:nat,Py:nat,Pz:nat,[n]eq (mul x (mul y z))[n](mul (mul x y) z)[n]#t
:%,1$获取99mg推理素
:%,1#[[tt5R7]]Px:nat,not (eq (mul x 5) 7)[n]#t
:%,2$获取157mg推理素
:hint-tt-a3,3@这种函数嵌套类型[n]其实就是多元函数类型
:%,3@输入的自变量为[n]a:U、b:U、c:U、[n]x:a->b->c、y:a->b、[n]z:a这六个
:%,3@输出的变量类型为c[n]我们的目标就是要构造[n]有这样输入输出[n]类型的多元函数
:%,3@于是可以先写[n]La:U.Lb:U.Lc:U.[n]Lx:a->b->c.[n]Ly:a->b.Lz:a.???[n]其中???类型是c，值还不确定
:%,3@只要在给定的输入变量下[n]能凑出一个类型为c的值[n]将其填入???处即可
:%,3@类型c只出现过两次[n]第一次c:U，告诉我们它是个类型[n]第二次出现在x:a->b->c
:%,3@即输入类型为a、b的两个值，[n]x函数就能得到[n]类型为c的值
:%,3@类型为a的值是有的，[n]它是z[n]因此要找类型为b的值
:%,3@注意到y:a->b[n]意味着输入a类型的变量[n]就能得到b类型的变量：[n](y z) : b
:%,3@现在可以让函数x作用了：[n]因为z:a、(y z):b[n]所以x z (y z):c[n]这就是???处要填入的表达式
:%,3@能看到这里[n]的玩家也太辛苦了[n]给点奖励合不合适？
:%,3@合适得不得了
:%,3$获取666µg推理素

// 序数附加

1,2,2,1,2,4,1$[[w^2]]到达序数ω²
1,2,1,4,3,1$[[aInf]]解锁ZFC集合论[n]无穷公理(aInf)

// w^w+w
// 1,2,1,4,4,1,4,1$[[dSd0]]解锁自然数与[n]后继函数[n]的集合论定义
// w^w+w^2
1,2,1,4,4,1,4,4,2,5$[[dw]]解锁第一个无限集合[n]“ω”(omega)[n](即自然数集)
:dw,0#E!o:Vn:(n@o <> [n]Vx:(({}@x & Vy:(y@x>yU{y}@x)) > n@x))[n]#p
// w^(w2)+w^2
1,2,1,4,3,4,4,1,4,2$[[dRel]]解锁二元关系谓词(Rel)[n]定义
1,2,1,4,3,4,4,1,4,3,1@提示：证明不可数集合[n]的存在请前往序数[n]ω^ω^ω[n][n]证明良序定理[n]请前往序数[n]ω^(ω+2)+ω^(ω+1)+ω^ω
// ω^(ω+2)+ω^(ω+1)+ω^ω
1,2,1,4,4,1,2,2,4,4,1,2,4,3,2$[[dOrder]]解锁全序(Order)与[n]良序(WellOrder)[n]定义
// w^w^w+1
1,2,1,4,3,3,1,3$[[dEquiv]]解锁双射(Equiv)谓词的定义
:%,5#Va:Vb:Equiv({a},{b})[n]#p
:%,5$获取1.1g推理素
// w^2*3+w4+7
1,2,2,1,2,3,1,2,3,1,2,3,1,3,1,3,1,3,1,3,2,2,2,2,2$[[ttord]]解锁类型层中的[n]序数类型Ord
:ttord,1,3@提示：正常使用序数类型[n]需先解锁类型层[n]与自然数类型
1,2,1,4,3,4,4,1,4,4,2$[[base3]]将序数进位基底[n]降至3
1,2,1,4,3,4,4,1,4,3,2$[[base2]]将序数进位基底[n]降至2
// w^3+w^23+w5+7
1,2,2,1,2,2,3,1,2,3,1,2,3,1,2,3,1,3,1,3,1,3,1,3,1,3,2,2,2,2,2,1,3@你终于找到这里来啦！[n]并集公理是说[n]每个集合x的元素（也是集合）[n]中的所有元素能放在一起[n]构成新集合
:%,3@我们还需要结合分离公理aSep[n]得到不包含其它元素[n]的集合Union(x)
:%*,2@这听起来有点复杂[n]你可以花钱买这个引理[n]它还能构造幂集、[n]自然数集等集合哦
:%*,2,5#Ex:Vz:(#nf($0,x) > z@x)⊢[n]E!x:Vz:(z@x <> #nf($0,x))[n]#d
:%*,2,5,2$[[.filter]]解锁引理“.filter”
:%*,2,4#通过此门需消耗推理素3mg

:%,3@我们这样构造aUb：[n]Union({a,b})
//w^(w^w+w)
1,2,1,4,3,2,4,3,1#通过此门需消耗推理素1.111g
:%,5$[[stepw]]解锁技能[n]将能前往的最大序数[n]的后继运算提升至指数
//w***4
1,2,1,4,3,2,1,3$获取222.2g推理素
:%,3Oε₀
:%,3Oε₁
:%,3Oφ(ω,0)
:%,3Oφ(1@ω)
:%,3Oφ(1@(1,0))
:%,3OΨ(Ω₂)
:%,3OΨ(Ω_ω)
:%,3OΨ(Ω_Ω)
:%,3OΨ(I)
:%,3OΨ(M)
:%,3OPTO(ZFC)
:%,3OΩ
:%,3#[[Aleph]]门#א
:%,3$获取0.999999kg推理素

1,2,2@欢迎来到序数的世界[n]序数是自然数的推广
1,2,2,2,1,3@序数不仅包含自然数[n]还包含很多种“无穷大”
1,2,2,2,2,2@要想突破有限到达无穷[n]需要借助极限的力量
1,2,2,2,2,2,2,2,1,3@进度层中的数据统计[n]记录了你能前往的最大序数[n]以及序数的“进位”机制
1,2,2,2,2,2,2,2,2,2,2,2@到达一个序数有两种方式[n]一是取“后继”[n]二是取“极限”
1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,3@后继就是下一个数[n]即加上1
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2@取“极限”进位则是把[n]大于某个数的数字[n]视为无穷“ω”[n](提示：你可以第一次进位了)
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,3@进位与序数更精确的描述如下[n]每个序数都等同于先于它的[n]所有序数构成的集合
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2@将序数0定义为空集{}[n]则1 = {0}[n]2 = {0,1}[n]3 = {0,1,2}[n].....
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,3@这样从序数n得到[n]的序数n U {n}[n]就叫后继序数
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2@不是后继序数的序数[n]叫极限序数[n]如 ω = {0,1,2,3,4...}[n]即自然数的集合[n]是第一个除0外的极限序数
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,3@虽然极限序数无法[n]在有限步之内达到[n]进位机制可让你在[n]有限步之内完成“飞升”
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2@提示：ω17+7处[n]有一些重要的线索
    1,2,2,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,2,2,2,2,2$[[w^3]]到达序数ω³
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,3@[[an42]]刚刚你路过了[n]宇宙的终极答案的后继
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2@你或许发现了[n]这些数字[n]都是质数
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,3@质数有无穷个[n]一直走下去也没什么意思
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2@真的还要继续前进吗？
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,3@好了我的朋友[n]请回吧
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2@这个游戏最主要的[n]谜题是形式系统[n]难道不是吗？
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,3@还有好多谜题等着[n]你来解开呢[n]别贪玩了
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2@你知道吗？[n]为了你继续向前走[n]我在这里要多码[n]好几百字呢
:%*,2,2,2,2,2,2,1,3@而且，再往下走[n]你的浏览器继续加载[n]地图，内存会溢出的
:%,2,2,2,2,2,2,2,2,2,2@别走了，速回！[n]请听我的话[n]我不会害你的
:%*,2,2,2,2,2,2,1,3@快回去！[n]你这个顽固的家伙！
:%,2,2,2,2,2,2,2,2,2,2,2,2,2,2@你继续向前走吧[n]我不管你了！
:%*,2,2,2,2,1,3@
:%,2,2,2,2,2,2@别找我！
:%*,2,2,2,2,1,3@
:%,2,2,2,2,2,2@别烦我！
:%*,2,2,2,2,1,3@
:%,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2@你真的疯了
:an42,3@为纪念你来到这里[n]现将终极答案[n]印发给你们
:an42,3,3@向前追寻答案吧！[n](建议保存一下游戏进度[n]再去追寻哦)
`;
//# sourceMappingURL=map.js.map