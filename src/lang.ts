import { blockMap } from "./hy/maploader.js";

class LangMgr {
    lang: string = 'en';
    textNodes: Array<HTMLElement>;
    init() {
        // this.textNodes = document.querySelectorAll("label") as any as Array<HTMLElement>;
        this.textNodes = document.querySelectorAll("h3,button,.achievement div,label") as any as Array<HTMLElement>;
        for (const d of this.textNodes) {
            d.setAttribute("data-tr", d.innerText);
        }
        for (const d of document.querySelectorAll("p[data-tr-mark]") as any as Array<HTMLElement>) {
            d.setAttribute("data-tr", d.innerHTML);
        }
        this.setLang(
            localStorage.getItem("lang") || (navigator.languages.join(",").includes("zh") ? "zh" : "en")
        );
    }
    setLang(lang: string) {
        this.lang = lang;
        localStorage.setItem("lang", lang);
        for (const d of this.textNodes) {
            if (d.childNodes[1]) (d.childNodes[1] as Text).data = TR(d.getAttribute("data-tr"));
            else d.innerText = TR(d.getAttribute("data-tr"));
        }
        for (const d of document.querySelectorAll("p[data-tr-mark]") as any as Array<HTMLParagraphElement>) {
            d.innerHTML = TR(d.getAttribute("data-tr"));
        }
        for (const v of blockMap.values()) {
            v.text = this.trc(v.text);
        }
    }
    dataEnInCanvas = {
        "Toggle Language:\nEnglish": "切换游戏语言：\n中文",
        "欢迎来到游戏\nDeductrium!\n按WASD或\n拖动画面进行移动": "Welcome to the game\nDeductrium!\nUse WASD keys or\ndrag the screen to move",
        "这是一个形式系统推理结合\n双曲空间解谜小游戏\n游戏作者：Hqak(wxyhly)": "This is a puzzle game \ncombining formal system deduction\nwith hyperbolic space exploration\nGame Developer: Hqak(wxyhly)",
        "前面的区域\n以后再来探索吧？": "How about we explore\nthe area ahead of us later?",
        "未解锁的闸门无法通过\n请寻找线索解开闸门\n#ω": "Unlocked gates cannot be passed\nPlease find clues to unlock it\n#ω",
        "解锁进度层": "Unlock progress layer",
        "解锁推理层\n与符号“→”（>）": "Unlock deduct layer \nand symbol “→” (>)",
        "#p闸门开启方法：\n当推理层的定理列表中\n包含闸门上的字符串时\n才能通过闸门": "Method to unlock Gate #p:\n you can pass through it\nWhen the [P] list in the deduct layer\ncontains the string on the gate",
        "解锁使用推理宏\n（即“录制宏”按钮）\n提示：前往⊢($0>$0)\n后方以解锁假设": "Unlock deduction macros\n(ie, the \"Record Macro\" button)\nHint: Pass through of ⊢($0>$0)\nto unlock hypotheses",
        "#d闸门开启方法：\n当推理层的推理规则列表中\n包含闸门上的字符串时\n才能通过闸门": "Method to unlock Gate #d:\n you can pass through it\nWhen the [D] list in the deduct layer\ncontains the string on the gate",
        "健身俱乐部会员：\n进度层中累计的\n总方块步数达到\n256步才能通过此门": "Jogging Club Member:\nTo pass through this gate\nThe total block steps in progress layer\nmust reach 256 steps",
        "拆除门#ω": "Destruct the gate #ω",
        "提示：解锁符号“~”后\n才能开这些门\n另外：\n大写字母为系统保留\n建议输入小写字母": "Hint: You can only open these\n gates after unlocking the symbol \"~\"\nOther Hints: Uppercase\n letters are reserved by the system\nLowercase letters are recommended",
        "向前走，有推出\na>a\n的提示": "Go forward for a hint\n on deriving a>a",
        "要想推出a>a\n尝试使用a2公理看看\na>((a>a)>a)\n能推出什么\n然后再尝试使用\n两次推理规则mp": "To derive a>a\nTry using Axiom a2 on\na>((a>a)>a)\n to see what you can derive\nThen try using\nthe inference rule MP twice",
        "向前走寻找指南针": "Go forward to find the compass",
        "获得奖励：\n若序数进位基底大于5\n则将基底减1": "Obtain Reward:\nReduce the limit carry base by 1\nif the ordinal base is greater than 5",
        "获取指南针": "Obtain Compass",
        "解锁否定公理a3\n即符号“¬”（~）": "Unlock Negation Axiom a3 \n and symbol “¬” (~)",
        "提示：录制宏会将\n整个定理列表\n保存到推理规则表中\n“$xxx”可被任意替换使用": "Hint: Recording macro will save\nthe entire [P] list\nto the deduction rule table\n“$xxx” can be replaced with anything",


        "解锁假设\n注意：定理表中若有假设\n不可开启对应门#p\n假设是用来录制宏的": "Unlock Hypotheses\nNote: If there are hypotheses in [P] list\nthe Gate #p cannot be opened\nHypotheses are for recording macro",
        "将定理列表清空后添加假设\n录制成宏后假设将作为\n推理条件出现在\n推出符号“⊢”前": "To add hypotheses, you need to\n clear the [P] list first.\nAfter recorded as a macro, the hypotheses\n will occur as conditions\nbefore the turnstile symbol “⊢”",
        "解锁拆门技能\n通过门后将其拆除\n提示：考虑逆否命题\n（建议推出否定爆炸后\n再探索前方系列谜题）": "Unlock gate destruction skill:\nRemove gates after passing through them\nHint: Consider contrapositive statements\n(recommend to get the principle of explosion\nbefore exploring the puzzles ahead)",
        "拆除门#<>(↔)\n提示：该门后才解锁相应符号": "Destruct Gate #<>(↔)\nHint: After this gate, you can\n unlock the related symbol",
        "解锁逻辑符号\n“∧”（&）与“∨”（|）": "Unlock logical symbols\n“∧” (&) and “∨” (|)",
        "提示：需解锁\n“<>”(↔)符号\n才能使用逻辑符号": "Hint: You need to unlock\nthe “<>” (↔) symbol\nto use logical symbols",
        "高亮显示\n仅奖励推理素的方块": "Highlight blocks\nthat only reward deductrium",
        "条件演绎元定理\n将自动帮你生成\n带条件的推理宏": "Conditional Deduction Metatheorem\nwill automatically generate\nconditional macros for you",
        "解锁条件演绎元定理": "Unlock Conditional\nDeduction Metatheorem",
        "通过此门需\n1.解锁条件演绎元定理\n2.消耗推理素20µg": "To pass this gate you need:\n1. Unlock the Conditional Deduction Metatheorem\n2. Consume 20µg of Deductrium",
        "解锁演绎元定理\n解锁演绎元定理\n解锁演绎元定理": "Go for Unlock Deduction Metatheorem!\nGo for Unlock Deduction Metatheorem!\nGo for Unlock Deduction Metatheorem!",
        "重要的元定理说三遍\n重要的元定理说三遍\n重要的元定理说三遍": "Something is worth repeating 3 times\nSomething is worth repeating 3 times\nSomething is worth repeating 3 times",
        "提示：要证a>~~a\n需先证~~~a>~a": "Hint: To prove a>~~a\nyou first need to prove ~~~a>~a",
        "提示：\n门a>(a>a)\n后有些关于双重否定\n推理的提示": "Hint:\nBehind the gate a>(a>a)\nthere are hints for\n double negation elimination",
        "提示：这里继续深入\n前进可拆除门#K": "Hint: Continuing deeper here\nwill allow you to destruct gate #K",
        "拆除门#K": "Destruct Gate #K",
        "提示：先从a2公理出发证明\n($0>$1),($0>($1>$2))⊢($0>$2)": "Hint: Using axiom a2, firstly prove\n($0>$1),($0>($1>$2))⊢($0>$2)",
        "提示2：通过a1公理可以证明\n($1>$2)⊢($0>($1>$2))": "Hint 2: Using axiom a1 to prove\n($1>$2)⊢($0>($1>$2))",
        "提示：证明规则\n($0>$1),($1>$2)⊢($0>$2)\n后使用它": "Hint: Prove the rule\n($0>$1),($1>$2)⊢($0>$2)\nthen use it",
        "提示：~~a>(~~a>a)\n与a2公理": "Hint: ~~a>(~~a>a)\nand Axiom a2",
        "提示：证否定爆炸须先证a>~~a\n关键步骤：\na⊢~b>a\n~b>a⊢~a>b": "Hint: To prove\n the principle of explosion,\n you must first prove a>~~a\nKey steps:\na⊢~b>a\n~b>a⊢~a>b",
        "获得常见\n命题逻辑定理\n大礼包！可直接使用！": "Obtain a Toolkit of\ncommon propositional logic theorems!\nYou can use these rules directly!",
        "门#K在离\n#p闸门开启方法说明\n直线距离2格远的地方": "Gate #K is located\n2 tiles away from the tile with\n explanation of how to unlock Gate #p",
        "要解锁门#L\n需要从“解锁拆门技能”\n方块旁经过": "To unlock Gate #L\nyou need to pass by the block\n\"Unlock Gate Destruction Skill\"",
        "解锁完备性元定理\n（命题逻辑自动推理）": "Unlock Completeness Metatheorem\n(Automated propositional logic reasoning)",
        "解锁拆门技能奖励方块前方\n可解锁<>、&、|逻辑符号\n然后有很多推理素奖励": "You can unlock logical symbols <>, & and |\nAhead of the gate destruct skill reward\nThen, there are many deductriums",
        "解锁一阶逻辑\n量词公理a4、a5、a6\n与公理模式元规则mq\n建议先前往介绍\n量词、公式那条路\n后面再来公理a4相关关卡": "Unlock 1st-order logic\nQuantifier Axioms a4, a5, a6\nand Axiom Schema Meta-rule mq\nRecommend: first go to the path\n introducing quantifiers and formulas\nThen back to the Axiom a4 later",

        "解锁当且仅当（互推）\n逻辑符号“↔”（<>）": "Unlock iff (mutual implication)\nLogical symbol “↔” (<>)", "解锁逆演绎元定理": "Unlock inverse deduction metatheorem", "解锁组合元定理": "Unlock combination metatheorem", "组合元定理将两个\n带条件的推理规则a与b\n自动匹配组合成\n一条规则“:a,b”\n比如推理规则\n“:a7,<a1”将自动得到\n⊢ $1 > ($0=$0)": "Combination metatheorem \nautomatically matches 2 \nconditional deduction rules\n a and b into one rule \":a,b\"\nE.g., deduction rule\":a7,<a1”\n will be ⊢ $1 > ($0=$0)", "快捷执行元规则：\n可输入元规则名字前方括号内\n的字符前缀加上推理规则名\n来执行元规则。该方式生成的新规则\n不列入推理规则表中": "Quick execute metarule:\nEnter prefix between '[' and ']' \nbefore metarule name, then follow\n deduction rule name\nto execute metarule.\nNew rules generated this way\nwill not  be added to [D] rule table", "“∀”(V)叫做量词\n量词后紧跟的叫变量\n冒号后的公式叫\n该量词的管辖范围\n整个V$0:$1是公式": "“∀” (V) is called quantifier symbol\nAfter quantifier is variable\nFormula after colon is called\nscope of this quantifier\nWhole expression V$0:$1 is formula", "公理a6解读：\n#nf($0,$1)的值为$0\n外加验证变量$1不在\n表达式$0中自由出现\n(nf为not free缩写)": "Axiom a6 interpretation:\nValue of #nf($0,$1) is $0\nwith verifying variable $1 not free \nin expression $0\n('nf' is for not free)", "验证#nf(Vx:$0,$1)\n有两种情况：\n1.若x为$1，则\n$1不在Vx:$0中自由出现\n若$0中有x,我们说\nx被量词约束": "To verify #nf(Vx:$0,$1)\nThere's two cases. Frist case:\nIf x is $1, then\n variable x is not free in Vx:$0\nIf x occurs in $0, we say\nx bound by quantifier", "2.若x不是$1\n则#nf(Vx:$0,$1)=\nVx:#nf($0,$1)\n即$1在Vx:$0中是否自由出现\n取决于$1在$0中是否自由出现": "2. If x is not $1\nthen #nf(Vx:$0,$1)=\nVx:#nf($0,$1)\ni.e., whether $1 is free in Vx:$0\ndepends on whether $1 is free in $0", "由于$开头的公式或项\n在录制宏后可替换成任意值\n无法确定时\n#nf函数将保留": "Since $-prefixed formulas or terms\ncan be replaced with any value in macro usage\n#nf function remains when there's uncertainty", "你永远别想拿到这个奖励！": "You'll never get this reward!", "公理a4解读：\n#rp($0,$1,$2)的值\n为将$0中自由出现的$1\n全替换为$2后的新值\n(即replace)": "Axiom a4 interpretation:\nValue of #rp($0,$1,$2)\nis to replace all free $1 in $0\nwith $2\n('rp' is for replace)", "假设中若有未化简的#rp函数\n会导致匹配机制失效\n因此会被系统禁止": "If an unreduced #rp function\n occurs in hypotheses,\n the matching mechanism will fail.\nThis will not be allowed",
        "补充量词换名相关规则礼包": "Obtain a Toolkit for Renaming Variables in quantifiers",
        "解锁替换元定理中\n可跨越量词E!进行替换": "Unlock Replacement across the quantifier E!\nIn the IFF Metatheorem",
        "后方解锁替换元定理中\n可跨越量词E!进行替换": "Go forward to unlock Replacement \nacross the quantifier E! in IFF Metatheorem",
        "拆除门#rp": "Destruct Gate #rp",
        "未解锁的闸门无法通过\n请寻找线索解开闸门\n#rp": "Unlocked gates cannot be passed\nFind clues to unlock it\n#rp",
        "特称元定理可给\n任何带一个条件的规则\n的条件和结论都加上\n相同的存在量词": "The Existential Metatheorem adds\nthe same existential quantifier\nto both the condition and conclusion\nof any rule with one condition",
        "尝试执行规则\">veve.Vcn\"\n试试一键证明\n“解锁特称元定理”方块\n旁边的定理": "Try executing the rule \">veve.Vcn\"\nto proof the theorem next to the\n\"Unlock Particularization Metatheorem\" block",
        "解锁特称元定理": "Unlock Existential Metatheorem",
        "集合论中直接定义：\n0={}，S(x)=xU{x}\n若皮亚诺公理此时\n不限制只对数推理的话\n会推出矛盾": "In set theory, we have definitions: \n0={} and S(x)=x∪{x}\nIf the Peano axioms\nare not restricted to natural numbers\nthis leads to a contradiction",

        "解锁直接重命名\n推理规则的能力": "Unlock the ability \nto directly rename[D] rules.",
        "解锁建立文件夹\n整理规则列表的能力": "Unlock the ability \nto create folders\nto organize the list of [D] rules.",
        "解锁用斜体区分\n显示项与公式": "Unlock the use of italics \nto distinguish terms and formulas.",
        "往前走，还有更高级的\n组合元定理用法\n（仅限快捷执行元规则）": "Further on, there are more advanced uses\nof the combination metatheorem\n(for execution of fast-meta-rules only).",
        "组合元定理可以嵌套\n如::a,b,c相当于\n令m = :a,b\n则::a,b,c = :m,c": "Combination rules can be nested.\nFor example, ::a,b,c is equivalent to\nlet m = :a,b\nthen ::a,b,c = :m,c.",
        "第二个参数同理\n如:a,:b,c相当于\n令m = :b,c\n则:a,:b,c = :a,m": "The second parameter can also be nested.\nFor example, :a,:b,c is equivalent to\nlet m = :b,c\nthen :a,:b,c = :a,m.",
        "第二个参数规则\n也可以有多个条件\n如:a:b,c表示\n先执行推理规则a与b\n然后把它们的结论\n分别作为规则c的条件\n再执行c": "The second parameter rule\ncan also have multiple conditions.\nFor example, :a:b,c means\nfirst execute rules a and b\nand then use their conclusions\nas conditions for rule c,\nand then execute c.",
        "条件之间用“:”分隔\n条件与结论之间用“,”分隔\n“#”为放入默认条件\n条件没写够则默认为“#”": "Conditions are separated by “:”.\nConditions and conclusions are separated by “,”.\n“#” represents the insertion of the default condition.\nIf not enough conditions are written,\n it defaults to “#”.",
        "你可以输入这几个规则体会一下：\n:<a1,c.t\n:<a1:#,c.t\n:#:<a1,c.t": "You can input these rules to experience it:\n:<a1,c.t\n:<a1:#,c.t\n:#:<a1,c.t",
        "定理.t($a>$b,$b>$c⊢$a>$c)\n可以输入规则名直接生成：\n<:<a1,<a2\n(虽然两个条件顺序反了)": "The theorem .t($a>$b,$b>$c⊢$a>$c)\ncan be generated directly by entering the rule name:\n<:<a1,<a2\n(although the order of the two conditions is reversed).",
        "获取关于系统函数#nf、#rp\n自动化简规则的提示": "Get hints about the system functions #nf, #rp,\nand the automated simplification rules.",
        "若apn5中去掉$0中\n不自由出现x的条件\n也能推出矛盾。": "If the condition that x does not occur freely\nin $0 is removed from apn5,\na contradiction can still be derived.",
        "分离公理中的\n不自由出现条件\n取消掉后也能推出矛盾。": "If the non-free occurrence \ncondition in the Axiom of Separation is removed,\n a contradiction can also be derived.",
        "解锁有序数对符号\n (a, b)": "Unlock the ordered pair symbol\n(a, b).",
        "整个{..|..}是项\n其中z(x)中的x被\n广义量词“x@y”约束\n注意y中的x（如果有）是自由的": "The entire {..|..} is a term.\nHere, x in z(x) is bound by\nthe generalized quantifier “x@y”.\nNote that x in y (if any) is free.",
        "解锁分离公理\n构造集合符号": "Unlock the set construction symbol\nfrom the Axiom of Separation.",
        "{x@y|z(x)}的意思是\n把集合y中满足条件z(x)\n的元素拿出来\n构成新集合。\nz是谓词，z(x)是公式": "{x@y|z(x)} means\nto take the elements from set y\nthat satisfy the condition z(x)\nand form a new set.\nz is a predicate, and z(x) is a formula.",
        "{z(x)|x@y}的意思是\n把集合y的所有元素x\n通过函数z映射到z(x)\n构成新集合。\nz是函数，z(x)是项": "{z(x)|x@y} means\nto map all elements x of set y\nthrough the function z to z(x)\nand form a new set.\nz is a function, and z(x) is a term.",
        "解锁替换公理\n构造集合符号": "Unlock the set construction symbol\nfrom the Axiom of Replacement.",
        "解锁差集运算符\n“\\”": "Unlock the difference operator\n“\\”.",
        "解锁集合\n笛卡尔积运算\n“×”(X)": "Unlock the set\nCartesian product operation\n“×”(X).",
        "解锁有序数对投影函数\nPr1与Pr2": "Unlock the ordered pair projection\n functions Pr1 and Pr2.",
        "ZFC中把整数a-b看成(a,b)\n其中a与b是自然数": "In ZFC, the integer a-b is\n represented as (a,b),\nwhere a and b are natural numbers.",
        "解锁整数等价类生成函数“Z”": "Unlock the integer equivalence\n class generating function “Z”.",
        "若a+d=b+c，则\n(a,b)跟(c,d)表示同一个整数\n因此ZFC中把整数\n定义为整个等价类的集合": "If a+d=b+c, then\n(a,b) and (c,d) represent the same integer.\nTherefore, in ZFC, integers are defined\nas the set of the equivalence class.",
        "解锁整数集合(Z)": "Unlock the set of\n integers (Z).",
        "解锁整数加法运算": "Unlock the integer\n addition operation.",
        "解锁整数序关系谓词": "Unlock the integer\n order relation predicate.",
        "解锁整数乘法运算": "Unlock the integer\n multiplication operation.",
        "我们将在集合论框架下\n实现皮亚诺公理系统": "We'll implement the Peano Axiom System\nwithin the framework of set theory.",
        "空集相当于0\n后继S(x)相当于xU{x}": "The empty set is equivalent to 0.\nThe successor S(x) is\n equivalent to xU{x}.",
        "要将ω与ℕ两者等同\n就要重新“证明”5个公理": "To equate ω and ℕ,\nwe must “prove” the 5 axioms again.",
        "提示：证明序数ω2的存在性\n需要使用替换公理": "Hint: Proving the existence of the ordinal ω2\nrequires the use of the Axiom of Replacement.",
        "拆除门#pn": "Distruct gate #pn",
        "未解锁的闸门无法通过\n请寻找线索解开闸门\n#pn": "Locked gate cannot be passed.\nFind clues to unlock it\n#pn.",
        "解锁并集公理定义的“Union”函数\n与二元函数符号“U”": "Unlock the “Union” function \ndefined by the Axiom of Union\nand the binary function symbol “U”.",
        "解锁序关系谓词符号\n“≤”(<=)与“≥”(>=)": "Unlock the order relation\n predicate symbols\n“≤”(<=) and “≥”(>=).",
        "解锁整除谓词“∣”(/|)": "Unlock the divisibility\n predicate “∣”(/|).",
        "获得常见\n加法乘法性质定理\n大礼包！": "Obtain a tookit of common\ntheorems on the properties of\n addition and multiplication!",

        "提示：解锁差集符号“\\”\n需要先解锁有序数对\n或重新证明皮亚诺公理": "Hint: To unlock the difference symbol “\\”\n you need to unlock the ordered pair\nor to re-prove the Peano Axioms.",
        "向前走获得错误的\napn5公理apn5x\n该公理只能在前方\n门后的区域中使用": "Go forward and get the incorrect\napn5 axiom: apn5x.\nThis axiom can only be used in the area\nbeyond the gate ahead.",
        "向前走获得错误的\nasep公理asepx\n该公理只能在前方\n门后的区域中使用": "Go forward and get the incorrect\nasep axiom: asepx.\nThis axiom can only be used in the area\nbeyond the gate ahead.",
        "有难度？绕行的路上给些提示": "Too difficult? \nGet some hints \nalong the detour.",
        "解锁整数常数定义\n如dZ0/dZ-1/dZ2\n将引入整数+0/-1/+2": "Unlock the integer constant definitions\nsuch as dZ0/dZ-1/dZ2.\nThis introduces the integers +0/-1/+2.",
        "侧面买提示": "Buy a hint on the side",
        "旁边付费看提示": "Pay nearby to see the hint.",
        "侧面买提示2": "Buy hint 2 on the side.",
        "侧面买提示1": "Buy hint 1 on the side.",
        "从前提易得x@yU{y}\n因此要么x=y要么x@y\n正规公理可证x@y不可能\n因此x=y得证": "It is easily derived from the premise that x@yU{y}.\nTherefore, either x=y or x@y.\nThe Axiom of Regularity\n proves x@y is impossible.\nThus, x=y is proven.",
        "提示还不够？\n没事，继续付费嘛！": "Not enough hints?\nNo worries, continue paying!",
        "因为x跟y的地位对称\n所以同样可得到y@x\n即：若~x=y，有x@y&y@x成立。\n易证集合{x,y}违背了正规公理\n说明假设~x=y错误": "Because x and y are symmetric,\nwe can similarly get y@x.\nThat is: If ~x=y,\n then x@y & y@x holds.\nIt is easily proven that the set \n{x,y} violates the Axiom of Regularity,\nwhich shows that\n the assumption ~x=y is false.",
        "由omega定义可知\nx属于omega等价于\nx属于任意一个归纳集S\n对xU{x}也同理\nx@omega推出x@S\n归纳集定义可知\nx@S能推出xU{x}@S": "From the definition of omega,\n we know that x is \nan element of omega if and only if\nx is an element of any inductive set S.\nThe same applies to xU{x}.\nx@omega implies x@S.\nFrom the definition of an inductive set,\n we know that x@S implies xU{x}@S.",
        "自然数是最小的归纳集\n因此{x@omega|P(x)}=omega\n所以P(x)对所有自然数成立": "The natural numbers are the smallest inductive set.\nTherefore, {x@omega|P(x)}=omega.\nSo, P(x) holds for all natural numbers.",
        "归纳集指满足{}@x且\nVa:(a@x>aU{a}@x)的集合\n若已知P(0)、Vx:(P(x)>P(xU{x}))\n可证{x@omega|P(x)}是个归纳集": "An inductive set is a set \nthat satisfies {}@x and\nVa:(a@x > aU{a}@x).\nIf P(0) and Vx:(P(x) > P(xU{x})) are given,\nwe can prove that {x@omega|P(x)} is an inductive set.",
        "解锁自动计算\n整数的加减法与乘法\n如.1*-2生成\n⊢ +1 * -2 = -2": "Unlock automatic calculation\nof integer addition, subtraction,\n and multiplication.\nFor example, .1*-2 generates\n⊢ +1 * -2 = -2.",
        "退出该门前请\n清除所有依赖错误公理\n的定理与规则！\n然后执行“del apn5x”\n(该门为自动门，且无法被拆)\n#imm": "Before exiting this gate,\nplease clear all props and rules\nthat rely on the incorrect axiom!\nThen execute “del apn5x”\n(This gate is automatic and cannot be destructed)\n#imm",
        "获得错误公理apn5x": "Obtain the incorrect axiom apn5x.",
        "退出该门前请\n清除所有依赖错误公理\n的定理与规则！\n然后执行“del asepx”\n(该门为自动门，且无法被拆)\n#imm": "Before exiting this gate,\nplease clear all props and rules\nthat rely on the incorrect axiom!\nThen execute “del asepx”\n(This gate is automatic and cannot be destructed)\n#imm",
        "获得错误公理asepx": "Obtain the incorrect axiom asepx",


        "卡住了？前往序数\nω³+ω²3+ω5+7查看\n证明并集符号U合法性的提示": "Got Stucked? Go to the ordinal\nω³+ω²3+ω5+7 to see a hint \nfor proving the legality\n of the union symbol U.",
        "解锁后命令行输入.3+4\n可生成规则⊢3+4=7\n乘法同理": "After unlocking, enter \".3+4\"\nin the command line to\n generate the rule ⊢3+4=7.\nMultiplication is also supported.",
        "解锁所有正常计算机\n能表示的自然数常量\n且可自动计算加法与乘法": "Unlock all natural number constants\nrepresentable by a normal computer\nand enables automatic calculation\n of addition and multiplication.",
        "你终于找到这里来啦！\n并集公理是说\n每个集合x的元素（也是集合）\n中的所有元素能放在一起\n构成新集合": "You finally found your way here!\nThe Axiom of Union says\nthat all elements of the elements \n(which are also sets)\nof every set x can be put together\nto form a new set.",
        "我们还需要结合分离公理aSep\n得到不包含其它元素\n的集合Union(x)": "We also need to combine this \nwith the Axiom of Separation (aSep)\nto obtain the set Union(x)\nwhich contains no other elements.",
        "这听起来有点复杂\n你可以花钱买这个引理\n它还能构造幂集、\n自然数集等集合哦": "This sounds a bit complicated.\nYou can buy this lemma;\nit can also construct the power set,\n natural numbers, and other sets.",
        "解锁引理“.filter”": "Unlock the lemma \".filter\"",
        "我们这样构造aUb：\nUnion({a,b})": "We can construct \n\"aUb\" by: Union({a,b})",

        "解锁简化显示#nf等系统函数": "Unlock Display Omitted \n System Functions e.g. #nf(...)",

        "公理a4解读：\n#rp($0,$1,$2)执行替换前\n还会外加验证$0中\n可将$1替换为$2": "Axiom a4 interpretation:\nExpression #rp($0,$1,$2)\nwill verify that\nAll $1 in $0 can be replaced with $2\nBefore replacement execution", "若本来自由出现的变量\n替换后被量词约束\n则不可替换": "If free variable becomes bound\n by quantifier after replacement\n this replacement can't be allowed", "例如#rp(~Vy:(x=y),x,y)\n系统将验证失败\n": "E.g., #rp(~Vy:(x=y),x,y)\n#rp verification will fail\n", "带第四个参数的\n#rp函数可部分替换\n输入数字指定仅替换\n第几个出现的变量\n数字0表示全部替换\n负数代表倒数第几个出现的变量": "#rp functions allow partial \nreplacement with fourth parameter\nEnter number to specify replacing only the\nnth occurrence of variable\n0 means replace all\nNegative numbers mean nth from end", "注意：变量都是“项”\n不能说某项为真或假\n只有公式才能讨论其真假\n纯命题逻辑都是公式\n即都可判断真假": "Note: Variables are all \"terms\"\nWe can't say term is true/false\nOnly formulas can be assigned\n with True or False\nPure propositional logic are all formulas\nie, all can be judged true/false", "谓词属于“∈”（@）与\n相等“=”只能连接项\n连接后的整体是公式\n如x@y与x=y都是公式\n它们都能谈论真假": "Predicates like “∈” (@) and\nequality “=” can only connect terms\nAfter connection, the expression\n becomes formula\nE.g., x@y and x=y are both formulas\nThey can all be assigned with truth values", "所有命题逻辑连词符号\n即>、<>、~、&、|\n都只能连接公式\n不能直接连接项\n连接后的整体也是公式": "All propositional logic connective\nsymbols, ie, >, <>, ~, &, |\ncan only connect formulas\nThey can't directly connect terms\nAfter connection, the expression is also formula", "比如输入Vx:x>x\n系统会报错\n因为x出现在V后\n就判定x为变量\n而“>”不能连接变量": "E.g., enter Vx:x>x\nYou will get an error\nBecause x occurs after V as a variable\nbut \">\" cannot connect variables", "a8公理使用提示1\n若想把$a=$b中的$b替换成$c\n写“#rp($a=$b,$b,$c,0)”\n会发现系统无法计算#rp函数\n因为$a的值不确定，\n不能判断是否会\n也包含$b并参与替换。": "Axiom a8 usage tip 1\nTo replace $b with $c in $a=$b\nyou'll find that system cannot execute \nreplacement expression “#rp($a=$b,$b,$c,0)”\nBecause value of $a is uncertain\n it may participates in replacement\n if it also contains $b", "a8公理使用提示2\n若想把$a=$b中的$a替换成$c\n写“#rp($a=$b,$a,$c,1)”\n则没问题，因为$a第一个出现\n是一定要被替换的。因此\n让系统只替换第一个变量\n不再管后面的变量即可": "Axiom a8 usage tip 2\nTo replace $a with $c in $a=$b\nwe can write “#rp($a=$b,$a,$c,1)”,\n because $a occurs first so it must be replaced\n Therefore let system replace only first variable\nand ignore latter variables", "导航提示：\n1.这里离解锁皮亚诺公理\nZFC公理与类型层\n仅有三个方块距离了，\n2.旁边有着#nf与<>的门后\n可解锁一阶逻辑大礼包": "Navigation tips:\n1. Here is only 3 blocks away from unlocking \nPeano axioms, ZFC axioms and type layers\n2. Behind gate with #nf and <>, you can\nunlock useful 1st-order logic toolkit", "连续消除两个量词\n需要局部变量机制：\n由“#”开头的叫局部变量\n它保证与一切“$XX”的值都不同\nZFC集合论后不远的包含符号\n周围有详细介绍使用方法": "Eliminating 2 quantifiers consecutively\nneeds local variable mechanism:\nLocal variable started with “#”\nGuarantes different from all “$XX” values\nNear inclusion symbol behind ZFC set Theroy\nThere're detailed usage instructions around", "解锁一阶逻辑大礼包": "Unlock useful first-order logic\n theorem toolkit", "解锁类型层": "Unlock type layer", "解锁皮亚诺公理\napn1 - apn5\n与10以内数字定义": "Unlock Peano axioms\napn1 - apn5\nand definitions for numbers ≤10", "解锁ZFC集合论\n外延公理(aExt)": "Unlock ZFC set theory\naxiom of extensionality (aExt)", "卡住了？可交钱绕行": "Stucked? Pay deductrium to bypass", "其实若解锁了\n互推替换元定理\n就可直接生成：\n先证( ⊢ (~(($0>$1) > ~($1>$0)) <> ($0<>$1)))\n然后使用元定理\n把aExt的内容作为$$2\n$$3填0（意思为全部替换）": "If unlocked IFF metatheorem\n you can directly generate:\nFirst prove ( ⊢ (~(($0>$1) > ~($1>$0)) <> ($0<>$1)))\nThen use metatheorem:\nEnter aExt content as $$2\nthen enter 0 as $$3 (meaning replace all)", "如果用不惯或未解锁元定理\n也可使用一阶逻辑大礼包中的\n“.<>rxx”系列推理宏规则\n结合“.<>s”、“.<>t”、“.<>1”等\n手动等价代换得到": "If not used to or not unlocked metatheorem\nyou can also use \".<>rxx\" series macro rules\nin first-order logic toolkit\ncombine with \".<>s\", \".<>t\", \".<>1\", etc.\nto manually get equivalent substitution for iff", "解锁量词符号\n“∃”(E)": "Unlock quantifier symbol\n“∃”(E)", "解锁条件概括元定理\n并拆除门#V\n(门#V后解锁概括元定理)": "Unlock conditional generalization metatheorem\nand destruct gate #V\n(Unlock Generalization metatheorem behind gate #V)", "该门后可解锁概括元定理\n#V": "Generalization metatheorem #V\ncan be unlocked behind this gate", "条件概括元定理可把\n定理的所有条件和结论\n都加上相同的量词": "Conditional generalization metatheorem\n can add same quantifier to all conditions \nand conclusions of a given deduction rule", "概括元定理是说\n若定理的所有条件\n都没自由出现$0\n则可单独在结论中\n加上量词V$0": "Generalization metatheorem states that\nif all conditions of a rule\nhave no free occurrence of $0\nthen quantifier V$0 can be added to conclusion", "解锁ZFC集合论\n分离公理(aSep)": "Unlock ZFC set theory\naxiom of separation (aSep)", "由于我们通过a7公理\n知道z=z是对的，因此\n~z=z是错的，\n继而有z@x & ~z=z是错的\n则与之等价的z@y也是错的": "Since via axiom a7\n we know z=z is true, thus\n~z=z is false,\nthus z@x & ~z=z is false\nThen equivalent z@y is also false", "具体做法：先证明$zz ⊢ \n($zy<>($zx&~$zz)) <> ~$zy\n(提示：命题逻辑自动推理\n元规则可一键完成该证明)\n然后将$XXX代入具体值\n使用互推替换即可": "Specific approach: First prove $zz ⊢ \n($zy<>($zx&~$zz)) <> ~$zy\n(Hint: Completeness metarule can\n complete this proof with one click)\nThen substitute specific values for $XXX\nuse IFF metatheorem", "解锁唯一存在量词\n“∃!”(E!)": "Unlock unique existence quantifier\n“∃!”(E!)", "解锁空集常量符号\n“{}”": "Unlock empty set constant symbol\n“{}”", "解锁ZFC集合论\n配对公理(aPair)": "Unlock ZFC set theory\naxiom of pairing (aPair)", "解锁配对集合构造符号\n“{#0,#1}”": "Unlock pairing set construction symbol\n“{#0,#1}”", "解锁一元集合构造符号\n“{#0}”": "Unlock unary set construction symbol\n“{#0}”", "解锁ZFC简化大礼包\n即用更方便的\n人类习惯的符号\n重新书写ZFC所有公理": "Unlock ZFC simplify toolkit\nwhich rewrites all ZFC axioms\nusing more convenient symbols\n that human get used to", "解锁ZFC集合论\n选择公理(aChoice)": "Unlock ZFC set theory\naxiom of choice (aChoice)", "解锁ZFC集合论\n正规公理(aReg)": "Unlock ZFC set theory\naxiom of regularity (aReg)", "提示：omega、Equiv\n的定义分别在\n序数ω^ω+ω^2与\n序数ω^ω^ω附近": "Hint: Definitions of omega、Equiv are \nrespectively near ordinal \nω^ω+ω^2 and ordinal ω^ω^ω", "提示：利用反证法\n假设存在双射r，则可\n通过“对角线法则”\n构造矛盾": "Hint: Use proof by contradiction\nAssume bijection r exists, then\nconstruct contradiction via \"diagonal method\"", "拆除门#א": "destruct gate #א", "提示：门#א在序数的尽头之后": "Hint: Gate #א is beyond end of ordinals", "提示：解锁WellOrder(良序)的定义\n需要到达序数ω^(ω2)\n（前往该序数需在\n解锁并集公理的不远处\n用替代公理证明\n{ω,ω+1,ω+2,...}\n的存在性）": "Hint: Unlock WellOrder definition\nNeed to reach ordinal ω^(ω2)\n(To get there, near unlocked union axiom\nuse replacement axiom to prove\n{ω,ω+1,ω+2,...}\nexistence)", "将序数进位基底\n降至5\n(提示：到达在#ω门后的\n序数ω^ω后才能\n解锁无穷公理)": "Reduce ordinal base to 5\n(Hint: After reaching ordinal ω^ω behind gate #ω\nyou can unlock axiom of infinity)", "到达序数\nω^(ω2)": "Reach ordinal\nω^(ω2)", "将序数进位基底\n降至4": "Reduce ordinal base to 4", "到达序数\nω⁴4+ω³4+ω²4": "Reach ordinal\nω⁴4+ω³4+ω²4", "解锁ZFC集合论\n替换公理(aRepl)": "Unlock ZFC set theory\naxiom of replacement (aRepl)", "该门上有三把锁：\n#I1 #I2 #I3\n(提示：前两把锁在\n解锁一阶逻辑之后)": "This gate has three locks:\n#I1 #I2 #I3\n(Hint: First two locks are after\nunlocking first-order logic)", "解锁互推替换元定理": "Unlock IFF (mutual replacement) metatheorem", "证加法交换律\n需要用数学归纳法apn5\n若不会证\n请向前走看教程": "Proving additive commutativity\nneed axiom of induction apn5\nIf you get stucked\nGo forward for tutorial", "首先证明对0成立\nVy:(y@N>0+y=y+0)\n提示：证明该命题\n也需要数学归纳法": "First prove holds for 0\nVy:(y@N>0+y=y+0)\nHint: Prove this proposition\nAlso need induction (apn5)", "解锁谓词“是素数”\n(Prime)": "Unlock predicate \"is prime\"\n(Prime)", "提示：建议有条件优先解锁\n距此处两格的一阶逻辑，之后\n才可能解锁皮亚诺公理\n或ZFC集合论、类型层": "Hint: First recommend to unlock\n 1st-order logic (two grids away from here)\nThen ahead you can unlock \n Peano axioms, ZFC set theory and type layers", "值a的类型是A\n记作a:A": "Type of value a is A\ndenotes as a:A", "#t闸门开启方法：\n当类型层定理列表中有\n门上写的类型的值时\n才能通过闸门": "How to unlock gate #t:\nYou can pass through it when there's \na value in type layer's proposition list\nwhose type is written on the gate", "类型的类型是U0\n可简写成U\n叫“宇宙”或“全类”\nU0的类型是更大的全类U1": "Type of a type is U0\nAbbreviated as U\nCalled universe type.\nType of U0 is larger universa type U1", "开启之门即为真理\n谬误之门无法通过\n提示：解锁“+”后继续前进\n可大量挣钱与解锁ind_eq": "Opened gate is truth\nFalse gate can never be passed\nHint: Go ahead after Unlocking \"+\"\nCyou can earn a lot and unlock ind_eq", "介绍函数符号“λ”（L）\n与函数类型符号“Π”（P）\n": "Introduce function symbol “λ” (L)\nand function type symbol “Π” (P)\n", "函数表达式为λx:A.b\n其自变量x类型为A\n输出(因变量)值为b": "Function expression is λx:A.b\n where input variable x has type A\nand output value is b", "若假设x:A能推出b:B\n则λx:A.b的类型为\nΠx:A,B": "If assuming x:A we can derive b:B\nThen type of λx:A.b is\nΠx:A,B", "注意函数输出类型B\n可能依赖于x的值\n以后将看到例子": "Note that function output type B\nMay depend on value of x\nExamples will be seen later", "函数可以嵌套，如\nλx:A.λy:B.x其实是\nλx:A.(λy:B.x)\n其类型是\nΠx:A,Πy:B,A": "Functions can be nested, e.g.\nλx:A.λy:B.x is actually\nλx:A.(λy:B.x)\nIts type is\nΠx:A,Πy:B,A", "与量词类似\nλ后的变量x出现在“.”后的表达式中\n都是约束变量": "Similar to quantifiers\nVariables x after λ occuring in expression after “.”\nAre all bound variables", "不同于传统编程中的函数\n函数输出值的类型\n可以依赖于输入的自变量": "Different from functions\n in traditional computer programming\nType of function output value\nCan depend on input argument", "解锁简写非依赖函数\n类型符号“→”（->）": "Unlock abbreviation \nfor non-dependent function\ntype symbol “→” (->) ", "若类型Πx:A,B中\nx不在表达式B中自由出现\n则该类型可省去x\n并记作：A→B": "If in type Πx:A,B\nx is not free in expression B\nThen x can be omitted from type\nAnd denoted: A→B", "默认符号“→”是右结合的\n即A→B→C为\nA→(B→C)": "Symbol “→” is right-associative by default\ni.e., A→B→C is A→(B→C)", "α-转换规则：\n若z不在y中自由出现\n则λx:A.y等价于λz:A.y'\n其中y'是将y中自由的x\n替换为z的结果": "α-conversion rule:\nIf z is not free in y\nThen λx:A.y is equivalent to λz:A.y'\nWhere y' is result of replacing free x in y with z", "α-转换前后的两表达式\n是“定义相等”的\n由系统自动判定；\n函数类型\n简写前(Π)后(→)\n也“定义相等”": "Expressions before and after α-conversion\nAre \"definitionally equal\" which can\n be automatically checked by system;\nFunction types before (Π) and after (→) abbreviation\n are also \"definitionally equal\"", "若a:A，f:A->B\n则函数f可以作用于a\n记作f a\n且f a类型为B": "If a:A, f:A->B\nThen function f can apply to a\nDenoted as (f a)\n(f a) has type of B", "β-归约规则：\n若a:A，则有\n(λx:A.y) a等价于\n将y中自由的x替换成a": "β-reduction rule:\nIf a:A, then\n((λx:A.y) a) is equivalent to\nReplacing free x in y with a", "注意λx:A.y a的含义是\nλx:A.(y a)而不是\n(λx:A.y) a": "Note: 'λx:A.y a' means\n'λx:A.(y a)', not\n'(λx:A.y) a'", "计算(λx:A.λy:B.z) y时\n将z中自由的x替换为y\n将被λy:B约束\n系统将自动使用α-等价\n更改自变量名称来规避": "When computing (λx:A.λy:B.z) y\nReplace free x in z with y\nWill be bound by λy:B\nSystem will automatically use \nα-conversion to rename variable", "“存在某个值其类型是A”\n可翻译成“A是定理”\n那个值就是该命题\n成立的证据": "\"There exists a value of type A\"\nCan be translated as \"A is a theorem\"\nThat value is evidence or witness\n for this proposition to hold", "旁边的#t门打不开？\n付费后给提示": "Can't open adjacent gate #t?\nAfter payment, I'll give some hints", "解锁简写否定符号“not”\n即，将“A->False”\n简写为“not A”": "Unlock negation symbol “not”\nI.e., abbreviate “A->False”\nto “not A”", "解锁证明策略\nintro/expand/apply": "Unlock proof strategies\nintro/expand/apply", "由于False为空类型\n因此若存在函数A->False\n则若A类型不为空\n就能推出False也不为空\n因此A类型只能为空\n即A是假命题": "Since False is empty type\nThus if function A->False exists\nThen if A type is non-empty\nCan derive False is also non-empty\nThus A type can only be empty\nI.e., A is false proposition", "类型论不同于经典逻辑\nnot(not A)仅表明\n无法提供A为假的证据\n并不能证明A为真\n因此有扇相邻的门\n是永远无法打开的": "Type theory is different from classical logic\n“not(not A)” only indicates\nwe cannot provide evidence of A being false\nThis cannot prove A is true\nThus there is an adjacent gate\nThat can never be opened", "除了点击推荐的策略\n还可直接输入策略点加号\n比如目标是A\n你恰好知道值a:A\n可手动输入“apply a”\n完成目标": "Besides clicking recommended strategies\nYou can also enter strategy then \nclick \"+\" button. E.g., the goal is A\nand you know some value a:A\nThen you can manually enter \"apply a\"\nTo complete the goal", "如果觉得写这些函数太晕\n建议把待证命题写在定理列表中\n然后点证明策略的加号\n使用解锁的证明助手": "If you feel writing these \nevidence functions is too diffcult\nyou can write the target type in proposition list\nThen press proof strategy's \"+\" button\nAnd use unlocked strategies of proof assistant", "解锁相等类型": "Unlock identity type", "若a与b类型都是A\n则eq a b是个类型\n可翻译为命题“a等于b”\n显然若a与b定义相等\n则命题“a等于b”一定成立\n故引入“refl a”表示该事实": "If both a and b have type A\nThen 'eq a b' is a type\nThis can be translated as proposition \"a equals b\"\nObviously if a and b are definitionally equal\nThen proposition \"a equals b\" must hold\nThus introduce evidence \"refl a\" to this fact ", "注意现在有“定义相等”\n与“命题相等”两种概念\n由于是否定义相等\n直接由系统判定\n故不引入相等类型\n就无法表达含假设命题\n“若两值相等，则...”": "Note there are two concepts: \n\"definitional equal\" and \"propositional equal\"\nSince definitional equal\nis directly determined by system\nThus without identity type\n We cannot express hypothetical proposition:\n\"If two values are equal, then...\"",
        "道理是这个道理\n但否定挪进去后\n真相就又变了\n(这边是附加题)": "The rule is clear, but\nonce the negation is moved in\nthe truth changes again.\n(This part is an extra question)",
        "提示：你可以在定理列表中\n输入a:b，让系统\n帮你检查a的类型\n是否为b": "Hint: you can enter a:b\n in proposition list to let \nthe system check whether \nthe type of a is b", "提示：你可以在定理列表中\n输入a===b，让系统\n帮你检查a与b\n是否定义相等": "Hint: you can enter a===b\n in proposition list to let \nthe system check whether a and b\nare definitionally equal", "定义相等一定命题相等\n反之不一定成立哦": "Definitional equal implies propositional equal\nbut the converse is not necessarily true", "“eq”其实有些隐藏参数\n故其类型中带问号\n系统可通过\n上下文的函数作用\n智能推断匹配\n问号开头的类型": "“eq” actually has hidden parameters\n e.g. the question marks in its type.\nThe system can  infer these\n question mark-prefixed types\nthrough contextual function application", "\n完整版是多元函数“@eq”\n它接受以下参数\n1.全类的下标数字u\n2.类型a:Uu\n3.值x:a与值y:a\n最后得到一个命题(即Uu类型)\neq省略了前两个参数": "\nThe full version is function “@eq”\nwhich accepts the following parameters\n1. Subscript number u of the universe\n2. Type a:Uu\n3. Values x:a and y:a\nIt Finally returns a proposition (i.e., of type Uu)\nfunction “eq” omits the first 2 parameters", "提示：一般来说没必要\n使用“expand eq”将其\n展开为“@eq”\n展开前后虽都定义相等\n但这只会让目标更复杂": "Hint: It's unnecessary to Use\n “expand eq” to expand it into “@eq”\nAlthough they are definitionally equal \nthis only make the goal more complex", "解锁rfl与相应证明策略\n(自动推断定义相等)": "Unlock rfl and corresponding proof strategy\n(automatically infer definitional equality)", "解锁自然数nat类型": "Unlock natural number (nat) type", "自然数“1”定义为\nsucc 0\n“2”定义为\nsucc (succ 0)\n ...": "Natural number \"1\" is\n defined as \"succ 0\"\n\"2\" is defined as\n\"succ (succ 0)\"\n ...", "解锁布尔类型Bool": "Unlock boolean type (Bool)", "解锁ind_True\n提示：后方可解锁\nind_eq": "Unlock ind_True\nHint: ind_eq can be unlocked ahead", "类型True只有一个值true\n要证对任意x:True成立\n其实只需论证对true成立\n引入ind_True作为\n该事实的证据": "Type True has only one value “true”\nTo prove for any x:True\nactually only need to check for value true\nIntroduce ind_True as\nevidence of this fact", "ind_True接受一个\n关于x:True的命题\n（命题的类型都是U，\n因此通过函数True->U定义）\n和该命题对true成立的证据\n从而输出该命题对\n任意x:True成立的证据": "ind_True accepts a\nproposition about x:True\n(All propositions have type U,\nthus defined via function True->U)\nand evidence that the proposition holds for true\nIt returns an evidence that \nthe proposition holds for any x:True", "给些证旁边命题的提示：\n看看表达式“ind_True \n(Lx:True.eq x true)”的类型": "Hints for solve the adjacent puzzle:\nThink of the type of expression \n“ind_True (Lx:True.eq x true)”,", "除了理解为命题\nind_True也可用于构造函数：\n要构造f:True->XXX\n只需给定f(true)的值即可\n公理类型列表中\nind_True的计算规则\n表示这一事实": "Besides understood as a proposition\nind_True can also be used to construct functions:\nTo construct f:True->XXX\njust need the value of f(true)\nIn the axiom type list\nind_True's computation rule\n(marked with 'COMP') shows this fact", "解锁积类型“X”与\n有序对构造子“(,)”、\n依赖值对类型“Σ”(S)与\n依赖有序对构造子“pair”": "Unlock product type “X” and\nordered pair constructor “(,)”,\ndependent pair type “Σ” (S) and\ndependent ordered pair constructor “pair”\n(constructors are marked with CTOR)", "对任意a:A与b:B\n可以构造有序对\n(a,b) : A X B": "For any a:A and b:B\nwe can construct ordered pair\n(a,b) : A X B", "对积类型A X B\n需要同时提供\na:A与b:B才能构造\n因此积类型可\n理解为命题“A且B”": "For product type A X B\nboth\na:A and b:B are needed to construct it\nThus product type can be\nunderstood as proposition \"A and B\"", "若(a,b)中，b的类型依赖于\na的值，则是依赖值对类型。": "If in (a,b), the type of b depends on\nthe value of a, it is a dependent pair type.", "即若B:A->U，a:A，b:B(a)，\n则依赖值对记作\npair B a b : Sx:A,B(x)\n若B是常函数则\n退化为非依赖的积类型": "That is, if B:A->U, a:A, b:B(a),\nthen dependent pair is denoted\npair B a b : Sx:A,B(x)\nIf B is a constant function\nit degenerates into a non-dependent product type",
        "要构造类型Sx:nat,eq x 1\n需要提供一个nat类型的值x\n和eq x 1类型的值\n明显我们可以选择1:nat\n和refl 1 : eq 1 1\n组成依赖有序对": "To construct type Sx:nat,eq x 1\nyou need to provide a nat type value x\nand eq x 1 type value\nObviously we can choose 1:nat\nand refl 1 : eq 1 1\nto form a dependent ordered pair", "因此也可把该\n依赖有序对类型\n理解为命题“存在x:nat\n使得eq x 1成立”": "Thus this dependent pair type\ncan also be understood as proposition \n\"There exists a natural number x\nsuch that x equals 1\"", "解锁证明策略\n“ex”与“case”": "Unlock proof strategies\n“ex” and “case”", "解锁证明策略“hyp”（假设）\n通过“hyp XXX”可以引入\n新的证明子目标XXX\n完成后将得到值:XXX\n作为条件供后续证明使用\n执行“hyp a:A”可将引入的目标\n证明后得到的变量命名为a": "Unlock proof strategy “hyp” (hypothesis)\nUsing “hyp XXX” can introduce\nnew proof subgoal XXX\nAfter subgoal completion, you'll get a value with type XXX,\n as a condition for subsequent proof steps\nExecuting “hyp a:A” can name \nthe introduced goal as variable a", "解锁和类型“+”": "Unlock sum type “+”", "和类型有左(inl)右(inr)\n两个构造子\n要构造类型A + B\n仅需提供a:A或b:B即可\n可翻译为“A或B”": "Sum type has left (inl) and right (inr)\ntwo constructors\nTo construct a value of type A + B\nwe only need to provide a:A or b:B\nThis can be translated as proposition \"A or B\"", "提示：可以直接在定理列表中\n写xxx : XXX\n断言xxx有类型XXX\n系统类型推断可自动\n匹配并验证其正确性": "Hint: You can write xxx : XXX\nin the proposition list\n to assert xxx has type XXX\nSystem type inference will\ncheck and verify its correctness", "解锁证明策略\n“left”/“right”": "Unlock proof strategies\n“left”/“right”", "欲证该命题，需对x:Bool\n通过ind_Bool分类讨论\n建议采用“destruct”/“rfl”\n“left”/“right”等证明策略\n辅助构造证据": "To prove this proposition, \nproving by cases for x:Bool\nthrough ind_Bool is needed\nRecommend using proof strategies \nlike “destruct”/“rfl”/“left”/“right”\nto construct evidence automatically", "积类型、依赖有序对\n它们类似Bool、nat、\nTrue、False、eq\n都是归纳类型\n也有相应的ind_xxx函数\n和相应的destruct策略": "Product types, dependent pairs\nThey are similar to Bool, nat,\nTrue, False, eq\nAll are inductive types\nAlso have corresponding ind_xxx functions\n(ind is for induction, i.e. destructor, marked with DTOR)\nand corresponding destruct strategies", "解锁ind_Prod": "Unlock ind_Prod", "依赖有序对类型只有唯一\n的带两个参数的构造子pair\n因此仅需证明由任意的两值\n组成的有序对成立，\n就可证对所有有序对成立": "Dependent pair type has only one\nconstructor pair with two parameters\nto prove a proposition for all ordered pairs,\nwe only need to check that ordered pairs\n composed of any two values hold", "提示：可通过ind_Prod定义函数\nf : aXb -> a，\n使得对任意x:a和y:b\n有f (x,y) === x": "Hint: To define function\nf : aXb -> a via ind_Prod,\nsuch that for any x:a and y:b\nf (x,y) === x", "解锁投影函数pr0/pr1\n与依赖投影函数prd1": "Unlock projection functions pr0/pr1\nand dependent projection function prd1", "解锁ind_Sum": "Unlock ind_Sum", "和类型A+B有两个\n分别带一个参数的构造子\n要证对所有A+B的值均成立\n需分别证明任意a:A对(inl a)成立，\n且任意b:B对(inr b)成立": "Sum type A+B has two\nconstructors each with one parameter\nTo prove for all values of A+B\nneed to respectively prove for any a:A holds for (inl a),\nand for any b:B holds for (inr b)", "不会解可交钱绕行": "Can't solve? Pay to bypass", "注意eq类型本身带参数\n而不像nat和积类型\n只是构造子带参数\n因此ind_eq是在对\n一簇类型使用“归纳法”": "Note that eq type itself takes parameters\nunlike nat and product types\nwhich only have constructors with parameters\nThus ind_eq uses \"induction\" on\na family of types", "类型eq a b只有一个带参数\n的构造子refl\n且只能构造出类型eq a a\n因此要证对任意m:eq a b成立\n只需证明对refl a成立": "Type eq a b has only one \nparameterized constructor refl\nand can only construct type eq a a\nThus to prove for any m:eq a b holds\nonly need to prove for refl a", "解锁ind_eq": "Unlock ind_eq", "解锁相等逆路径运算\ninveq": "Unlock inverse path operation for equality\ninveq", "解锁相等连接路径运算\ncompeq": "Unlock concatenation path operation for equality\ncompeq", "然而对任意类型a:U\n并不是非真即假\n比如有无法证明的命题\n还有其它复杂的非命题类型\n其实排中律Pa:U,a+(not a)\n在类型论中不可证": "However for any type a:U\nit may not be true and also not be false\nFor example, there are unprovable propositions\nand other complex non-propositional types\nIn fact, the law of excluded middle Pa:U,a+(not a)\nis unprovable in type theory", "若把命题逻辑中a3公理\n(~$0>~$1)>($1>$0)\n改成($1>$0)>(~$0>~$1)\n则跟类型论一样\n无法证明排中律\n与双重否定消去律\n还有皮尔士定律": "If axiom a3 in propositional logic\n(~$0>~$1)>($1>$0)\nis changed to ($1>$0)>(~$0>~$1)\nthen like in type theory\nwe cannot prove the law of excluded middle\nand double negation elimination\nand also Peirce's law", "解锁自动抄写技能\n将上次碰到的门上的命题\n抄下，以便使用证明助手": "Unlock auto-copy skill\nCopy the proposition on the last touched gate\nto make the proof assistant usage easier", "类型论可引入额外的公理\n让排中律成立\n从而可推出双重否定消去\n然而引入同伦类型论相关公理\n可以证明刚才对任意\n类型的排中律是错误的\n仅能引入公理让\n排中律对“纯命题”成立": "Type theory can introduce extra axioms\nto make the law of excluded middle hold\ntherefore double negation elimination can be proved\nHowever, introducing homotopy type theory related axioms\ncan prove that the law of excluded middle \nfor unlimited any type is wrong\nWe can only introduce axioms to make\nthe law of excluded middle hold for \"pure propositions\"", "解锁ind_False": "Unlock ind_False", "类型False没有值\n要证对任意x:False成立\n其实都永远成立\n引入ind_False作为\n该事实的证据\n即“从谬误能推出一切”": "Type False has no values\nTo prove for any x:False holds\nwe do nothing, it actually always holds\nIntroduce ind_False as\nevidence of this fact\nnamely \"from falsehood, anything follows\"", "解锁ind_Bool\n提示：后方可解锁\nind_nat与\n策略destruct": "Unlock ind_Bool\nHint: ind_nat andstrategy \"destruct\"\n can be unlocked ahead", "类型Bool有值0b和1b\n要证对任意x:Bool成立\n只需对0b与1b均成立\n引入ind_Bool作为\n该事实的证据": "Type Bool has values 0b and 1b\nTo prove for any x:Bool holds\nonly need to check 2 cases: 0b and 1b\nIntroduce ind_Bool as\nevidence of this fact", "提示：需分别证明\n1. (not (eq 0b 0b))\n->(eq 0b 1b)；\n2. (not (eq 1b 0b))\n->(eq 1b 1b)。\n还有困难可交钱给更多提示": "Hint: Need to prove respectively\n1. (not (eq 0b 0b))\n->(eq 0b 1b);\n2. (not (eq 1b 0b))\n->(eq 1b 1b).\nStill stucked? Pay for more hints", "ind_Bool函数首先接受\n一个关于x:Bool的命题\n然后分别接受对0b与1b\n成立的命题证据\n最后返回该命题的证据": "ind_Bool function first accepts\na proposition about x:Bool\nthen accepts evidences for 0b and 1b\nfinally returns evidence of the proposition", "看看值“ind_Bool \n(Lx:Bool.(not (eq x 0b))\n->(eq x 1b))”的类型\n它将提醒你还需要\n提供哪些参数": "Consider the type of value “ind_Bool \n(Lx:Bool.(not (eq x 0b))\n->(eq x 1b))”\nIt will remind you which \nkind of evidences are still needed", "1.要证关于0b的命题\n可通过假设“not (eq 0b 0b)”\n得到一个False类型的值\n然后用否定爆炸ind_False即可；\n2.要证关于1b的命题则很简单": "1. To prove the proposition about 0b\nwe can obtain a False type value via assuming “not (eq 0b 0b)”\nthen use explosion principle from ind_False;\n2. Proving the proposition about 1b is simple", "解锁ind_nat": "Unlock ind_nat", "自然数(nat)类型有两个构造子\n“0”与“succ”\n其中“succ”是带一个\n递归参数的构造子": "Natural number (nat) type\n has two constructors: “0” and “succ”\nwhere “succ” is a constructor\nwith a recursive parameter", "因此要证关于任意自然数的命题\n要提供命题对0成立的证据\n和对“succ”成立的证据": "Thus to prove a proposition about any natural number,\nWe need to provide evidence that the proposition holds for 0\nand also it holds for “succ”", "带递归参数的“succ”有点复杂\n类似于积类型、和类型的参数\n这意味着要证对任意的n:nat\n命题对succ n都成立": "“succ” with a recursive parameter is a bit complex\nsimilar to parameters of product and sum types\nThis means we need to show evidence \nthat for any n:nat, it holds for succ n", "然而该参数的递归性\n却给我们提供了额外信息\n即由于递归构造，\n其实已经知道\n命题对该参数n成立了": "However, the recursiveness of this parameter\nprovides us with extra information\nthat is, due to recursive construction,\nwe actually already know\nthe proposition holds for parameter n", "因此命题“对构造子succ成立”\n其实是，对任意的n:nat\n都有若已知命题对n成立\n都能推出对succ n成立\n即等价于数学归纳法": "Thus the proposition \"holds for constructor succ\"\nis actually, for any n:nat\nif the proposition holds for n\ncan derive it holds for succ n\nwhich is equivalent to mathematical induction", "解锁证明策略destruct\n它将自动引入ind_XXX\n改写证明目标": "Unlock proof strategy destruct\nIt will automatically introduce ind_XXX\nto rewrite the proof goal", "解锁证明策略\n“simpl”\n即系统通过定义相等关系\n自动化简证明目标": "Unlock proof strategy simpl:\n the system automatically simplifies \nthe proof goal through definitional equality", "ind_nat还可以理解为\n递归函数的生成器：\n构造函数f(x)需要给定f(0)的值，\n然后对任意自然数n\n通过n与f(n)的值来给出f(n+1)的值": "ind_nat can also be understood as\na generator of recursive functions:\nTo construct function f(x), the value of f(0) is needed,\nthen for any natural number n\nf(n+1) is contructed by n and f(n)\n hence a function (n and f(n) as its parameters) is needed", "解锁翻倍函数\ndouble : nat->nat": "Unlock double function\ndouble : nat->nat", "解锁加法函数\nadd : nat->nat->nat": "Unlock addition function\nadd : nat->nat->nat", "来都来了，\n这点小钱都出不起吗？\n赶紧交钱，\n不然你自己想办法过去": "Since you're already here,\ncan't afford this small amount of money?\nPay up quickly,\notherwise figure out how to pass by yourself", "解锁“前继”函数\npred : nat->nat": "Unlock \"predecessor\" function\npred : nat->nat", "解锁相等替换改写策略\nrw(rewrite)\n与rwb(rewrite back)": "Unlock equality substitution rewrite strategies\nrw (rewrite)\nand rwb (rewrite back)", "若m: eq a b，则\n执行策略“rw m”\n将通过ind_eq把证明目标\n中的所有a改写成b": "If m: eq a b, then\nexecute strategy “rw m”\nit will rewrite all a to b in the proof goal\nvia ind_eq", "若没解锁ind_eq\n系统会认为ind_eq未定义\n无法使用该策略完成证明\n提示：在ind_True的后方\n可解锁ind_eq": "If ind_eq is not unlocked yet\nthe system will consider ind_eq undefined\nand you can't use this strategy for the proof\nHint: ind_eq can be unlocked behind ind_True", "若m: eq a b，则\n执行策略“rwb m”\n将通过ind_eq把证明目标\n中的所有b改写成a": "If m: eq a b, then\nexecute strategy “rwb m”\nit will rewrite all b to a in the proof goal\nvia ind_eq", "证succ m=succ n -> m=n 的提示：\n直接用ind_nat归纳法\n无法化简证明目标\n需引入pred函数": "Hint for proving succ m=succ n -> m=n:\nDirectly using ind_nat induction\ncannot simplify the proof goal\nWe need to introduce pred function", "解锁常见相等类型证据\nap/trans/apd": "Unlock common identity type evidences\nap/trans/apd", "1.ap是x=y推出\nf(x)=f(y)的证据\n2.trans是若x=y，则命题对x成立\n就能推出对y成立的证据\n3.apd是ap的依赖类型函数版本\n由于x与y可以不定义相等\n故若f(x)与f(y)类型不同\n无法直接用eq比较相等\n需要通过trans函数转换到\n同一类型后才能用eq比较": "1. ap is evidence that x=y implies f(x)=f(y)\n2. trans is evidence that if x=y, then a proposition \nholding for x implies it also holds for y\n3. apd is the dependent type function version of ap\nSince x and y may not be definitionally equal\nif f(x) and f(y) have different types\nwe cannot directly compare equality with eq\nConvertion to the same type via trans function\n is needed before comparing with eq", "解锁圆周类型\nS1\n(高阶同伦归纳类型)": "Unlock circle type\nS1\n(high-order homotopy inductive type)", "解锁“等价”关系\neqv: U->U->U": "Unlock \"equivalence\" relation\neqv: U->U->U", "如果两个类型a与b之间\n存在可逆的\n一到一的双射f:a->b\n则它们等价，记作\neqv A B": "If between two types a and b\nexists an invertible\nbijection f:a->b\nthen they are equivalent, denoted\neqv A B", "“f是双射”即为\n存在函数g与h\n使得f(g x) = x\n且h(f x) = x": "\"f is a bijection\" means\nexist functions g and h\nsuch that f(g x) = x\nand h(f x) = x", "解锁同伦类型论\n泛等公理\nua\n(等价即相等)": "Unlock homotopy type theory\naxiom of univalence (ua)\n(equivalence is equality)", "loop不等于rfl的证明思路：\n通过ind_S1构造映射f:S1->U\n其中让f(base)=Bool，\nf(loop)=ua(e)\n若loop与rfl相等，则\nua(e)与rfl相等\n后者能推出e(x)=x矛盾\n(e在双重否定消去思路中定义)": "Proof idea for loop ≠ rfl:\nConstruct map f:S1->U via ind_S1\nwhere f(base)=Bool,\nf(loop)=ua(e)\nIf loop = rfl, then\nua(e) = rfl\nThe latter implies e(x)=x contradiction\n(e defined in double negation elimination idea)", "双重否定消去错误\n的证明思路：\n设映射e:Bool->Bool\n且e(0b)=1b，e(1b)=0b\n可证e是Bool自身到自身的双射\n即能构造eqv Bool Bool的证据": "Proof idea for double negation elimination is wrong:\nLet map e:Bool->Bool\ne(0b)=1b, e(1b)=0b\nWe can prove e is a bijection of Bool to itself\ni.e., construct evidence of eqv Bool Bool", "则ua(e):eq Bool Bool\n通过ua(e)使用ind_eq\n可证明若存在f:Pa:U,~~a->a\n则能推出e(f Bool x)=f Bool x\n从而可推出矛盾": "Then ua(e):eq Bool Bool\nUsing ind_eq via ua(e)\n we can prove that if there exists f:Pa:U,~~a->a\nthen e(f Bool x)=f Bool x can be derived\nthus leading to a contradiction", "泛等公理不仅说ua是命题\n“(eqv a b)->(eq a b)”的证据\n它还说ua映射与id2eqv\n映射互为逆映射": "The axiom of univalence not only indicates\n ua is evidence for proposition\n“(eqv a b)->(eq a b)”\nIt also says the ua map and id2eqv\nmap are inverse to each other", "映射id2eqv为命题\n“(eq a b)->(eqv a b)”的证据\n该证据可通过ind_eq得到\n不需要添加新公理": "Map id2eqv is evidence for proposition\n“(eq a b)->(eqv a b)”\nThis evidence can be obtained via ind_eq\nwithout adding new axioms", "解锁ind_S1": "Unlock ind_S1", "解锁乘法函数\nmul : nat->nat->nat": "Unlock multiplication function\nmul : nat->nat->nat", "这种函数嵌套类型\n其实就是多元函数类型": "This nested function type\nis actually a multi-argument function type", "输入的自变量为\na:U、b:U、c:U、\nx:a->b->c、y:a->b、\nz:a这六个": "Input arguments are\na:U, b:U, c:U,\nx:a->b->c, y:a->b,\nz:a (total 6 inputs)", "输出的变量类型为c\n我们的目标就是要构造\n有这样输入输出\n类型的多元函数": "Output variable type is c\nOur goal is to construct\na multi-argument function\nwith such input and output types", "于是可以先写\nLa:U.Lb:U.Lc:U.\nLx:a->b->c.\nLy:a->b.Lz:a.???\n其中???类型是c，值还不确定": "Thus we can first write\nLa:U.Lb:U.Lc:U.\nLx:a->b->c.\nLy:a->b.Lz:a.???\nWhere ??? has type c, but with unknown value ???", "只要在给定的输入变量下\n能凑出一个类型为c的值\n将其填入???处即可": "Under given input variables,\na value of type c need to be constructed\nthen fill it in the ??? place,\nthat's all", "类型c只出现过两次\n第一次c:U，告诉我们它是个类型\n第二次出现在x:a->b->c": "Type c occurs only twice\nFirst c:U, telling us it's a type\nSecond occurs in x:a->b->c", "即输入类型为a、b的两个值，\nx函数就能得到\n类型为c的值": "That is, given two values of types a, b,\nfunction x can output\na value of type c", "类型为a的值是有的，\n它是z\n因此要找类型为b的值": "A value of type a is \nalready available: it is z\nThus now we need to find a value of type b", "注意到y:a->b\n意味着输入a类型的变量\n就能得到b类型的变量：\n(y z) : b": "Notice that y:a->b\nmeans inputting a variable of type a\ncan obtain a variable of type b:\n(y z) : b", "现在可以让函数x作用了：\n因为z:a、(y z):b\n所以x z (y z):c\n这就是???处要填入的表达式": "Now we can apply function x:\nBecause z:a, (y z):b\nThus x z (y z):c\nThis is the expression to fill in the ??? place", "能看到这里\n的玩家也太辛苦了\n给点奖励合不合适？": "You can read up to here\nYou work really hard!\nIs it appropriate to give a reward?", "合适得不得了": "Yes!",
        "到达序数ω²": "Reach ordinal ω²", "解锁ZFC集合论\n无穷公理(aInf)": "Unlock ZFC set theory\naxiom of infinity (aInf)", "解锁自然数与\n后继函数\n的集合论定义": "Unlock the ZFC set definitions of \nnatural numbers and successor function", "解锁第一个无限集合\n“ω”(omega)\n(即自然数集)": "Unlock the first infinite set\n“ω” (omega)\n(i.e. set of natural numbers)", "解锁二元关系谓词(Rel)\n定义": "Unlock definition of binary relation predicate (Rel)", "提示：证明不可数集合\n的存在请前往序数\nω^ω^ω\n\n证明良序定理\n请前往序数\nω^(ω+2)+ω^(ω+1)+ω^ω": "Hint: To prove the existence of uncountable sets\nGo to ordinal\nω^ω^ω\n\nTo prove the well-ordering theorem\nGo to ordinal\nω^(ω+2)+ω^(ω+1)+ω^ω", "解锁全序(Order)与\n良序(WellOrder)\n定义": "Unlock definitions of Order and WellOrder", "解锁双射(Equiv)谓词的定义": "Unlock definition of bijection (Equiv) predicate", "解锁类型层中的\n序数类型Ord": "Unlock ordinal type (Ord) in type layer", "提示：正常使用序数类型\n需先解锁类型层\n与自然数类型": "Hint: To use ordinal types, you need to first\nunlock type layer and natural number type", "将序数进位基底\n降至3": "Reduce ordinal base to 3", "将序数进位基底\n降至2": "Reduce ordinal base to 2", "解锁技能\n将能前往的最大序数\n的后继运算提升至指数": "Unlock skill\nUpgrade the successor operation of 、nthe maximum reachable ordinal to exponential", "门#א": "Gate #א", "欢迎来到序数的世界\n序数是自然数的推广": "Welcome to the world of ordinals\nOrdinals are generalizations of natural numbers", "序数不仅包含自然数\n还包含很多种“无穷大”": "Ordinals not only include natural numbers\nbut also many kinds of \"infinities\"", "要想突破有限到达无穷\n需要借助极限的力量": "To beyond finiteness to reach infinity\nWe need the power of limit", "进度层中的数据统计\n记录了你能前往的最大序数\n以及序数的“进位”机制": "Game statistics in progress layers\nrecord the maximum ordinal you can reach\nand the \"carry\" mechanism of ordinal base", "到达一个序数有两种方式\n一是取“后继”\n二是取“极限”": "There are two ways to reach an ordinal\nOne is to take the \"successor\"\nThe other is to take the \"limit\"", "后继就是下一个数\n即加上1": "Successor is the next number\nthat is, plus 1", "取“极限”进位则是把\n大于某个数的数字\n视为无穷“ω”\n(提示：你可以第一次进位了)": "Taking a \"limit\" carry is to regard\nnumbers greater than a certain number\nas infinity \"ω\"\n(Hint: You can carry for the first time)", "进位与序数更精确的描述如下\n每个序数都等同于先于它的\n所有序数构成的集合": "A more precise description of limit ordinals is:\nEach ordinal is equal to the set of all ordinals\nsmaller than it", "将序数0定义为空集{}\n则1 = {0}\n2 = {0,1}\n3 = {0,1,2}\n.....": "Define ordinal 0 as empty set {}\nthen 1 = {0}\n2 = {0,1}\n3 = {0,1,2}\n.....", "这样从序数n得到\n的序数n U {n}\n就叫后继序数": "Thus the ordinal obtained from ordinal n as\nn U {n}\nis called a successor ordinal", "不是后继序数的序数\n叫极限序数\n如 ω = {0,1,2,3,4...}\n即自然数的集合\n是第一个除0外的极限序数": "Ordinals that are not successor ordinals\nare called limit ordinals\nSuch as ω = {0,1,2,3,4...}\nthat is, the set of natural numbers\nis the first limit ordinal except 0", "虽然极限序数无法\n在有限步之内达到\n进位机制可让你在\n有限步之内完成“飞升”": "Limit ordinals cannot be reached\nwithin finite steps\nBut the carry mechanism allows you to make\n an infinit giant jump within finite steps", "提示：ω17+7处\n有一些重要的线索": "Hint: At ω17+7\nthere are some important clues", "到达序数ω³": "Reach ordinal ω³", "刚刚你路过了\n宇宙的终极答案的后继": "Just now you passed by\nthe successor of the ultimate answer of the universe", "你或许发现了\n这些数字\n都是质数": "You may have noticed\nThese numbers\nare all prime numbers", "质数有无穷个\n一直走下去也没什么意思": "There are infinitely many prime numbers\nIt's not interesting to keep going", "真的还要继续前进吗？": "Do you really want to continue advancing?", "好了我的朋友\n请回吧": "Well my friend\nPlease go back", "这个游戏最主要的\n谜题是形式系统\n难道不是吗？": "The main puzzle of this game is the formal system\nIsn't it?", "还有好多谜题等着\n你来解开呢\n别贪玩了": "There are many puzzles waiting\nfor you to solve\nDon't be too nauty", "你知道吗？\n为了你继续向前走\n我在这里要多码\n好几百字呢": "Did you know?\nFor you to keep moving forward\nI have to write \nhundreds of words here", "而且，再往下走\n你的浏览器继续加载\n地图，内存会溢出的": "Moreover, going further down\nYour browser continues to load\n more map contents, memory will overflow", "别走了，速回！\n请听我的话\n我不会害你的": "Don't go further, come back quickly!\nPlease listen to me\nI won't harm you", "快回去！\n你这个顽固的家伙！": "Go back!\nYou stubborn guy!", "你继续向前走吧\n我不管你了！": "Go forward!\nI don't care about you anymore!", "别找我！": "Don't look for me!", "别烦我！": "Leave me alone!", "你真的疯了": "You are really crazy", "为纪念你来到这里\n现将终极答案\n印发给你们": "To commemorate your arrival here\nNow print the ultimate answer\nfor you",
        "向前追寻答案吧！\n(建议保存一下游戏进度\n再去追寻哦)": "Go forward in pursuit of the answer!\n(Hint: Save your game progress\n before you set off)",

        "拆除门#L": "Destruct gate #L", "\n未解锁的闸门无法通过\n请寻找线索解开闸门\n#K": "\nLocked gate cannot be passed\nFind clues to unlock it\n#K", "门#K在离\n#p闸门开启方法说明\n直线距离2格远的地方\n": "Gate #K is\n2 grids away in straight line\nfrom gate #p unlock method description\n", "\n未解锁的闸门无法通过\n请寻找线索解开闸门\n#L": "\nLocked gate cannot be passed\nFind clues to unlock it\n#L", "\n未解锁的闸门无法通过\n请寻找线索解开闸门\n#<>(↔)": "\nLocked gate cannot be passed\nFind clues to unlock it\n#<>(↔)", "逆演绎元定理其实就是\n相应公理与mp规则的简单组合\n但组合后的条件自动匹配\n如推理规则“<a1”为\n$1⊢$2>$1": "Inverse deduction metatheorem is \nsimple combination of corresponding axioms and mp rule\nbut conditions automatically match\nE.g., deduction rule “<a1” is $1⊢$2>$1", "提示：对某个\n命题逻辑的公理使用\n元推理规则mq\n来打开这扇门": "Hint: Use metadeduction rule mq on\nsome propositional logic axiom\nto open this gate", "若$0中没有一阶逻辑量词\n则自由出现指$0中含有$1\n": "If $0 has no first-order logic quantifiers\nfree occurrence means $0 contains $1\n", "若#nf函数验证成功\n则系统自动删去#nf函数\n若验证失败系统将报错": "If #nf function verification succeeds\nthe system automatically removes it\nIf verification fails, the system gets an error", "Vx:$1中x被量词约束\n不会自由出现\n因此可使用公理a6": "In Vx:$1, x is bound by quantifier\nwill not occur freely\nThus can use axiom a6", "Vx:$1中y没被量词约束\n可能在$1中自由出现\n因此无法使用公理a6": "In Vx:$1, y is not bound by quantifier\nmay occur freely in $1\nThus cannot use axiom a6", "解锁等词公理a8": "Unlock equational axiom a8", "解锁门#I1": "Unlock gate #I1", "解锁等词公理a7": "Unlock equational axiom a7", "解锁概括元定理": "Unlock generalization metatheorem", "看似直接使用两次\n“ (z@x & ~z=z))": "First simplify axiom of separation\nvia mutual replacement into\nnormal human form:\nVx:Ey:Vz:\n(z@y <> (z@x & ~z=z))", "Unlock ZFC simplified toolkit\nwhich rewrites all ZFC axioms\nusing more convenient\nhuman习惯的符号": "解锁ZFC简化大礼包\n即用更方便的\n人类习惯的符号\n重新书写ZFC所有公理", "解锁ZFC集合论\n并集公理(aUnion)": "Unlock ZFC set theory\naxiom of union (aUnion)", "解锁并集符号\n“U”": "Unlock union symbol\n“U”", "解锁ZFC集合论\n幂集公理(aPow)": "Unlock ZFC set theory\naxiom of power set (aPow)", "解锁门#I2": "Unlock gate #I2", "此处向前有开#I3的钥匙": "Ahead lies the key to open gate #I3", "解锁门#I3": "Unlock gate #I3", "解锁加法与乘法算数": "Unlock addition and\n multiplication arithmetic", "看似直接使用两次\n“<a4”规则即可消去量词\n但$x或$y可能是y或x\n因此可能一个变量被替换两次": "It seems that applying the\"<a4\" rule\n twice would directly eliminate the quantifiers.\nHowever, $x or $y could be y or x,\nwhich may cause a variable being replaced twice.", "解决方法：先把x、y替换成\n与$x、$y永不相同的\n#x、#y，然后用概括定理\n加上量词V#x:V#y:\n(也可先用a6公理加量词\n再用“vv<a4”消内部量词\n并同时将x/y替换为#x/#y）": "Solution: First replace x and y with\n#x and #y, symbol “#” are guaranteed to be different from “$”.\nThen apply the generalization theorem\nwith the quantifiers ∀#x:∀#y:\n(Or, you can first introduce quantifiers using Axiom a6,\nthen eliminate the inner quantifier with rule \"vv<a4\",\nwhile replacing x/y with #x/#y).", "然后再使用两次\n“<a4”规则消去量词\n这时由于$x、$y不可能是\n#x、#y，不再出现循环替换问题": "Then apply the \"<a4\" rule twice to remove the quantifiers.\nSince $x and $y cannot be #x and #y,\nthe problem of cyclic substitution is avoided.", "受够了自由出现\n的条件#nf了吗？\n快试用“#”开头的局部变量\n在录制宏的过程中\n它将视为与一切“$”开头\n的符号都不同\n摆脱#nf的困扰": "Tired of the #nf condition for variables?\nTry using local variables prefixed with \"#\".\nDuring macro recording,\nthey are treated as distinct from all symbols starting with \"$\",\nfreeing you from #nf constraints.", "尝试把分离公理中的$0\n替换为~(z=z)\n以证明空集存在": "Try replacing $0 in the Axiom of Separation\n with ~(z=z) to prove the existence of the empty set.", "解锁谓词包含符号“⊂”(<)": "Unlock the predicate inclusion symbol \"⊂\" (<).", "解锁交集运算符\n“∩”(I)": "Unlock the intersection operator\n“∩” (I).",
        "提示:配对公理大概说的是\n任意两个集合x,y\n都存在集合{x,y}": "Hint: The Axiom of Pairing roughly states that\nFor any two sets x, y,\nthe set {x, y} exists.", "向前走，有更多关于证明\n空集存在性的提示": "Go forward for more hints on proving\nthe existence of the empty set.",
        "首先把分离公理\n通过互推替换化简为\n正常人类使用的形式：\nVx:Ey:Vz:\n(z@y <> (z@x & ~z=z))": "First, simplify the Axiom of Separation\nthrough IFF metatheorem into \na form read by normal humans:\nVx:Ey:Vz:(z@y <> (z@x & ~z=z))",
        "下面是重点：消去量词\n看似直接使用两次\n“<a4”规则即可消去量词\n但$0或$1可能是y或x\n因此可能一个变量被替换两次": "The key point: Eliminating quantifiers.\nIt seems that applying\n the \"<a4\" rule twice can work,\nbut $0 or $1 might be y or x,\n may leading to substitution twice.",
        "λx:A.x的类型是Πx:A,A\n因为x的类型是A": "The type of λx:A.x is Πx:A,A\nbecause the type of x is A.",
        "λx:A.True的类型是Πx:A,U\n因为True的类型是U": "The type of λx:A.True is Πx:A,U\nbecause the type of True is U.",
        "类似也有变量\n在某表达式中\n“自由出现”的概念": "Similarly, there is the concept of a variable\n\"free\" or \"bound\"\nin an expression.",
        "λx:U.λy:x.y类型为\nΠx:U,Πy:x,x\n因为λy:x.y\n类型为Πy:x,x": "The type of λx:U.λy:x.y is\nΠx:U,Πy:x,x\nbecause the type of λy:x.y\nis Πy:x,x.",
        "例：λx:A→B.x\n的类型为(A→B)→(A→B)": "Example: The type of λx:A→B.x\nis (A→B)→(A→B).",
        "下面介绍函数作用\n": "Next, we introduce function application.\n",
        "例：λx:A→B.λy:A.x y\n的类型为(A→B)→(A→B)\n因为x y的类型为B": "Example: The type of (λx:A→B.λy:A.x y)\nis (A→B)→(A→B)\nbecause the type of (x y) is B.",

        "我是程序化生成的\n你玩得过我？": "I'm procedurally generated\nDo you think you can beat me?",
        "好了，我也不怕\n跟你撕破脸": "Fine, I'm not afraid\nto show my hand",
        "走到天荒地老\n谁怕谁": "Walk till the end of time\nNo one's backing down here!",
        "xxx@163.com": "xxx@163.com",
        "我懒得理你了": "I can't be bothered with you anymore",
        "都要破两百了\n有何感想？": "Nearly hitting 200\nHow do you feel?",
        "985不是质数": "985 is not a prime number",
        "但233是质数": "But 233 is a prime number",
        "唉，算了\n看你这么无聊\n解锁个类型层\n的序数给你玩玩？": "Oh, fine\nSince you're so bored\nHow about unlocking an ordinal\nfrom the type layer for you to play with?",
        "想得美！\n继续走吧你": "In your dreams!\nKeep moving",
        "前进！不择手段地前进！": "Advance! at all costs!",
        "走走走！": "Let's go! Let's go!",
        "走走走！！": "Move along! Move along!!",
        "请前往序数ω²3+ω4+7\n解锁序数类型": "Please go to ordinal ω²3+ω4+7\nto unlock the ordinal type",
        "去那个那么小的序数\n你应该不在话下": "Going to such a small ordinal\nshould be a breeze for you",
        "恭喜你，步数破400！": "Congratulations, you've passed 400 steps!",
        "过截角正五胞体，\n前进四！": "Bitruncated 5-cell,\nFull ahead!",
        "我一直在督促你回家": "I've been urging you to go home",
        "空袭预警！\n空袭预警！": "Air raid warning!\nAir raid warning!",
        "恭喜你，步数破千！": "Congratulations, you've passed 1000 steps!",
        "恭喜你，到达了\n第五个梅森素数": "Congratulations, you've reached\nthe fifth Mersenne prime"

    };
    dataEn = {
        // tt/assist.ts
        "无证明目标，请使用 qed 命令结束证明": "No goal. Please enter 'qed' to finish the proof.",
        "无法重复 intro 相同变量名": "Cannot intro the same variable name",
        "intro 只能作用于函数类型": "Strategy 'intro' can only be applied to function types",
        "无法对类型": "Cannot operate on the type ",
        "使用 apply 策略作用于类型": " using the strategy 'apply' to the type",
        "请输入用于改写的相等假设": "Please enter the equality hypothesis for rewrite",
        "使用 rewrite 策略必须提供一个相等类型": "Must provide an identity type when using the 'rewrite' strategy",
        "无法对非相等类型使用 rfl 策略": "Cannot use the 'rfl' strategy for non-identity types",
        "使用 rfl 策略失败：等式两边无法化简至相等": "rfl strategy failed: The two sides of the equation cannot be simplified to be equal",
        "证明尚未完成": "The proof is not yet complete",
        "无法引入重复名称的假设变量": "Cannot introduce hypothesis variables with duplicate names",
        "只能解构归纳类型的变量": "Only variables of inductive types can be destructed",
        "解构失败：其它变量依赖该变量": "Destruction failed: Other variables depend on this variable",
        "destruct 引入了重复的变量名": "Strategy 'destruct' introduced duplicate variable names",
        "ex 策略只能作用于依赖积类型": "The 'ex' strategy can only be applied to dependent product types",
        "left 策略只能作用于和类型": "The 'left' strategy can only be applied to sum types",
        "case 策略只能作用于积类型": "The 'case' strategy can only be applied to product types",
        "未找到任何指定展开的项": "No terms to expand",
        // tt/gui.ts
        "推荐策略：<br>": "Recommended strategy: <br>",
        "最近#t门上的目标：": "Last Puzzle on #t Gate: ",
        "无目标，请输入qed结束": "No goals, enter 'qed' to finish",
        "目标": "Goal ",
        "当前目标：": "Current goal: ",
        "：": ": ",
        "表达式因错误而丢失": "Expression lost due to error",
        "类型": "TYPE",
        "构造": "CTOR",
        "解构": "DTOR",
        "定义": "DEFN",
        "计算": "COMP",
        "的定义重复": " definition is redundant",
        ":=符号左侧仅允许出现自定义常量": "Only user-defined constants allowed on left side of :=",
        "空表达式": "Empty expression",
        "不是命题类型": "Not a proposition type",
        "已断言该类型有值": "Already asserted inhabitation for this type",
        "命题格式有误：": "Malformed proposition: ",
        "请在定理列表中点选待证命题": "Please select a proposition to prove from the proposition list",
        "未知的证明策略": "Unknown strategy",
        //tt/astparser.ts
        "Lambda未匹配“.”号": "Missing '.' after Lambda", "Pi未匹配“,”号": "Missing ',' after Pi", "未知的语法错误": "Unknown syntax error", "不完整的表达式": "Incomplete expression", "表达式丢失": "Expression missing", "表达式不完整": "Incomplete expression", "语法错误：未找到符号\"": "Syntax error: Missing symbol \"",
        //tt/check.ts
        "类型断言失败：“:” 左边表达式类型为": "Type assertion failed: Type of expression on left side of ':' is", "非函数尝试作用": "Non-function attempted to be applied", "函数与作用目标类型不匹配：函数": "Function type mismatch with argument: Function ", "需要接受的参数类型为": " expects argument type is ", "，作用对象": ", but argument ", "类型为": " has wrong type of ", "意外出现非全类：": "Unexpected non-universe type: ", "由于系统性能问题，递归大数字超时": "Recursive large number timeout due to system performance issues", "未知的变量：": "Unknown variable: ", "未匹配": "Unmatched", "未知的语法树": "Unknown syntax tree", "意外的空表达式": "Unexpected empty expression", "整数太大超过表示上限": "Integer too large, exceeds representation limit",
        //tt/core.ts
        "函数参数类型不合法": "Invalid function parameter type",
        "函数返回类型不合法": "Invalid function return type",
        "函数作用导致类型推断信息丢失": "Type inference information lost due to function application",
        "函数作用类型不匹配": "Type mismatch in function application",
        "类型断言失败": "Type assertion failed",
        "定义相等断言失败": "Definitional equality assertion failed",
        "未知的全类层级运算": "Unknown universe type operation",
        "尝试对非全类操作层级": "Attempted to use hierarchy operator for non-universe object",

        // game.ts
        "、后继指数提升": " with successor exponential boost",
        "（此门已拆除）": "(Destructed Gate)",
        "请粘贴进度代码：": "Please paste your progress code: ",
        "请粘贴进度代码至保存加载按钮下方的文本框内。粘贴好了请点确定，还未粘贴请先点取消\n注意：加载新进度后，当前游戏进度会丢失！": "Please paste the progress code into the text box below the Save/Load button. After pasting, click OK. If you haven't pasted it yet, click Cancel first.\nWarning: Loading new progress will erase your current game progress!",
        "进度代码为空！": "Progress code cannot be empty!",
        "获得成就：": "Unlocked Achievement: ",
        "推理素": "Deductrium",
        "共": "Total ",
        // fs/gui.ts
        "假设": "[Hyp]",
        "请输入命令": "Please enter command",
        // fs/cmd.ts
        "命令：": "Command: ",
        " 共": ". Total ",
        "可复制定理内容，按Esc取消": "Copying propoition content is avaliable, press Esc to cancel",
        "可复制生成定理的命令，按Esc取消": "Copying propoition generation command is avaliable, press Esc to cancel",
        "无效命令": "Invalid command",
        "意外的错误：": "Unexpected error: ",
        "请输入或点击要展开的推理规则或定理\n按Esc取消": "Please enter or click the deduction rule or props to expand\nPress Esc to cancel",
        "\n要展开推理规则，请先按Esc返回": "\nTo expand deduction rules, please press Esc to return first",
        "\n无法展开不存在的规则": "\nCannot expand non-existent rule",
        "目前位于": "Currently at ",
        "上层命令：": "Command of Parent Layer: ",
        "层推理宏内，按Esc返回上一层定理表，或继续输入/点击要展开的定理": " layer(s) of deduction macros, press Esc to return to outter layer\nOr continue to enter/click the proposition to expand",
        "请输入或点选使用推理宏得到的定理": "Please enter or click the propostion obtained by deduction macro",
        "该定理或规则不存在。": "The propostion or rule does not exist.",
        "要展开规则，请确保定理列表为空。": "Please ensure that [P] list is empty if you want to expand rules.",
        "展开定理出错：": "Error while expanding propostion:",
        "请输入或点选元规则，按Esc取消": "Please enter or click metarule, press Esc to cancel",
        "该元规则不存在，元推理取消": "The metarule does not exist, metadeduct canceled",
        "元推理已取消：条件推理规则不存在": "Metadeduct canceled: Condition rule does not exist",
        "正在进行元推理": "Metadeducting ",
        "请输入条件": "Please enter the condition ",
        "的推理规则名或点推理规则": " by deduction rule name or click it in the [D] list.",
        "请输入替代": "Please enter the content for replacing ",
        "的内容": ".",
        "很抱歉，该规则暂未被作者实现": "Sorry, this rule has not been implemented yet",
        "错误：": "Error: ",
        "请输入或点选推理规则，按Esc取消": "Please enter or click an deduction rule, press Esc to cancel",
        "推理已取消：\n未找到推理规则": "Deduction canceled:\nDeduction rule not found",
        "推理已取消：条件定理不存在": "Deduction canceled: Condition proposition does not exist",
        "正在进行推理": "Deducting",
        "的定理编号，或点选定理": " by proposition number or click it in the [P] list.",
        "中包含了系统保留的符号“##”": "contains the system reserved symbol \"##\"",
        "推理已取消\n": "Deduction canceled\n",
        "请输入要删除的推理规则名称": "Please enter the rule name to delete", "列表中无此规则": "The rule does not exist in the list", "删除推理规则失败：": "Failed to delete rule: ", "请输入假设命题p": "Please enter the hypothesis proposition p", "，或按“Esc”结束": ", or press \"Esc\" to end", "\n请点选定理！": "\nPlease select a proposition!", "\n请点选推理规则！": "\nPlease select a deduction rule!", "请输入在哪个规则后方插入新规则。若直接输入新规则名称，则默认插入至规则表最后": "Please enter the rule after which to insert the new rule. If you enter the new rule name directly, it will be inserted at the end of the rule table by default", "请输入新规则名称": "Please enter the new rule name",
        "以.<>acdempuv#或数字开头的推理规则名称由系统保留，请重新命名": "Rule names starting with .<>acdempuv# or numbers are reserved by the system, please rename",
        "元规则输入中不能包含以$$开头的变量": "Variables starting with $$ cannot appear in metarule input",
        "以$$开头的推理规则名称由系统保留，请重新命名": "Rule names starting with $$ are reserved by the system, please rename",
        "推理规则名称中禁止出现空格或由系统保留的“:”或“,”符号，请重新命名": "Rule names must not contain space or the system-reserved symbols “:” or “,”. Please rename it.",
        "推理规则名称": "Deduction rule name", "已存在或被系统保留，请重新命名": "already exists or is reserved by system, please rename",
        // fs/metarule.ts
        "意外的规则名称表达式": "Unexpected rule name expression",
        // fs/assertion.ts
        "替换表达式中指定的匹配序号": "The specified match index in the replace expression",
        "必须为整数": "Must be an integer",
        "断言失败：#rp执行替换后自由变量将被量词约束": "Assertion failed: Free variable would be bound by quantifier after #rp substitution",
        "断言失败：变量": "Assertion failed: Variable ",
        "自由出现": " is Free",
        "替换函数#rp导致模式匹配": "Replace function #rp cause undecidable pattern matching ",
        "时无法顺利进行": "",
        "不能同时为项和公式": " cannot be a term and formula simultaneously",
        "函数": "Function ",
        "函数#rp执行失败：自由变量将被量词约束": "Excecute #rp failed: Free variable would be bound by quantifier",
        "模式匹配失败：匹配多个替代变量": "Pattern matching failed: Multiple substitution variables matched ",
        "时值不相同": " with different values",
        "模式匹配失败": "Pattern matching failed",
        "表达式出现在了变量的位置中": "Expression occurs in a variable position",
        "元推理符号⊢M只能出现在元推理规则中": "Meta-deduction symbol ⊢M can only occur in meta-deduction rules",
        "推理符号⊢只能出现在推理规则中": "Deduction symbol ⊢ can only occur in deduction rules",
        "未知的推理符号": "Unknown deduction symbol",
        "元推理/推理符号子节点数目必须为2": "Meta-deduction/deduction symbol must have exactly 2 child nodes",
        "元推理/推理符号的条件格式必须为数组": "Conditions of meta-deduction/deduction symbol must be in array format",
        "元推理/推理符号的结论格式必须为数组": "Conclusions of meta-deduction/deduction symbol must be in array format",
        "推理符号的结论数必须为1": "Deduction symbol must have exactly 1 conclusion",
        "元推理符号的结论不能为空": "Meta-deduction symbol's conclusion cannot be empty",
        "条件中": "In conditions ",
        "结论中": "In conclusions ",
        "未找到元推理符号": "Meta-deduction symbol not found",
        "未找到推理符号": "Deduction symbol not found",
        "意外出现了量词": "Unexpected quantifier found",
        "非变量表达式出现在了量词": "Unexpected Non-variable expression in bound variable of quantifier ",
        "的约束变量中": ".",
        "常数符号": "Constant symbol ",
        "禁止出现在量词": " cannot occur in quantifier ",
        "意外出现谓词表达式": "Unexpected predicate expression ",
        "自定义符号中不能有大写字母": "Uppercase letter cannot appear in custom tokens",
        "意外出现集合表达式": "Unexpected set expression ",
        "意外出现谓词符号": "Unexpected predicate symbol ",
        "意外出现逻辑连词": "Unexpected logical connective ",
        "系统函数": "System function ",
        "的参数个数必须为三个或四个": " must have exactly three or four arguments",
        "的参数个数必须至少有": " must have at least ",
        "个": " arguments",
        "第1个参数中：": "'s first parameter: ",
        "第2个参数中：": "'s second parameter: ",
        "第3个参数中：": "'s third parameter: ",
        "第4个参数中：": "'s fourth parameter: ",
        "第5个参数中：": "'s fifth parameter: ",
        "第6个参数中：": "'s sixth parameter: ",
        "意外出现算数谓词表达式": "Unexpected arithmetic predicate expression",
        "算数谓词 Prime 仅接受一个类型为项的参数": "Arithmetic predicate 'Prime' only accepts one argument of type term",
        "意外出现双射谓词表达式": "Unexpected bijection predicate expression",
        "双射谓词 Equiv 仅接受两个类型为项的参数": "Bijection predicate 'Equiv' only accepts two arguments of type term",
        "意外出现序关系谓词表达式": "Unexpected order relation predicate expression",
        "序关系谓词Order仅接受两个类型为项的参数": "Order relation predicate 'Order' only accepts two arguments of type term",
        "序关系谓词WellOrder仅接受两个类型为项的参数": "Order relation predicate 'WellOrder' only accepts two arguments of type term",
        "意外出现二元关系谓词表达式": "Unexpected binary relation predicate expression",
        "二元关系谓词 Rel 仅接受3个类型为项的参数": "Binary relation predicate 'Rel' only accepts three arguments of type term",
        "无法将集合常量符号“": "Cannot use set constant symbol '",
        "”作为原子公式符号": "' as atomic formula symbol",
        "变量": "Variable ",
        "不能同时为函数和谓词": " cannot be function and predicate simultaneously",
        "自由出现断言失败": " free occurrence assertion failed",
        "表达式可被替换断言失败": "Substitutable expression assertion failed",
        // fs/astparser.ts
        "语法错误：未找到变量": "Syntax error: Variable not found",
        "语法错误：未找到符号": "Syntax error: Missing symbol ",
        "语法错误": "Syntax error",
        "未找到断言函数": "Assertion function not found",
        // fs/initial.ts
        "，多个变量名请用“,”隔开": ". For multiple variable names, please separate them with ','",
        // fs/formalsystem.ts
        "函数的参数不能是常量": "The function parameter can't be const",
        "函数的参数必须是变量": "The function parameter must be variable",
        "定义的常量没在结论中出现": "The defined constant does not appear in the conclusion",
        "定义的函数表达式没在结论中出现": "The defined function expression does not appear in the conclusion",
        "$$0只能为纯变量名": "$$0 must be a pure variable name",
        "以$开头的变量名称被系统保留": "Variable names starting with $ are reserved by the system",
        "以#开头的变量名称被系统保留": "Variable names starting with # are reserved by the system",
        "匹配条件##newconst($$0)时：": "When matching condition ##newconst($$0):",
        "匹配条件##newconst($$0)时：$$0已有定义": "When matching condition ##newconst($$0): $$0 is already defined",
        "不能包含$开头的替代项": "Cannot contain substitutions starting with $",
        "以#开头的函数被系统保留": "Functions starting with # are reserved by the system",
        "以$开头的函数被系统保留": "Functions starting with $ are reserved by the system",
        "匹配条件##newfn($$0)时：$$0已有定义": "When matching condition ##newfn($$0): $$0 is already defined",
        "元推理符号后面没有结论": "No conclusion found after meta-deduction symbol",
        "规则名称 ": "Rule name ",
        " 不存在": " does not exist",
        "无法删除规则 ": "Cannot delete rule ",
        "，请先删除对其有依赖的规则 ": ", please delete dependent rules first: ",
        "，请先删除对其有依赖的定理 p": ", please delete dependent proposition: p",
        "删除了不存在的常量的定义公理 ": "Deleted definition axiom of non-existent constant ",
        "删除了不存在的函数的定义公理 ": "Deleted definition axiom of non-existent function ",
        " 已存在": " already exists",
        "非法移动：推出定理": "Invavlid movement: The dependent proposition of ",
        "所依赖的定理": ": ",
        "无法调整至其后方": " cannot be placed after it.",
        "被移动的假设条件被删除：假设须位于其它定理之前": "The hypothesis is deleted because hypothesis must be before other propositions",
        "无法移动假设条件：假设须位于其它定理之前": "Cannot move hypothesis: Hypothesis must be before other propositions",
        "假设中不能出现以#号开头的局部变量": "Local variables prefixed with '#' cannot occur in hypotheses",
        "假设中": "In hypotheses, ",
        "还未解锁跨越量词E!进行替换的功能": "Replacement across the quantifier E! has not been unlocked yet",
        "假设中不能包含未化简的#rp函数，否则匹配机制将失效": "Unreduced #rp function cannot occur in hypotheses, otherwise the matching mechanism will fail.",
        "无有效定理推导步骤，创建宏推导失败": "No valid deduction steps, failed to create macro",
        "局部变量不能出现在推理宏的结论中": "Local variables cannot appear in the conclusion of deduction macros",
        "已有定义，无法重复定义": "Already defined, cannot be redefined",
        "发现意外的“,”字符": "Unexpected ',' character found",
        "使用元规则生成推理规则": "While using metarule to generating deduction rule ",
        "时：意外出现了“,”": ", unexpected ',' encountered",
        "时：": ", ",
        "规则 ": "Rule ",
        "无法重命名系统规则": "Cannot rename system rule",
        "无法重命名快速元规则": "Cannot rename fast-metarules",
        "请输入要重命名的规则名称": "Please enter the rule name to rename",
        "请输入新名称": "Please enter the new name",
        "请输入新文件夹名称": "Please enter the new folder name",
        "重命名推理规则失败：": "Failed to rename deduction rule: ",
        "非法文件夹名称": "Invalid folder name",
        "找不到指定文件夹": "Cannot find specified folder",
        "该操作将删除文件夹，并将里面的内容散列在上级目录中，确定要删除<": "This operation will delete the folder and scatter its contents into the parent directory. Are you sure you want to delete <",
        ">吗？": ">?",
        " 推理失败:": " deduction failed: ",
        "规则不存在": "Rule does not exist",
        "解析错误：": "Error: ",
        "第1个": "The first ",
        "第2个": "The second ",
        "第3个": "The third ",
        "第4个": "The fourth ",
        "第5个": "The fifth ",
        "第6个": "The sixth ",
        "第7个": "The seventh ",
        "第8个": "The eighth ",
        "第9个": "The ninth ",
        "第10个": "The tenth ",
        "条件对应的定理p": "condition: Corresponding proposition p",
        "不存在": "does not exist",
        "条件": "Condition ",
        "条件中:": "condition: ",
        "结论中出现语法错误：": "Syntax error in the conclusion: ",
        "结论中：": "In the conclusion: ",
        "子步骤": "In substep",
        ")中 ": "): ",
        "该定理为假设，无推理步骤可展开": "This proposition is hypothesis, no deduction steps can be expanded",
        "该定理由来自<": "This proposition is derived from <",
        ">的原子推理规则得到，无子步骤": "> atomic deduction rule with no substeps",
        "一阶逻辑公理模式": "1st Logic Axiom Schema",
        "推理规则 ": "Deduction rule ",
        "无法展开原子推理规则": "Cannot expand atomic deduction rule",
        "无法匹配带条件的推理规则": "Cannot match deduction rule with conditions",
        "无法匹配非公理推理规则": "Can only match axiomatic deduction rule",
        "条件中的推理规则不存在": "Deduction rule in condition does not exist",
        "元推理结论规则中的条件中的#nf函数永远无法通过验证": "The verification of #nf function failed in the condition of the rule in meta-deduction's conclusion", "向": "", "条件添加不自由断言时出现不一致：": " condition: Inconsistency occurs when adding non-free assertion: ",
        "中间步骤": "Intermediate step",
        "推理规则不包含假设，无法与条件匹配": "Deduction rule does not contain hypotheses, cannot match condition",
        "元推理结论 >mp 为 (($0 > $1) ⊢ ($0 > $1))，假设与结论相同": "Meta-deduction conclusion >mp is (($0 > $1) ⊢ ($0 > $1)), where hypothesis identical to conclusion",
        "条件推理规则(...$$0 ⊢ ($$1 > $$2))匹配失败": "Conditional deduction rule (...$$0 ⊢ ($$1 > $$2)) matching failed",
        "匹配条件推理规则($$0 ⊢ $$1)失败": "Conditional deduction rule ($$0 ⊢ $$1) matching failed",
        "匹配条件推理规则($$1b ⊢ $$2)失败": "Conditional deduction rule ($$1b ⊢ $$2) matching failed",
        "无任何变量被改名": "No variables were renamed",
        "推理规则不存在": "Deduction rule does not exist",
        "条件推理规则( ⊢ ($$0 <> $$1))匹配失败": "Condition deduction rule ( ⊢ ($$0 <> $$1)) matching failed",
        "匹配序号参数必须为非负整数": "Matching index parameter must be a non-negative integer",
        "元推理函数中替换函数##rp执行失败": "Excuting replace function ##rp failed in meta-deduction function",
        // saveload.ts
        "[创造模式]": "[Creative Mode]",
        "[生存模式]": "[Survival Mode]",
        "确定要放弃所有游戏进度吗？": "Are you sure you want to give up all game progress?",
        "进度代码格式错误：": "Format Error of Progress Code: ",
        "进度已回滚。": "Progress rollbacked",
        // fs/gui.ts
        "[宏]": "[M]",
        "录制*": "Recorded*",
        "元规则生成*": "From Metarule*",
        // fs/initial.ts
        "[v]一阶逻辑公理模式": "[v]1st Logic Axiom Schema",
        "[c]条件演绎元定理": "[c]Cond. Deduct. Theorem",
        "[>]演绎元定理": "[>]Deduction Theorem",
        "[<]逆演绎元定理": "[<]Inv. Deduct. Theorem",
        "[:]组合元定理": "[:]Combination Theorem",
        "常数定义公理模式": "Const Def. Axiom Schema",
        "函数定义公理模式": "Fn. Def. Axiom Schema",
        "谓词定义公理模式": "Pred. Def. Axiom Schema",
        "[v]条件概括元定理": "[v]Cond. Gen. Theorem",
        "[u]概括元定理": "[u]Generalization Theorem",
        "[e]特称元定理": "[e]Existential Theorem",
        "互推替换元定理": "IFF Theorem",
        "完备性元定理": "Completeness Theorem",
        "前束范式V...$$0:$$1": "Prenex Normal Form V...$$0:$$1",
        "$$2（多个新变量名请用“,”或空格隔开）": "$$2 (Separate multiple new variable names with ',' or space)",
        "纯命题逻辑$$0": "Pure Propositional Logic $$0",
        // fs/proof.ts

        "无法对非命题逻辑符号进行真值指派": "Cannot perform truth assignment on non-propositional logic terms", "条件重言式测试失败：真值指派": "Conditional tautology test failed: When Truth assignment ", "为": " is ", "真": " true", "假": " false", "、": ", ", "时命题为假": ", the proposition is false",

        // buttons
        "几何层": "Geom Layer",
        "推理层": "Deduct Layer",
        "类型层": "Type Layer",
        "进度层": "Progress Layer",
        "保存": "Save",
        "加载": "Load",
        "清除进度": "Clear Progress",
        "Toggle Game Language to English": "切换游戏语言至中文",
        "假设(hyp)": "Hypotheses (hyp)",
        "推理(d)": "Make Deduction (d)",
        "回退定理(pop)": "Undo Deduction (pop)",
        "清空定理(clear)": "Clear Props (clear)",
        "录制宏(m)": "Record Macro (m)",
        "录制元宏(mm)": "Record Macro (mm)",
        "删除宏(del)": "Delete Macro (del)",
        "查看宏(entr)": "View Macro (entr)",
        "展开宏(inln)": "Expand Macro (inln)",
        "更名宏(rename)": "Rename Macro (rename)",
        "新文件夹(mkdir)": "New Folder (mkdir)",
        // labels
        "以输入形式(ascii)显示谜题": "Show Puzzles in ASCII Form",
        "[#]系统函数规则：": "[#]System function Rules:",
        "[M]元规则：": "[M]Metarules:",
        "[D]推理规则：": "[D]Deduction Rules:",
        "[P]定理：": "[P]Propositions:",
        "公理": "Axioms",
        "定理": "Theorems",
        "基本定理": "Basic Theorems",
        "相等的基本定理": "Basic Theorems of Equation",
        "皮亚诺算数": "Peano Arithmetic",
        "配对公理集合": "Set of Pairing",
        "有序对与笛卡尔积": "Ordered Pairs & Cartesian Product",
        "矛盾相关定理": "Contradiction-related Theorems",
        "↔的基本定理": "Basic Theorems of ↔",
        "且与或的基本定理": "Basic Theorems of AND & OR",
        "等价定理": "Theorems of IFF substitution",
        "部分自由出现的定理": "Partially Free Occurrence Theorems",
        "序关系": "Order Relation",
        "数系": "Number Systems",
        "自然数": "Natural Numbers",
        "整数": "Integers",
        "有理数": "Rational Numbers",
        "实数": "Real Numbers",
        "换名定理": "Renaming Theorems",
        "简化公理": "Simplified Axioms",
        "符号定义": "Symbol Definitions",
        "1-10定义": "Definitions of 1-10",
        "后继定理": "Theorems of Successor",
        "加法定理": "Theorems of Addition",
        "乘法定理": "Theorems of Multiplication",
        "序关系定理": "Theorems of Order Relation",
        "命题逻辑": "Prop. Logic Axioms",
        "几何公理": "Geometric Axioms",
        "逻辑符号定义": "Logical Sym Defs",
        "集合符号定义": "Set Sym Defs",
        "集合算数连接": "Set & Arith.",
        "算数符号定义": "Arith. Defs",
        "内置宏": "Built-in Macros",
        "添加的规则": "Added Rules",
        "公理类型：": "Axiom Types:",
        "定理：": "Propositions:",
        "证明策略：": "Proof Strategies: ",
        "拥有推理素：": "Deductrium Owned: ",
        "累计消耗推理素：": "Total Deductrium Consumed: ",
        "拆除门个数：": "Destructed Gates: ",
        "块": " Tile(s)",
        "总方块步数：": "Total Block Steps: ",
        "到达过的最大序数：": "Highest Ordinal Reached: ",
        "能前往的最大序数：": "Highest Ordinal Accessible: ",
        "逢": "Base ",
        "进位": " for Limit Ordinal",
        "欢迎联系游戏作者": "Feel Free to Contact Game Author ",
        "简化显示系统函数": "Display Omitted System Functions",
        "斜体显示项": "Italicize Terms",
        // p
        '注意：创造模式与生存模式不共享进度系统。创造模式下无法体验双曲空间以及序数系统等游戏内容，前往生存模式<a href="?" target="_blank">请点击这里</a>。': "Note: Creative and Survival Mode do not share progress. Hyperbolic space and the ordinal number system cannot be accessed in Creative Mode. To switch to Survival Mode, <a href=\"?\" target=\"_blank\">Click Here</a>.",
        // h3
        "数据统计：": "Game Statistics:",
        "成就统计：(手机横屏最佳)": "Achievements: (Rotate your phone for better experience)",
        "若遇Bug或其它任何问题：": "If you encounter bugs or any other issues: (including English translation errors)",
        // achievements
        "解锁了成就": "Achievement Unlocked",
        "我推出我": "I Proved Me",
        "收费站拆除": "Crash Toll Gate",
        "你推出你，他推出他（⊢$0>$0）": "You Proved you, He Proved Him (⊢$0>$0)",
        "If I were..": "If I were..",
        "会跑的“⊢”（演绎元定理）": "Running '⊢' (Deduction Metatheorem)",
        "吃素啦": "Gather Deductrium",
        "第一次消费": "First Consume",
        "敢于说不": "The Courage to Deny",
        "负负得正": "Double Negation Elimination",
        "否定爆炸": "Explosion Principle (exfalso)",
        "我推出你，你推出我（<>）": "I Proved You, You Proved Me (<>)",
        "素食主义者（累计获40µg推理素）": "Deductriumist (Accumulated 40µg of Deductrium)",
        "逻辑门（与/或）": "Logic Gates (AND/OR)",
        "排中律是真的！(p|~p)": "LEM is True! (p|~p)",
        "没毛病！~( p & ~p )": "No Problem! ~( p & ~p )",
        "皮尔士定律((p>q)>p)>p": "Peirce's Law ((p>q)>p)>p",
        "命题逻辑自动推理": "Automated Propositional Reasoning",
        "一阶逻辑": "1st-Order Logic",
        "约束与自由": "Bound and Free Variables",
        "丢掉量词，尽情替换！": "Drop Quantifiers, Replace Freely!",
        "众生平等": "Equality for All",
        "概括一切（概括元定理）": "Generalize Everything (Metatheorem)",
        "命题逻辑大礼包": "Propositional Logic Toolkit",
        "替换一切（互推替换元定理）": "Replace Everything (IFF Metatheorem)",
        "割让量词的领土": "Quantifier Relinquishment",
        "一阶逻辑大礼包": "1st-Order Logic Toolkit",
        "量词连连消消乐": "Quantifier Elimination Challenge",
        "改名换姓（换名元定理）": "α-Conversion (Metatheorem)",
        "加大剂量（累计获1mg推理素）": "Dose Increased (Accumulated 1mg of Deductrium)",
        "皮亚诺公理": "Peano Axioms",
        "1+1=2": "1+1=2",
        "2*2=4": "2×2=4",
        "加法交换律": "Commutativity of Addition",
        "乘法分配率": "Distributivity of Multiplication",
        "致死剂量（累计获1g推理素）": "Lethal Dose (Accumulated 1g of Deductrium)",
        "3小于4": "3 is Less Than 4",
        "5不整除6": "5 Does Not Divide 6",
        "解锁素数": "Prime Number Unlocked",
        "7是素数": "7 is Prime",
        "任何数都有阶乘": "Factorials for All Numbers",
        "质数有无穷个": "Infinitely Many Primes",
        "类型论": "Type Theory",
        "真理之门": "Gate of Truth",
        "简化依赖函数": "Simplify Dependent Functions",
        "证明助手上线！": "Proof Assistant Hired!",
        "相等类型": "Identity Types",
        "自然数的归纳法": "Induction on Natural Numbers",
        "True的值都是true": "All Values of True are true",
        "1+1=2类型论版": "1+1=2 in Type Theory",
        "相等的归纳法": "Induction on Equality",
        "代入方程即可": "Substitution Solves It",
        "1就是1，2就是2（not (eq 1 2)）": "1 is 1, 2 is 2 (not (eq 1 2))",
        "数论达人(5不整除7)": "Number Theory Master (5 Does Not Divide 7)",
        "顺时针一圈逆时针一圈，还是回到原点": "CW plus CCW Returns to Origin",
        "我等价我": "I Am Equivalent to Me",
        "泛等公理（ua）": "Univalence Axiom (ua)",
        "圆圈跟圆点不同伦（loop不是rfl）": "Circle and Point Are Not Homotopic (loop is not rfl)",
        "原来皮尔士跟他们是一伙的": "Peirce Is One of Them",
        "排中律是个谎言！？": "LEM Is a Lie!?",
        "ZFC集合论": "ZFC Set Theory",
        "我包含我": "I Contain Myself",
        "千里之行，始于空集": "All things Begin with Empty Set",
        "ZFC简化大礼包": "Simplified ZFC Toolkit",
        "交交并并": "Intersections and Unions",
        "ω^ω": "ω^ω",
        "我给且只给所有不自己理发的人理发": "Russell's Barber Paradox",
        "集齐所有ZFC公理": "Collect All ZFC Axioms",
        "不可数": "Uncountable",
        "一切皆可良序": "Everything Is Well-Ordered",
        "ω^ω^ω^ω": "ω^ω^ω^ω",
        "临界质量（累计获50.1kg推理素）": "Critical Mass (Accumulated 50.1kg of Deductrium)"
    };
    tr(text: string, mode: string) {
        if (this.lang === "zh") return text;
        return this.dataEn[text] || text;
    }
    trc(text: string) {
        if (this.lang === "zh") return text;
        if (text[0] === "已") {
            return (this.dataEnInCanvas[text.slice(1)] || this.trc1(text.slice(1))).replace(/^([A-Za-z]+)\s/, "$1ed ").replace(/Reduceed/, "Reduced");
        }
        return this.dataEnInCanvas[text] || text;
    }

    trc1(text: string) {
        if (this.lang === "zh") return text;
        if (text.endsWith("\n （此门已拆除）")) {
            text = text.replace("\n （此门已拆除）", "");
            text = this.trc(text) + "\n(This Gate is Destructed)";
        }
        let t = text.replace(/^通过此门需消耗推理素(.+)(\n\(This Gate is Destructed\))?$/, "To pass this gate \nyou need $1 of deductrium$2").replace(/获取(.+)推理素$/, "Obtain $1 of deductrium");
        if (t[0] === "已") {
            return t.slice(1)?.replace(/^([A-Za-z]+)\s/, "$1ed ");
        }
        return t;
    }
}
export const langMgr = new LangMgr();
export const TR = (text: string, mode?: string) => langMgr.tr(text, mode);
export const TRC1 = (text: string) => langMgr.trc1(text);