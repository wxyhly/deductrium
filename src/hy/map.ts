export const mapData = `

// 游戏大厅

@欢迎来到游戏[n]Deductrium![n]按WASD或[n]拖动画面进行移动
1@
3@这是一个形式系统推理结合[n]双曲空间解谜小游戏[n]游戏作者：Hqak(wxyhly)
    :%,4;5;5;5;0;5@
    :%,3$获取1µg推理素
    4,1,3,1,3@
    :%,4;2;3;4;4;2@
    :%,2#前面的区域[n]以后再来探索吧？
    :%,2;2;2;2;2;5@
1,1#[n]未解锁的闸门无法通过[n]请寻找线索解开闸门[n]#ω
2@
3,2@
:%,4$[[progL]]解锁进度层

2,2$[[dL]]解锁推理层[n]与符号“→”（>）
1,3#通过此门需消耗推理素5kg
1,3,1$获取50kg推理素

// a>a 与推理宏引导

:dL,3@#p闸门开启方法：[n]当推理层的定理列表中[n]包含闸门上的字符串时[n]才能通过闸门
:dL,4#[[aa]][n]a>a[n]#p
:%,4#[n]b>b[n]#p
:%,5#[n](a>b)>(a>b)[n]#p
:%,5$获取1µg推理素
:aa,2@[[否定/宏分路]]
:%,1#[[宏门]]通过此门需消耗推理素1µg
:%,2$[[macro]]解锁使用推理宏[n]（即“录制宏”按钮）
:%*,4#[n]⊢$0>(($0>$1)>$0)[n]#d
:%*,4,1$获取1µg推理素
:%,1@[[nd]]#d闸门开启方法：[n]当推理层的推理规则列表中[n]包含闸门上的字符串时[n]才能通过闸门
:aa,1#[n]a>(c>(b>a))[n]#p
:%,2$获取10µg推理素
:dL,2#[n]a>(a>a)[n]#p
:%,4@提示：解锁符号“~”后[n]才能开这些门[n]另外：[n]大写字母为系统保留[n]建议输入小写字母
:%,4@向前走，有推出[n]a>a[n]的提示
:%,5@
:%,5#[n]a>((a>a)>a)[n]#p
:%,4@要想推出a>a[n]尝试使用a2公理看看[n]a>((a>a)>a)[n]能推出什么[n]然后再尝试使用[n]两次推理规则mp
:否定/宏分路,2;1;2;1;1;1@
:否定/宏分路,4#[[否定门]]通过此门需消耗推理素2µg
:%,5$[[neg]]解锁否定公理a3[n]即符号“¬”（~）
:%,2;1;1;1;1;1;1@

// 引导 a>b,b>c > a>c

:否定/宏分路,3#[n]($0>($1>$2)),($0>$1)⊢($0>$2)[n]#d
:%*,3$获取1µg推理素
:macro,5#[[.i]][n]⊢($0>$0)[n]#d
:%*,2@提示：录制宏会将[n]整个定理列表[n]保存到推理规则表中[n]“$xxx”可被任意替换使用
:%,5#[n](~$0>~$1)⊢($1>$0)[n]#d
:%*,5$获取1µg推理素
:%,0#[n]($0>($1>$2))⊢(($0>$1)>($0>$2))[n]#d
:%*,5$获取1µg推理素

:.i,4$[[hyp]]解锁假设[n]注意：由假设得到的定理[n]不可用于开启门#p
:%*,3@将定理列表清空后添加假设[n]录制成宏后假设将作为[n]推理条件出现在[n]推出符号“⊢”前
:否定门,1$[[delgate]]解锁拆门技能[n]通过门后将其拆除

// 一些l7z8的元定理，可挣分买演绎定理

:nd,1;1@
:%,1#[n]⊢($0>(($0>$1)>$1))[n]#d
:%*,2$获取30µg推理素

// iff门, m1, m2

:delgate,3#[n]~($0>$1)⊢~$1[n]#d
:delgate,4#[n]$0,~$1⊢~($0>$1)[n]#d
:%*,3$[[del<>]]拆除门#<>
:%,1#[n]~($0>$1)⊢$0[n]#d
:%*,3$[[andor]]解锁逻辑符号[n]“∧”（&）与“∨”（|）

// <>基本定理

:del<>,1#[n]($0>$1),($1>$0)⊢($0<>$1)[n]#d
:%*,3$获取10µg推理素
:%,2#[n](a<>a)[n]#p
:%*,2$获取10µg推理素
:%,1#[n]($0<>$1)⊢$0>$1[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0<>$1)⊢$1>$0[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0<>$1)⊢($1<>$0)[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0<>$1)<>($1<>$0)[n]#p
:%*,2$获取10µg推理素
:%,1#[n]($0<>$1),($1<>$2)⊢($0<>$2)[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0<>~~$0)[n]#p
:%*,2$获取10µg推理素
:%,1#[n]($0<>$1)⊢(~~$0>$2)<>($1>$2)[n]#d
:%*,3$获取100µg推理素

// or
:andor,1#[n]($0|$1)>(~$0>$1)[n]#p
:%*,3$获取10µg推理素
:%,2#[n](~$0>$1)>($0|$1)[n]#p
:%*,2$获取10µg推理素
:%,1#[n]$0⊢($0|$1)[n]#d
:%*,2$获取10µg推理素
:%,1#[n]$1⊢($0|$1)[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0|$0)⊢$0[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0|$1)⊢($1|$0)[n]#d
:%*,2$获取10µg推理素
:%,1#[n]($0|$1)|$2⊢$0|($1|$2)[n]#d
:%*,2$获取10µg推理素
:%,1#[n]~$0,~$1⊢~($0|$1)[n]#d
:%*,2$获取10µg推理素
:%,0#[n](~$0|~$1)<>~($0&$1)[n]#p
:%*,1$获取10µg推理素

//and
:andor,5#[n]($0&$1)>~($0>~$1)[n]#p
:%*,2$获取10µg推理素
:%,5#[n]~($0>~$1)>($0&$1)[n]#p
:%*,2$获取10µg推理素
:%,0#[n]$0,$1⊢($0&$1)[n]#d
:%*,2$获取10µg推理素
:%,5#[n]($0&$1)⊢$0[n]#d
:%*,2$获取10µg推理素
:%,0#[n]($0&$1)⊢$1[n]#d
:%*,2$获取10µg推理素
:%,5#[n]($0&$1)⊢($1&$0)[n]#d
:%*,2$获取10µg推理素
:%,0#[n]($0&$1)&$2⊢$0&($1&$2)[n]#d
:%*,2$获取10µg推理素
:%,5#[n]~$0⊢~($0&$1)[n]#d
:%*,2$获取10µg推理素
:%,0#[n]~$1⊢~($0&$1)[n]#d
:%*,3$获取10µg推理素

// 自动推理

:%,5#通过此门需消耗推理素300µg
:%,2$[[delL]]拆除门#L
// :%,2$[[mcpt]]解锁完备性元定理[n]（命题逻辑自动推理）
:delgate,2;5;5;0@
:delgate,5;2;2;1@

// mct

:hyp,5;5;0;5;0;4;1;2@
:%,1@条件演绎元定理[n]将自动帮你生成[n]带条件的推理宏
:%,0#[[ccmp]][n]($0>($1>$2)),($0>($1>($2>$3)))⊢($0>($1>$3))[n]#d
:%,3$[[mct]]解锁条件演绎元定理
:%,5#[n]($0>~~$1)⊢($0>$1)[n]#d
:%*,5$获取5µg推理素
:mct,1,1$获取10µg推理素

// mdt后好证的从#p门含义出来的岔路：

:ccmp,1#[[mct2mdt]]通过此门需[n]1.解锁条件演绎元定理[n]2.消耗推理素30µg
:%*,2$[[mdt]]解锁演绎元定理[n]解锁演绎元定理[n]解锁演绎元定理
:%,1@重要的元定理说三遍[n]重要的元定理说三遍[n]重要的元定理说三遍
:%,4#[n]($0>($1>$2))>(($0>($1>($2>$3)))>($0>($1>$3)))[n]#p
2,2,3,2#[n]($0>($1>$2))>($1>($0>$2))[n]#p
:%,1$获取20µg推理素

// 否定逻辑词

:neg,0#[n]~~a>a[n]#p
:%,3#[n]a>~~a[n]#p
:%*,5$[[dniM]]获取5µg推理素
:%*,1@提示：[n]门a>(a>a)[n]后有些提示
:%,2#[n]($0>$1)⊢(~$1>~$0)[n]#d
:%*,2,1$获取10µg推理素
:%*,3$获取3µg推理素
:%,2#[n]($0>$1)>(~$1>~$0)[n]#p
:%,5#[n]($0>~$1)>($1>~$0)[n]#p
:%,5#[n](~$0>$1)>(~$1>$0)[n]#p
:%,4$拆除门#K
:%,2$获取15µg推理素
    2,2,2,4,2#[n]~~a>(~~~~a>~~a)[n]#p
    :%*,3$获取1µg推理素
    :%,2#[n]~~a>(~a>~~~a)[n]#p
    :%*,5#[n]($0>$1),($1>$2)⊢($0>$2)[n]#d
    :%*,5,5$获取9µg推理素
    :%,2#[n]~~a>(~~a>a)[n]#p
    :%,2#[n](~~a>~~a)>(~~a>a))[n]#p
    :%,2$获取1µg推理素
:neg,3#[n]$0⊢(~$0>$1)[n]#d
:%*,2$获取4µg推理素
:%,1#[n]$0>($0>$1)⊢$0>$1[n]#d
:%*,2$获取4µg推理素
:neg,4#[n]a>(~a>b)[n]#p
:%*,2$获取8µg推理素

// 门k及之后: a3/T互推，自动推理

2,2,3,4,4#[[K]][n]未解锁的闸门无法通过[n]请寻找线索解开闸门[n]#K
:%,5@
    // 提示门K在哪
    :.i,3;4;3;2@
    :%,3@门#K在离[n]#p闸门开启方法说明[n]直线距离2格远的地方[n]
    :%,1@要解锁门#L[n]需要从“解锁拆门技能”[n]方块旁经过
:K,1#[n](b>c)>((~b>c)>c)[n]#p
:%,1#[n](~b>c)>((b>c)>c)[n]#p
:%,1#[n](~b>~c)>((~b>c)>b)[n]#p
:%,1#[n](~b>c)>((~b>~c)>b)[n]#p
:%,1#[[L]][n]未解锁的闸门无法通过[n]请寻找线索解开闸门[n]#L
:%,1$[[mcpt]]解锁完备性元定理[n]（命题逻辑自动推理）

// 一阶逻辑与iff的引子

:dL,1@
:dL,1,4#通过此门需消耗推理素100µg
:dL,1,3#[[port-iff]][n]未解锁的闸门无法通过[n]请寻找线索解开闸门[n]#<>
:dL,1,4,5$[[1st]]解锁一阶逻辑[n]量词公理a4、a5、a6[n]与公理模式元规则mq
:dL,1,3,1$[[iff]]解锁当且仅当（互推）[n]逻辑符号“↔”（<>）
:%,5#[n](~(a>~b)>c)<>(a>(b>c)))[n]#p
:%,5$获取20µg推理素
// 一阶逻辑断言函数教程

:1st,5#[n](V$2:$0)>((V$2:$1)>(V$2:$0))[n]#p
:%,0#[n]V$2:($0>($1>$0))[n]#p
:%*,2@提示：记得使用[n]元推理规则
:%,5#[n]V$2:$0 > V$2:($1>$0)[n]#p
:%,0@#nf($0,$1)的值为$0[n]外加验证变量$1不在[n]表达式$0中自由出现[n](nf为nofree缩写)
:%,5@若$0中没有一阶逻辑量词[n]则自由出现指$0中含有$1[n]
:%,5@验证#nf(Vx:$0,$1)[n]有两种情况：[n]1.若x为$1，则[n]$1不在Vx:$0中自由出现
:%,0@2.若x不是$1[n]则#nf(Vx:$0,$1)=[n]Vx:#nf($0,$1)[n]即$1在Vx:$0中是否自由出现[n]取决于$1在$0中是否自由出现
:%,5@若#nf函数验证成功[n]则系统自动删去#nf函数[n]若验证失败系统将报错
:%,0@由于$开头变量[n]在录制宏后可替换成任意值[n]无法确定时[n]#nf函数将保留
:%,0#[n](Vx:$1)>(Vx:(Vx:$1))[n]#p
:%*,5@Vx:$1中x被量词约束[n]不会自由出现[n]因此可使用公理a6
:%,0#[n](Vx:$1)>(Vy:(Vx:$1))[n]#p
:%*,3,1#[n](Vx:x@y)>(Vy:(Vx:x@y))[n]#p
:%*,3$你永远别想拿到这个奖励！
:%,2@Vx:$1中y没被量词约束[n]可能在$1中自由出现[n]因此无法使用公理a6
:%,4#[n](Vx:#nf($1,y))>(Vy:(Vx:#nf($1,y)))[n]#p
:%,5#[n](Vx:x=z)>(Vy:(Vx:x=z)[n]#p
:%,2$获取10µg推理素

// 可替换教程
:1st,3@#rp($0,$1,$2)[n]为将$0中自由出现的$1[n]全替换为$2后的新值
:1st,2@[[crp]]#crp($0,$1,$2)值为$0[n]外加验证$0中[n]可将$1替换为$2[n](即canreplace)
:%,2@若本来自由出现的变量[n]替换后被量词约束[n]则不可替换
:%*,2#[n]Vx:(Vy:~(x=y)) > Vy:~(y=y)[n]#p
:%*,2,1$你永远别想拿到这个奖励！
:%,3@例如#crp(Vy:~(x=y),x,y)[n]系统将验证失败[n]
:%*,1#[n]~(Vx:(Vy:~(x=y)) > Vy:~(y=y))[n]#p
:%*,2,1$获取20µg推理素
:1st,3,1#[n](V$0:$1)⊢$1[n]#d
:%,4@带第四个参数的[n]#rp/#crp函数可部分替换[n]输入数字指定仅替换[n]第几个出现的变量[n]数字0表示全部替换
:%,1$[[a8]]解锁等词公理a8

// 谓词、变量、项教程

:1st,5@“∀”(V)叫做量词[n]量词后紧跟的是变量[n]冒号后的是项[n]整个V$0:$1是项
:%*,0,3#[n](V$2:($0<>$1))>((V$2:$0)<>(V$2:$1))[n]#p
:%*,0,3,5$[[I1]]解锁门#I1
:%*,3#[n]Vx:x@y > Vx:x@y[n]#p
:%*,2#[[vx=x]][n]Vx:x=x[n]#p
:%,4@谓词属于“∈”（@）与[n]相等“=”只能连接变量[n]连接后的整体是项[n]如x@y与x=y都是项[n]
:%*,1@所有命题逻辑连词符号[n]都只能连接项[n]连接后的整体也是项
:%,4@
:%*,5$[[d<]]解锁谓词包含符号“⊂”(<)
:%,1#通过此门需消耗推理素60µg
:%,5$[[highlightd]]解锁高亮显示[n]仅奖励获取推理素的方块

:vx=x,5$[[a7]]解锁等词公理a7

// 等词性质

:a8,1#[n]$0=$1⊢$1=$0[n]#d
:%*,2$获取30µg推理素
:%,1@
:%,1#[n]$0=$1,$1=$2⊢$0=$2[n]#d
:%,2#通过此门需消耗推理素100µg
:%*,5$[[type]]解锁类型层
:%,1$[[aExt]]解锁ZFC集合论[n]外延公理(aExt)
:1st,5,3,4$[[dE]]解锁量词符号[n]“∃”(E)
:%,5#[n]E$0:$0=$1[n]#p
:%,5$获取30µg推理素

// mcvt, mvt, vxvy = vyvx
:1st,3,3#通过此门需消耗推理素100µg
:%*,5$[[mcvt]]解锁条件概括元定理
:%,1#通过此门需消耗推理素100µg
:%*,2$[[mvt]]解锁概括元定理
:%,1#[n](V$0:V$1:$2)>$2[n]#p
:%,4#[n](V$0:V$1:$2)>(V$1:V$0:$2)[n]#p
:%,4#[n](E$0:E$1:$2)>(E$1:E$0:$2)[n]#p
:%*,2$获取60µg推理素
:%,4#[n](E$0:V$1:$2)>(V$1:E$0:$2)[n]#p
:%,5$获取70µg推理素

// 分离公理与空集

:aExt,1#通过此门需消耗推理素100µg
:%,1$[[aSep]]解锁ZFC集合论[n]分离公理(aSep)
:%,1@尝试把分离公理中的$0替换为[n]~(x=x)
:%,2#[n]~Vx:~Vy:~(y@x)[n]#p
:%*,5#[n]Vx:Vy:~Va:~Vz:[n]z@a<>(z@x & z@y)[n]#p
:%*,5,2$获取10µg推理素
:%*,5,0#[n]Vx:Vy:E!a:Vz:[n]z@a<>(z@x & z@y)[n]#p
:%*,5,0,5$[[dI]]解锁交集运算符[n]“∩”(I)
:%,1;1@
:%,1#[[beforePair]]通过此门需消耗推理素500µg

:crp,3#通过此门需消耗推理素19µg
:%,5$解锁唯一存在量词[n]“∃!”(E!)
:%,5#[n](E!x:Vy:~y@x)<>[n]((Ex:Vy:~(y@x))&(Vx:Vz:(((Vy:~(y@x))&Vy:~(y@z)) > x=z)))
:%,5$获取49µg推理素
:%,0@
:%,5#[n]E!x:Vy:~y@x[n]#p
:%,2#通过此门需消耗推理素501µg
:%,3$[[d{}]]解锁空集常量符号[n]“{}”

// 配对公理、正规公理

:beforePair,4$[[aPair]]解锁ZFC集合论[n]配对公理(aPair)
:%*,4#[n]Vx:Vy:Ez:(x@z & y@z)[n]#p
:%,5#[n]Vx:Vy:E!z:Va:[n](a@z <> (a=x | a=y))[n]#p
:%,2#通过此门需消耗推理素1mg
:%,5@
:%,0$解锁配对集合构造符号[n]“{#0,#1}”
:%,5#[n]{$0,$1}={$1,$0}[n]#p
:%*,2$解锁一元集合构造符号[n]“{#0}”
:%,0#[n]$0@{$0,$1}[n]#p
:%*,3$获取12µg推理素
:%,5#[n]Va:((Ex:x@a) > ~(a@{{},{}}))[n]#p
:%*,3$获取42µg推理素
:%,0#[n]a@{b} <> a=b[n]#p
:%,5#[n]{a}={b} <> a=b[n]#p
:%*,5#[n]~(a@{{a}})[n]#p
:%*,5,2$获取4.2mg推理素
:%,0#[n]{a,b}={b,c} <> a=c[n]#p
:%*,2$[[aReg]]解锁ZFC集合论[n]正规公理(aReg)

// 并集公理与并集符号

// iff定理

:dE,1#[n]~(V$2:~$0)<>~(V$2:~$1)[n]⊢(E$2:$0)<>(E$2:$1)[n]#d
:%,5$[[I2]]解锁门#I2

:port-iff,2@
:port-iff,2,5#[n]$a1<>$a2,$b1<>$b2[n]⊢($a1>$b1)<>($a2>$b2)[n]#d
:%*,4$获取34µg推理素
:port-iff,2,4#[n]$a1<>$a2,$b1<>$b2[n]⊢($a1<>$b1)<>($a2<>$b2)[n]#d
:%*,2$获取34µg推理素
:%,5#[n]$0<>$1⊢~$0<>~$1[n]#d
:%*,5#[n]$a1<>$a2,$b1<>$b2[n]⊢($a1&$b1)<>($a2&$b2)[n]#d
:%*,5,4$获取29µg推理素
:%,4#[n]$a1<>$a2,$b1<>$b2[n]⊢($a1|$b1)<>($a2|$b2)[n]#d
:%*,2$获取29µg推理素
:%,5$[[I3]]解锁门#I3
:iff,1#[[I1I2I3]]该门上有三把锁：[n]#I1 #I2 #I3
:%*,3$[[mifft]]解锁互推替换元定理
:%,4;5@

:%,2#[n](b>a),(c>a)⊢[n]((a&b<>a&c)<>(b<>c))[n]#d
:%*,4$获取37µg推理素
:%,1#[n](b>~a),(c>~a)⊢[n]((a|b<>a|c)<>(b<>c))[n]#d
:%*,2$获取37µg推理素

// type theory

:port-iff,5@提示：解锁等词传递性[n]（a=b,b=c ⊢ a=c）后[n]才可能解锁ZFC集合论[n]或解锁类型层
:type,4@值a的类型是A[n]记作a:A
:type,5@#t闸门开启方法：[n]当类型层定理列表中有[n]门上写的类型的值时[n]才能通过闸门
:%*,0;5;0;5;0;5@
:%*,0#U[n]#t
:%*,0,5@类型的类型是U[n]叫“宇宙”或“全类”[n]U的类型是更大的全类U'
:%*,0,5,0,5#U'[n]#t
:%*,0,5,0,5,0,5,0$获取1mg推理素
:%*,4@开启之门即为真理[n]谬误之门无法通过[n]但有些真理却……
    :%*,4,2#(not(not True))->True[n]#t
    :%*,4,3#eq (eq nat 0 0)[n] (refl nat 0) (refl nat 0)[n]#t
    :%*,4,4#Pa:U,Or a (not a)[n]#t
:%*,5#False[n]#t
:%,3#True[n]#t
:%,4$[[ttfnLP]]解锁函数符号“λ”（L）[n]与函数类型符号“Π”（P）
    :%*,1@函数表达式为λx:A.b[n]其自变量x类型为A[n]输出(因变量)值为b
    :%*,1,1@若x:A能推出b:B[n]则λx:A.b的类型为[n]Πx:A,B[n](特别注意“.”与“,”！）
    :%*,1,1,1@注意函数输出类型B[n]可能依赖于x的值[n]以后将看到例子
    :%*,1,1,1,1@λx:A.x的类型是Πx:A,A[n]因为x的类型是A
    :%*,1,1,1,1,1@λx:A.True的类型是Πx:A,U[n]因为True的类型是U
    :%*,1,1,1,1,1,1@函数可以嵌套，如[n]λx:A.λy:B.x其实是[n]λx:A.(λy:B.x)[n]其类型是[n]Πx:A,Πy:B,A
    :%*,3@与量词类似[n]λ后的变量x出现在“.”后的表达式中[n]都是约束变量
    :%*,3,5@类似也有变量[n]在某表达式中[n]“自由出现”的概念
:%,5#Px:True,True[n]#t
:%,5#Px:False,False[n]#t
:%,0#Pa:U,U[n]#t
    :%*,4@不同于传统编程中的函数[n]函数输出值的类型[n]可以依赖于输入的自变量
    :%*,4,5@λx:U.λy:x.y类型为[n]Πx:U,Πy:x,x[n]因为λy:x.y[n]类型为Πy:x,x
:%,5#Pa:U,Px:a,a[n]#t
:%*,4$获取2mg推理素
:%,0#Px:True,Py:False,True[n]#t
:%,5#Pa:U,Pb:U,Px:a,Py:b,a[n]#t
:%,0$[[ttsimplFn]]解锁简写非依赖函数[n]类型符号“→”（->）#t
    :%*,4@若类型Πx:A,B中[n]x不在表达式B中自由出现[n]则该类型可省去x[n]并记作：A→B
    :%*,4,5@默认符号“→”是右结合的[n]即A→B→C为[n]A→(B→C)
    :%*,4,5,5@例：λx:A→B.x[n]的类型为(A→B)→(A→B)
    :%*,4,5,5,0@α-转换规则：[n]若z不在y中自由出现[n]则λx:A.y等价于λz:A.y'[n]其中y'是将y中自由的x[n]替换为z的结果
    :%*,4,5,5,0,5@α-转换前后的两表达式[n]是“定义相等”的[n]由系统自动判定；[n]函数类型[n]简写前(Π)后(→)[n]也“定义相等”
:%,5#Pa:U,Pb:U,Pc:U,a->b->a[n]#t
    :%*,5@若a:A，f:A->B[n]则函数f可以作用于a[n]记作f a[n]且f a类型为B
    :%*,5,2$[[ttapplyFn]]解锁函数作用[n]
    :%*,5,0@β-归约规则：[n]若a:A，则有[n](λx:A.y) a等价于[n]将y中自由的x替换成a
    :%*,5,0,5,3@注意λx:A.y a的含义是[n]λx:A.(y a)而不是[n](λx:A.y) a
    :%*,5,0,5@计算(λx:A.λy:B.z) y时[n]将z中自由的x替换为y[n]将被λy:B约束[n]系统将自动使用α-等价[n]更改自变量名称来规避
    :%*,5,0,5,0@例：λx:A→B.λy:A.x y[n]的类型为(A→B)→(A→B)[n]因为x y的类型为B
    :%*,5,0,5,0,5@“存在某个值其类型是A”[n]可翻译成“A是定理”[n]那个值就是该命题[n]成立的证据
    :%*,5,0,5,0,5,0@旁边的#t门打不开？[n]付费后给提示
    :%*,5,0,5,0,5,0,3#[[hint-tt-a3]]通过此门需消耗推理素1mg
:%,0#Pa:U,Pb:U,Pc:U,(a->b->c)->(a->b)->(a->c)[n]#t
:%,5$[[ttnotFn]]解锁简写否定符号“not”
    :%*,3$解锁证明策略[n]intro/apply
    :%*,5@由于False为空类型，因此若存在函数A->False[n]则说明A类型也为空[n]即A是假命题
:%,0#True->(not (not True))[n]#t
:%,5#Pa:U,Pb:U,(a->b)->[n]((not b)->(not a))[n]#t
:%,0@not(not A)仅表明[n]无法提供A为假的证据[n]并不能证明A为真
:%,5#(not (not (not True)))[n]->(not True)[n]#t
:%,0$[[ttEq]]解锁相等类型
:%*,4@若a与b类型都是A[n]则eq A a b是个类型[n]可翻译为命题“a等于b”
:%,5#eq True true true[n]#t
:%*,2@由于是否定义相等[n]直接由系统判定[n]故不引入相等类型[n]就无法表达含假设命题[n]“若两值相等，则...”
:%,0#eq' U False False[n]#t
    :%*,2,1@若把全类当普通类型用[n]则无法通过类型检查[n]解决方法是使用[n]升级算子“'”[n]如“eq'”与“refl'”
    :%*,3$获取2mg推理素
:%,5#eq' U (False->False) (not False)[n]#t
:%,0$[[ttNat]]解锁自然数nat类型
:%,5#eq nat (succ 0) 1[n]#t
:%*,2@自然数“1”定义为[n]succ 0[n]“2”定义为[n]succ (succ 0)[n] ...
:%,0$[[ttBool]]解锁布尔类型Bool
:%,2#eq Bool 0b 0b[n]#t
:%,3$获取1mg推理素

// tt ind_xxx

:ttBool,5$[[ttindTrue]]解锁ind_True
:%,0@类型True只有一个值true[n]要证对任意x:True成立[n]其实只需论证对true成立[n]引入ind_True作为[n]该事实的证据
:%,5#Px:True,eq True x true[n]#t
:%,0$[[ttindnat]]解锁ind_nat
:ttBool,4$[[ttindFalse]]解锁ind_False
:%,3@类型False没有值[n]要证对任意x:False成立[n]其实都永远成立[n]引入ind_False作为[n]该事实的证据[n]即“从谬误能推出一切”
:%*,1#Pa:U,False->a[n]#t
:%*,1,5$获取10mg推理素
:%,5#False->(eq Bool 0b 1b)[n]#t
:%,2$获取10mg推理素
:ttBool,3$[[ttindBool]]解锁ind_Bool
:%,3@类型Bool有值0b和1b[n]要证对任意x:Bool成立[n]只需对0b与1b均成立[n]引入ind_Bool作为[n]该事实的证据
:%,5#Px:Bool,[n](not (eq Bool x 0b))[n]->(eq Bool x 1b)
:%,2$获取200mg推理素

// nat 递归函数


// :%,3$解锁翻倍函数
// :%,5#eq nat (double 3) 6 
// :%,0$解锁加法函数
// :%,5#eq nat (add 1 1) 2
// :%,0#Px:nat,eq nat (add 0 x) x
// :%,5#Px:nat,Py:nat,(eq nat x y)->(eq nat (succ x) (succ y))
// :%,0#Px:nat,eq nat (add 0 x) x
// :%,5#Px:nat,Py:nat,(eq nat x y)->(eq nat y x)
// :%,0$解锁证明策略[n]rewrite
// :%,5#Px:nat,Py:nat,Pz:nat,(eq nat x y)->(eq nat y z)->(eq nat x z)
// :%,0$解锁和类型
// :%,5#Sum True False
// :%,0$解锁积类型
// :%,5#~(Prod True False)
// :%,0$解锁依赖积类型
:hint-tt-a3,3@这种函数嵌套类型[n]其实就是多元函数类型
:%,3@输入的自变量为[n]a:U、b:U、c:U、[n]x:a->b->c、y:a->b、[n]z:a这六个
:%,3@输出的变量类型为c[n]我们的目标就是要构造[n]有这样输入输出[n]类型的多元函数
:%,3@于是可以先写[n]La:U.Lb:U.Lc:U.[n]Lx:a->b->c.[n]Ly:a->b.Lz:a.???[n]其中???类型是c，值还不确定
:%,3@只要在给定的输入变量下[n]能凑出一个类型为c的值[n]将其填入???处即可
:%,3@类型c只出现过两次[n]第一次c:U，告诉我们它是个类型[n]第二次出现在x:a->b->c
:%,3@即输入类型为a、b的两个值，[n]x函数就能得到[n]类型为c的值
:%,3@类型为a的值是有的，[n]它是z[n]因此要找类型为b的值
:%,3@注意到y:a->b[n]意味着输入a类型的变量[n]就能得到b类型的变量：[n](y z) : b
:%,3@现在可以让函数x作用了：[n]因为z:a、(y z):b[n]所以x z (y z):c[n]这就是???处要填入的表达式
:%,3@能看到这里[n]的玩家也太辛苦了[n]给点奖励合不合适？
:%,3@合适得不得了
:%,3$获取666µg推理素
`;