import { AST } from "./astmgr.js";
import { FSCmd } from "./cmd.js";
import { initFormalSystem } from "./initial.js";
import { Deduction, DeductionStep, FormalSystem } from "./formalsystem.js";
import { TR } from "../lang.js";
import { ListDragger } from "./itemdragger.js";

export class FSGui {
    formalSystem = new FormalSystem();
    actionInput: HTMLInputElement;
    hintText: HTMLDivElement;
    omitNfFn = false;
    propositionList: HTMLOListElement;
    deductionList: HTMLOListElement;
    metaRuleList: HTMLOListElement;
    cmdBtns: NodeListOf<HTMLButtonElement>;
    displayDs = new Set();
    deductions: string[] = [];
    metarules: string[] = [];
    autoGenerateDeduction = true;
    unlockedMacro = false;
    unlockedHyp = false;
    enableMIFFT_RP = false;
    onStateChange = () => { };
    onchangeOmitNF = () => { };
    draggerD = new ListDragger(document.getElementById("deduct-list"));
    draggerP = new ListDragger(document.getElementById("prop-list"));

    isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);
    cmd: FSCmd;
    constructor(
        propositionList: HTMLOListElement, deductionList: HTMLOListElement, metaRuleList: HTMLOListElement,
        actionInput: HTMLInputElement, hintText: HTMLDivElement, displayPLayerSelect: HTMLSelectElement,
        cmdBtns: NodeListOf<HTMLButtonElement>, creative: boolean
    ) {
        this.propositionList = propositionList;
        this.metaRuleList = metaRuleList;
        this.deductionList = deductionList;
        this.actionInput = actionInput;
        this.hintText = hintText;
        this.cmdBtns = cmdBtns;
        this.cmd = new FSCmd(this);
        const { fs, arrD } = initFormalSystem(creative);
        this.formalSystem = fs;
        this.deductions = arrD;
        cmdBtns.forEach(btn => {
            btn.addEventListener("click", () => {
                if (this.cmd.cmdBuffer.length) return;
                this.cmd.cmdBuffer.push(btn.innerText.replace(/.+\((.+)\)/g, "$1"));
                this.cmd.execCmdBuffer();
            });
        });
        document.querySelectorAll("input[name='show-d']").forEach((sd: HTMLInputElement) => {
            const from = (sd.parentNode as HTMLElement).getAttribute("data-tr");
            this.displayDs.add(from);
            sd.addEventListener("change", () => {
                sd.checked ? this.displayDs.add(from) : this.displayDs.delete(from);
                this.updateDeductionList();
            });
        });
        const simplSysFn = document.getElementById("simpl-sysfn") as HTMLInputElement;
        const onchangeOmitNF = () => {
            this.omitNfFn = document.getElementById("wrap-simpl-sysfn").classList.contains("hide") ? false : simplSysFn.checked;
            this.updateMetaRuleList(true);
            this.updateDeductionList();
            this.updatePropositionList(true);
        };
        this.onchangeOmitNF = onchangeOmitNF;
        simplSysFn.addEventListener("change", onchangeOmitNF);
        document.querySelectorAll(".footer .right button").forEach((btn: HTMLElement) => {
            btn.addEventListener("click", () => {
                if (btn.innerText === "OK") {
                    this.cmd.actionInputKeydown({ key: "Enter" });
                } else if (btn.innerText === "Esc") {
                    this.cmd.actionInputKeydown({ key: "Escape" });
                }
            });
        });
        this.draggerD.onExecute = (src, dst) => {
            const srcPos = this.deductions.indexOf(src);
            let dstPos = this.deductions.indexOf(dst);
            if (dstPos > srcPos) dstPos--;
            if (srcPos === -1) return;
            if (dstPos === -1 && dst !== " ") return;
            const moved = this.deductions.splice(this.deductions.indexOf(src), 1)[0];
            if (dstPos === -1) this.deductions.push(moved);
            else this.deductions.splice(dstPos, 0, moved);
            this.updateDeductionList();
        }
        this.draggerP.queryAllowDrag = () => this.cmd.cmdBuffer.length === 0;
        this.draggerP.onExecute = (src, dst) => {
            const pl = this.formalSystem.propositions.length;
            try {
                const s = Number(src.slice(1));
                const d = dst === " " ? -1 : Number(dst.slice(1));
                this.formalSystem.moveProposition(s, d);
                this.updatePropositionList(true);
            } catch (e) {
                if (pl !== this.formalSystem.propositions.length) {
                    this.updatePropositionList(true);
                }
                this.hintText.innerText = e;
            }
        }
        if (creative) {
            this.initCreative();
        }
        this.updateMetaRuleList();
        this.updateDeductionList();
        onchangeOmitNF();
    }
    initCreative() {
        this.metarules = Object.keys(this.formalSystem.metaRules);
        this.formalSystem.fastmetarules = "cvuqe><:#";
        document.getElementById("metarule-subpanel").classList.remove("hide");
        document.getElementById("macro-btns").classList.remove("hide");
        this.unlockedHyp = true;
        this.unlockedMacro = true;
        this.enableMIFFT_RP = true;
        document.getElementById("hyp-btn").classList.remove("hide");
        document.getElementById("ach").classList.add("hide");
        document.getElementById("wrap-simpl-sysfn").classList.remove("hide");
        document.getElementById("stat").classList.add("hide");
        document.getElementById("creer").classList.remove("hide");
    }
    prettyPrint(s: string) {
        return s.replace(/<>/g, "↔").replace(/>/g, "→").replace(/</g, "⊂").replace(/@/g, "∈")
            .replace(/U/g, "∪").replace(/I/g, "∩").replace(/\*/g, "×").replace(/X/g, "×").replace(/\//g, "÷").replace(/-/g, "−")
            .replace(/\|/g, "∨").replace(/&/g, "∧").replace(/~/g, "¬").replace(/V/g, "∀").replace(/E/g, "∃").replace(/omega/g, "ω");
    }
    private addSpan(parentSpan: HTMLSpanElement, text: string) {
        const span = document.createElement("span");
        span.innerHTML = text;
        parentSpan.appendChild(span);
        return span;
    }
    private ast2HTML(idx: string, ast: AST, scopes: AST[] = []) {
        const varnode = document.createElement("span");
        const astStr = this.cmd.astparser.stringify(ast);
        varnode.setAttribute("ast-string", astStr);
        if (ast.type === "meta") {
            this.addSpan(varnode, "(");
            let firstTerm = true;
            for (const n of ast.nodes[0].nodes) {
                if (firstTerm) { firstTerm = false; } else {
                    this.addSpan(varnode, ", ");
                }
                varnode.appendChild(this.ast2HTML(idx, n, scopes));
            }
            if (ast.name === "⊢M") {
                this.addSpan(varnode, ` ⊢<sub>M</sub> `);
            } else {
                this.addSpan(varnode, ` ${ast.name} `);
            }
            firstTerm = true;
            for (const n of ast.nodes[1].nodes) {
                if (firstTerm) { firstTerm = false; } else {
                    this.addSpan(varnode, ", ");
                }
                varnode.appendChild(this.ast2HTML(idx, n, scopes));
            }

            this.addSpan(varnode, ")");

        } else if (ast.type === "fn") {
            if (ast.name === "{") {
                this.addSpan(varnode, "{");
                let firstTerm = true;
                for (const n of ast.nodes) {
                    if (firstTerm) { firstTerm = false; } else {
                        this.addSpan(varnode, ", ");
                    }
                    varnode.appendChild(this.ast2HTML(idx, n, scopes));
                }
                this.addSpan(varnode, "}");
            } else {
                // todo: add show/hide #nf/vnf
                const omitNfFn = (ast.name.match(/^#(v*)nf$/) || ast.name.match(/^#rp$/)) && this.omitNfFn;
                if (!omitNfFn) {
                    if (ast.name !== "(") {
                        const fnName = this.addSpan(varnode, ast.name);
                        if (ast.name.startsWith("#")) fnName.classList.add("sysfn");
                        if (this.formalSystem.fns.has(ast.name)) fnName.classList.add("fn");
                    }
                    this.addSpan(varnode, "(");
                }
                const fonts = []; // 0 for mormal, 1 for sup, -1 for sub
                for (const [nidx, n] of ast.nodes.entries()) {
                    let font = 0;
                    const node = this.ast2HTML(idx, n, scopes);
                    if (ast.name.match(/^#(v*)nf/)) {
                        font = (nidx > ast.name.length - 3) ? -1 : 1;
                    }
                    if (ast.name.match(/^#(#match)?rp/)) {
                        if (nidx === 0) node.classList.add("rp");
                        font = nidx === 2 ? -1 : nidx === 1 ? 1 : 0;
                    }
                    if (!nidx) {
                        font = 0;
                    } else {
                        if (ast.name.match(/^#(v*)nf/)) node.setAttribute("ast-string", astStr);
                    }
                    fonts.push(font);
                    const noComma = (nidx >= 1);
                    if (nidx && !font && !fonts[nidx - 1]) this.addSpan(varnode, ", ");
                    if (omitNfFn && !nidx) node.classList.add("omit-nf");
                    if (font) {
                        const wrappedNode = document.createElement(font === 1 ? "sup" : "sub");
                        wrappedNode.classList.add("omit-nf");
                        varnode.appendChild(wrappedNode);
                        if (ast.name.match(/^#(v*)nf/) && nidx > ast.name.length - 3) wrappedNode.classList.add("nf");
                        if (ast.name.match(/^#(v*)nf/) && nidx === 1 && nidx <= ast.name.length - 3) {
                            wrappedNode.prepend(this.addSpan(wrappedNode, "∀"));
                        }
                        if (ast.name.match(/^#(#match)?rp/)) {
                            if (nidx === 2) {
                                const span = document.createElement("span");
                                node.before(span);
                                span.innerText = "↘";
                                wrappedNode.before(span);
                            }
                        }
                        if (nidx && font === fonts[nidx - 1])
                            wrappedNode.appendChild(this.addSpan(wrappedNode, ","));
                        wrappedNode.appendChild(node);
                    } else {
                        varnode.appendChild(node);
                    }
                    if (ast.name.match(/^#(#match)?rp/)) {
                        if (nidx === 3) {
                            const span = document.createElement("span");
                            node.before(span);
                            span.innerText = ",";
                            node.classList.add("rp-nth");
                        }
                    }
                }
                if (!omitNfFn) this.addSpan(varnode, ")");
            }
        } else if (ast.type === "replvar") {
            const el = this.addSpan(varnode, ast.name === "omega" ? "ω" : ast.name);
            const scopeStack = scopes.slice(0);
            if (this.formalSystem.assert.isConst(ast.name, this.formalSystem.consts)) {
                el.classList.add("constant");
            } else if (ast.name.replace(/^\.\.\./, "").match(this.formalSystem.deductionReplNameRule)) {
                el.classList.add("replvar");
            } else {
                el.classList.add("freeVar");
            }
            if (scopeStack[0]?.type === "quantvar") {
                // quantvar is only aimed for mark css style
                if (!el.classList.contains("replvar")) {
                    el.classList.remove("freeVar");
                    el.classList.add("boundedVar");
                }
                scopeStack.pop();
            }
            do {
                if (scopeStack[0] && scopeStack[0]?.nodes[0]?.name === ast.name) {
                    varnode.setAttribute("ast-scope", this.cmd.astparser.stringify(scopeStack[0]));
                    if (!el.classList.contains("replvar")) {
                        el.classList.remove("freeVar");
                        el.classList.add("boundedVar");
                    }
                    break;
                }
            } while (scopeStack.shift());
        } else {
            switch (ast.name) {
                case "~": case "!":
                    this.addSpan(varnode, this.prettyPrint(ast.name));
                    varnode.appendChild(this.ast2HTML(idx, ast.nodes[0], scopes));
                    break;
                case "{|":
                case "|}":
                case "V": case "E": case "E!":
                    const outterLayers: HTMLSpanElement[] = [];
                    outterLayers.push(this.addSpan(varnode, (ast.name === "{|" || ast.name === "|}") ? "{" : ("(" + this.prettyPrint(ast.name))));
                    const varast = this.ast2HTML(idx, ast.nodes[0], [{ type: "quantvar", name: "quantvar" }]);
                    varast.classList.add("boundedVar");
                    if (ast.name === "{|") {
                        outterLayers.push(varnode.appendChild(varast));
                        outterLayers.push(this.addSpan(varnode, this.prettyPrint("@")));
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[1], scopes));
                        outterLayers.push(this.addSpan(varnode, "|"));
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[2], [ast, ...scopes]));
                        outterLayers.push(this.addSpan(varnode, "}"));

                    } else if (ast.name === "|}") {
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[2], [ast, ...scopes]));
                        outterLayers.push(this.addSpan(varnode, "|"));
                        outterLayers.push(varnode.appendChild(varast));
                        outterLayers.push(this.addSpan(varnode, this.prettyPrint("@")));
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[1], scopes));
                        outterLayers.push(this.addSpan(varnode, "}"));
                    } else {
                        outterLayers.push(varnode.appendChild(varast));
                        outterLayers.push(this.addSpan(varnode, ":"));
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[1], [ast, ...scopes]));
                        outterLayers.push(this.addSpan(varnode, ")"));
                    }

                    // hightlight constrained vars

                    const constrainedVars = Array.from(varnode.querySelectorAll("span")).filter(
                        node => (node as HTMLSpanElement).getAttribute("ast-scope") === astStr
                    ) as HTMLSpanElement[];
                    for (const node of constrainedVars) {
                        node.addEventListener('mouseover', ev => {
                            for (const node of outterLayers) {
                                node.classList.add("highlighted");
                            }
                        });
                        node.addEventListener('mouseout', ev => {
                            for (const node of outterLayers) {
                                node.classList.remove("highlighted");
                            }
                        });
                    }
                    outterLayers[1].addEventListener('mouseover', ev => {
                        for (const node of constrainedVars) {
                            node.classList.add("highlighted");
                        }
                    });
                    outterLayers[1].addEventListener('mouseout', ev => {
                        for (const node of constrainedVars) {
                            node.classList.remove("highlighted");
                        }
                    });
                    break;
                default:
                    // case "@": case "=": case "&": case "^": case ">": case "|":
                    this.addSpan(varnode, "(");
                    varnode.appendChild(this.ast2HTML(idx, ast.nodes[0], scopes));
                    this.addSpan(varnode, ast.name.startsWith("$$") ? ` ${ast.name} ` : this.prettyPrint(ast.name));
                    varnode.appendChild(this.ast2HTML(idx, ast.nodes[1], scopes));
                    this.addSpan(varnode, ")");
            }
        }

        // clicks and hovers in this layer
        const spans = Array.from(varnode.childNodes).filter(
            node => ((node as HTMLSpanElement).getAttribute && !(node as HTMLSpanElement).getAttribute("ast-string"))
        ) as HTMLSpanElement[];
        for (const node of spans) {
            node.addEventListener('mouseover', ev => {
                for (const node of spans) {
                    node.classList.add("highlighted");
                }
            });
            node.addEventListener('mouseout', ev => {
                for (const node of spans) {
                    node.classList.remove("highlighted");
                }
            });
            node.addEventListener('click', ev => {
                ev.stopPropagation();
                this.cmd.onClickSubAst(idx, varnode.getAttribute("ast-string"));
            });
        }
        return varnode;
    }
    private _convert(d: Deduction) {
        let str = this.cmd.astparser.stringifyTight(d.value);
        let steps = d.steps?.map(step => [step.deductionIdx, step.conditionIdxs, step.replaceValues.map((v, i) => this.cmd.astparser.stringifyTight(
            v, this.formalSystem.assert.expand(v, d.replaceTypes[i])
        ))]);
        if (d.tempvars?.size) {
            console.log(JSON.stringify([str, "内置宏", steps, Array.from(d.tempvars)]));
            return [str, JSON.stringify(steps), Array.from(d.tempvars)];
        }
        console.log(JSON.stringify([str, "内置宏", steps]));
        return [str, JSON.stringify(steps)];
    }
    private updateGuiList<T extends { value: AST }>(
        prefix: string, logicArray: T[] | { [name: string]: T }, list: HTMLElement,
        filter: (term: T, idx: string) => boolean,
        setInfo: (term: T, itInfo: HTMLElement[], it: HTMLElement) => void,
        refresh?: boolean, customIdx?: string[]
    ) {
        this.onStateChange();
        if (refresh) {
            while (list.lastChild) {
                list.removeChild(list.lastChild);
            }
            list.setAttribute("total", "0");
        }
        let listLength = Number(list.getAttribute("total")) || 0;
        const values = Object.values(logicArray);
        const keys = Object.keys(logicArray);
        const targetLength = values.length;
        list.setAttribute("total", String(targetLength));
        for (; listLength > targetLength; listLength--) {
            const p = values[listLength];
            if (!filter(p, keys[listLength])) continue;
            for (let i = 0; i < 8; i++) list.removeChild(list.lastChild);
        }
        for (; listLength < targetLength; listLength++) {
            const p = values[listLength];
            const pname = customIdx ? customIdx[listLength] : prefix + listLength;
            if (!filter(p, keys[listLength])) continue;

            const itIdx = document.createElement("div");
            list.appendChild(itIdx);
            itIdx.classList.add("idx");
            itIdx.innerText = pname;

            const itVal = document.createElement("div");
            list.appendChild(itVal);
            itVal.classList.add("val");
            itVal.appendChild(this.ast2HTML(pname, p.value));

            const infoArr = [];
            for (let i = 0; i < 6; i++) {
                const itInfo = document.createElement("div");
                list.appendChild(itInfo);
                itInfo.className = "info";
                infoArr.push(itInfo);
            }
            setInfo(p, infoArr, itVal);

            itVal.addEventListener("click", () => {
                const inserted = this.cmd.astparser.stringify(p.value);
                this.cmd.onClickSubAst(pname, inserted);
            });
        }
        list.scroll({ top: list.scrollHeight });
    }
    getProps() {
        return this.cmd.cmdBuffer[0] === "entr" ? this.cmd.cmdBuffer[2] ?? this.formalSystem.propositions : this.formalSystem.propositions
    }
    updatePropositionList(refresh?: boolean) {
        this.updateGuiList("p", this.formalSystem.propositions, this.propositionList, (p) => true, (p, itInfo, it) => {
            itInfo[0].addEventListener("click", () => {
                if (this.cmd.cmdBuffer.length === 0) {
                    this.cmd.clearCmdBuffer();
                    this.hintText.innerText = TR("命令：");
                } else if (this.cmd.cmdBuffer[0] !== "entr") return;
                const from = p.from;
                const cmd = (from ?
                    ["d", from.deductionIdx, ...from.conditionIdxs,
                        ...from.replaceValues.map(v => this.cmd.astparser.stringifyTight(v))
                    ].join(" ")
                    : ("hyp " + this.cmd.astparser.stringifyTight(p.value))
                );
                this.cmd.replaceActionInputFromClick(cmd);
            })
            if (!p.from) {
                itInfo[0].innerText = TR("假设");
                return;
            }
            itInfo[0].innerHTML = this.stringifyDeductionStep(p.from).replaceAll("<", "&lt;").replaceAll(">", "&gt;");
        }, refresh);
        this.draggerP.attachIdxListener();
    }
    updateDeductionList() {
        const types = new Set<string>;
        const ds = this.deductions.map(d => this.formalSystem.deductions[d] || this.formalSystem.generateDeduction(d));
        for (const d of ds) {
            types.add(d.from);
            if (d.from.endsWith("*")) types.add("添加的规则");
        }
        document.querySelectorAll("input[name='show-d']").forEach((sd: HTMLInputElement) => {
            const from = (sd.parentNode as HTMLElement).getAttribute("data-tr");
            if (types.has(from)) sd.parentElement.classList.remove("hide"); else sd.parentElement.classList.add("hide");
        });
        this.updateGuiList("", ds, this.deductionList,
            (p) => (this.displayDs.has(p.from) || (this.displayDs.has("添加的规则") && p.from.endsWith("*"))),
            (p, itInfo, it) => {
                itInfo[0].innerText = TR(p.from).replace(/s$/, "").replaceAll("<", "&lt;").replaceAll(">", "&gt;") + (p.steps?.length ? TR("[宏]") : "");
            }, true, this.deductions
        );
        this.draggerD.attachIdxListener();
    }
    updateMetaRuleList(refresh?: boolean) {
        this.updateGuiList("m", this.formalSystem.metaRules, this.metaRuleList, (p, idx) => this.metarules.includes(idx), (p, itInfo, it) => {
            itInfo[0].innerHTML = TR(p.from).replaceAll("<", "&lt;").replaceAll(">", "&gt;");
        }, refresh, Object.keys(this.formalSystem.metaRules).map(e => "m" + e));
    }
    stringifyDeductionStep(step: DeductionStep) {
        return `&nbsp;${step.deductionIdx} ${step.conditionIdxs.join(",")}`;
    }
    addToDeductions(name: string, after?: string) {
        const oldpos = this.deductions.indexOf(name);
        // delete
        if (oldpos !== -1) {
            if (after === name) return; // x=S(x), aborted
            if (after === this.deductions[oldpos - 1]) return; // identity
            this.deductions.splice(oldpos, 1);
        }
        // insert
        if (!after) {
            this.deductions.push(name);
            this.updateDeductionList();
            return;
        }
        const pos = this.deductions.indexOf(after);
        if (pos === -1) {
            this.deductions.push(name);
        } else {
            this.deductions.splice(pos + 1, 0, name);
        }
        this.updateDeductionList();
    }
    getDeduction(id: string) {
        if (id === ".") return this.getDeduction(this.cmd.lastDeduction);
        if (id[0] === "." && !this.deductions.includes(id) && !(
            this.formalSystem.fastmetarules.includes("#") && this.formalSystem.generateNatLiteralOp(id)
        )) return null;
        if ("cuv".includes(id[0]) && !this.formalSystem.fastmetarules.includes(id[0])) {
            if (id[0] === "v" && this.formalSystem.fastmetarules.includes("q")) {
                if (id.match(/^v*mp$/)) return null;
            } else return null;
        }
        if (this.autoGenerateDeduction) {
            const res = [];
            this.formalSystem.generateDeductionNameTokens(id, 0, res);
            for (const it of res) {
                if (it[0] === "." && !this.deductions.includes(it) && !(
                    this.formalSystem.fastmetarules.includes("#") && this.formalSystem.generateNatLiteralOp(it)
                )) return null;
                if (this.formalSystem.deductions[it] && !this.deductions.includes(it) && !(
                    (it.match(/^d([1-9][0-9]+)$/) || this.formalSystem.generateNatLiteralOp(it)) && this.formalSystem.fastmetarules.includes("#")
                )) return null;
            }

            try {
                return this.formalSystem.generateDeduction(id);
            } catch (e) { return null; }
        } else if (this.deductions.includes(id)) {
            return this.formalSystem.deductions[id];
        }
        return null;
    }
}


