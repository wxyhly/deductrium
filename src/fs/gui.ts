import { AST, ASTMgr } from "./astmgr.js";
import { FSCmd } from "./cmd.js";
import { iniSysFnList, initFormalSystem } from "./initial.js";
import { Deduction, DeductionStep, FormalSystem } from "./formalsystem.js";
import { TR } from "../lang.js";
import { ListDragger } from "./itemdragger.js";
import { RuleTree } from "./metarule.js";
const astmgr = new ASTMgr();

export class FSGui {
    skipRendering = true;
    formalSystem = new FormalSystem();
    actionInput: HTMLInputElement;
    hintText: HTMLDivElement;
    omitNfFn = false;
    italicItem = false;
    propositionList: HTMLOListElement;
    deductionList: HTMLOListElement;
    metaRuleList: HTMLOListElement;
    sysFnList: HTMLOListElement;
    sysfns: [AST, string, string][];
    cmdBtns: NodeListOf<HTMLButtonElement>;
    displayDs = new Set();
    deductions: string[] = [];
    metarules: string[] = [];
    autoGenerateDeduction = true;
    unlockedMacro = false;
    unlockedHyp = false;
    unlockedRename = false;
    unlockedFolder = false;
    unlockedSysRulePanel = false;
    enableMIFFT_RP = false;
    onStateChange = () => { };
    onchangeOmitNF = () => { };
    draggerD = new ListDragger(document.getElementById("deduct-list"));
    draggerM = new ListDragger(document.getElementById("meta-list"));
    draggerP = new ListDragger(document.getElementById("prop-list"));

    isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);
    cmd: FSCmd;
    constructor(
        propositionList: HTMLOListElement, deductionList: HTMLOListElement, metaRuleList: HTMLOListElement, sysFnList: HTMLOListElement,
        actionInput: HTMLInputElement, hintText: HTMLDivElement, displayPLayerSelect: HTMLSelectElement,
        cmdBtns: NodeListOf<HTMLButtonElement>, creative: boolean, skipRendering: boolean
    ) {
        this.skipRendering = skipRendering;
        this.propositionList = propositionList;
        this.metaRuleList = metaRuleList;
        this.deductionList = deductionList;
        this.sysFnList = sysFnList;
        this.actionInput = actionInput;
        this.hintText = hintText;
        this.cmdBtns = cmdBtns;
        this.cmd = new FSCmd(this);
        const { fs, arrD } = initFormalSystem(creative);
        this.formalSystem = fs;
        this.deductions = arrD;
        this.sysfns = iniSysFnList();
        cmdBtns.forEach(btn => {
            btn.addEventListener("click", () => {
                if (this.cmd.cmdBuffer.length) return;
                this.cmd.cmdBuffer.push(btn.innerText.replace(/.+\((.+)\)/g, "$1"));
                this.cmd.execCmdBuffer();
            });
        });
        document.querySelectorAll("label.before-list-wrapper").forEach(v => {
            const div = v.nextElementSibling as HTMLDivElement;
            v.addEventListener("click", () => {
                div.classList.toggle("hide-animation");
            });
        })
        const simplSysFn = document.getElementById("simpl-sysfn") as HTMLInputElement;
        const italicItemBox = document.getElementById("italic-item") as HTMLInputElement;
        const onchangeOmitNF = () => {
            this.omitNfFn = document.getElementById("wrap-simpl-sysfn").classList.contains("hide") ? false : simplSysFn.checked;
            this.italicItem = document.getElementById("wrap-italic-item").classList.contains("hide") ? false : italicItemBox.checked;
            this.updateSysFnList();
            this.updateMetaRuleList(true);
            this.updateDeductionList();
            this.updatePropositionList(true);
        };
        this.onchangeOmitNF = onchangeOmitNF;
        simplSysFn.addEventListener("change", onchangeOmitNF);
        italicItemBox.addEventListener("change", onchangeOmitNF);
        document.querySelectorAll(".footer .right button").forEach((btn: HTMLElement) => {
            btn.addEventListener("click", () => {
                if (btn.innerText === "OK") {
                    this.cmd.actionInputKeydown({ key: "Enter" });
                } else if (btn.innerText === "Esc") {
                    this.cmd.actionInputKeydown({ key: "Escape" });
                }
            });
        });
        this.draggerD.onExecute = (src, dst) => {
            const mv = (src: string, dst: string) => {
                const srcPos = this.deductions.indexOf(src);
                let dstPos = this.deductions.indexOf(dst);
                if (dstPos > srcPos) dstPos--;
                if (srcPos === -1) return false;
                if (dstPos === -1 && dst !== " ") return false;
                const moved = this.deductions.splice(this.deductions.indexOf(src), 1)[0];
                if (dstPos === -1) this.deductions.push(moved);
                else this.deductions.splice(dstPos, 0, moved);
                return true;
            }

            const idx = this.deductions.indexOf(dst);
            const prevDst = idx === -1 ? this.deductions[this.deductions.length - 1] : (this.deductions[idx - 1] ?? "");
            const table = this.scanDeductionFolderScope([src, prevDst]);
            table[src] ??= [];
            table[prevDst] ??= [];
            let moved = 1;
            const movedSrcs = [src];
            let src_uuid = null;
            if (src.startsWith("< f >")) {
                const [_, srcCount, srcuuid] = src.split("::");
                src_uuid = srcuuid;
                moved += Number(srcCount);
                if (table[prevDst].find(e => e[0] === srcuuid)) {
                    return; // cannot move into itself
                }
                const srcidx = this.deductions.indexOf(src);
                const end = srcidx + 1 + Number(srcCount);
                for (let i = srcidx + 1; i < end; i++) {
                    movedSrcs.push(this.deductions[i]);
                }
            }
            for (const [fuuid] of table[src]) {
                if (src_uuid !== fuuid) {
                    this.setDeductionFolderCount(fuuid, (fcount) => fcount - moved);
                }
            }
            for (const [fuuid] of table[prevDst]) {
                const dir = this.deductions.find(d => d.startsWith("< f >") && d.split("::")[2] === fuuid);
                if (dir.endsWith("+")) break;
                this.setDeductionFolderCount(fuuid, (fcount) => fcount + moved);
            }
            if (dst.startsWith("< f >")) {
                const uuid = dst.split("::")[2];
                dst = this.deductions.find(d => d.startsWith("< f >") && d.split("::")[2] === uuid);
            }
            if (src !== dst) for (const s of movedSrcs) mv(s, dst);
            this.updateDeductionList();
        }
        this.draggerM.onExecute = (src, dst) => {
            src = src.slice(1);
            dst = dst.slice(1);
            const srcPos = this.metarules.indexOf(src);
            let dstPos = this.metarules.indexOf(dst);
            if (dstPos > srcPos) dstPos--;
            if (srcPos === -1) return;
            if (dstPos === -1 && dst !== " ") return;
            const moved = this.metarules.splice(this.metarules.indexOf(src), 1)[0];
            if (dstPos === -1) this.metarules.push(moved);
            else this.metarules.splice(dstPos, 0, moved);
            this.updateMetaRuleList(true);
        }
        this.draggerP.queryAllowDrag = () => this.cmd.cmdBuffer.length === 0;
        this.draggerP.onExecute = (src, dst) => {
            const pl = this.formalSystem.propositions.length;
            try {
                const s = Number(src.slice(1));
                const d = dst === " " ? -1 : Number(dst.slice(1));
                this.formalSystem.moveProposition(s, d);
                this.updatePropositionList(true);
            } catch (e) {
                if (pl !== this.formalSystem.propositions.length) {
                    this.updatePropositionList(true);
                }
                this.hintText.innerText = e;
            }
        }
        if (creative) {
            this.initCreative();
        }
        this.updateMetaRuleList();
        this.updateDeductionList();
        this.updateSysFnList();
        onchangeOmitNF();
    }
    reload() {
        this.formalSystem.fastmetarules = "";
        this.enableMIFFT_RP = false;
    }
    initCreative() {
        this.metarules = Object.keys(this.formalSystem.metaRules);
        this.formalSystem.fastmetarules = "cvuqe><:#zZQR";
        document.getElementById("metarule-subpanel").classList.remove("hide");
        document.getElementById("macro-btns").classList.remove("hide");
        this.unlockedHyp = true;
        this.unlockedRename = true;
        this.unlockedFolder = true;
        this.unlockedSysRulePanel = true;
        this.unlockedMacro = true;
        this.enableMIFFT_RP = true;
        document.getElementById("hyp-btn").classList.remove("hide");
        document.getElementById("ach").classList.add("hide");
        document.getElementById("wrap-simpl-sysfn").classList.remove("hide");
        document.getElementById("wrap-italic-item").classList.remove("hide");
        document.getElementById("stat").classList.add("hide");
        document.getElementById("creer").classList.remove("hide");
        document.getElementById("dir-btn").classList.remove("hide");
        document.getElementById("rename-btn").classList.remove("hide");
    }
    prettyPrint(s: string) {
        return s.replace(/>=/g, "‚â•").replace(/<=/g, "‚â§").replace(/<>/g, "‚Üî").replace(/>/g, "‚Üí").replace(/</g, "‚äÇ").replace(/@/g, "‚àà")
            .replace(/U/g, "‚à™").replace(/I/g, "‚à©").replace(/\*/g, "√ó").replace(/X/g, "√ó").replace(/\//g, "√∑").replace(/-/g, "‚àí")
            .replace(/\|/g, "‚à®").replace(/√∑‚à®/g, "|").replace(/&/g, "‚àß").replace(/~/g, "¬¨").replace(/V/g, "‚àÄ").replace(/E/g, "‚àÉ").replace(/omega/g, "œâ");
    }
    addSpan(parentSpan: HTMLSpanElement, text: string, parseHTML?: boolean) {
        const span = document.createElement("span");
        if (parseHTML) span.innerHTML = text; else span.innerText = text;
        parentSpan.appendChild(span);
        return span;
    }
    ast2HTML(idx: string, ast: AST, isItem: boolean, scopes: AST[] = []) {
        const varnode = document.createElement("span");
        const astStr = this.cmd.astparser.stringify(ast);
        varnode.setAttribute("ast-string", astStr);
        if (ast.type === "rule") {
            this.addSpan(varnode, '"');
            varnode.appendChild(this.tree2HTML(this.formalSystem.getDeductionTokens(ast.name)));
            this.addSpan(varnode, '"');
        } else if (ast.type === "meta") {
            this.addSpan(varnode, "(");
            let firstTerm = true;
            for (const n of ast.nodes[0].nodes) {
                if (firstTerm) { firstTerm = false; } else {
                    this.addSpan(varnode, ", ");
                }
                varnode.appendChild(this.ast2HTML(idx, n, false, scopes));
            }
            if (ast.name === "‚ä¢M") {
                this.addSpan(varnode, ` ‚ä¢<sub>M</sub> `, true);
            } else {
                this.addSpan(varnode, ` ${ast.name} `);
            }
            firstTerm = true;
            for (const n of ast.nodes[1].nodes) {
                if (firstTerm) { firstTerm = false; } else {
                    this.addSpan(varnode, ", ");
                }
                varnode.appendChild(this.ast2HTML(idx, n, false, scopes));
            }

            this.addSpan(varnode, ")");

        } else if (ast.type === "fn") {
            if (ast.name === "{") {
                this.addSpan(varnode, "{");
                let firstTerm = true;
                for (const n of ast.nodes) {
                    if (firstTerm) { firstTerm = false; } else {
                        this.addSpan(varnode, ", ");
                    }
                    varnode.appendChild(this.ast2HTML(idx, n, true, scopes));
                }
                this.addSpan(varnode, "}");
            } else {
                // todo: add show/hide #nf/vnf
                const omitNfFn = (ast.name.match(/^#(v*)nf$/) || ast.name.match(/^#rp$/)) && this.omitNfFn;
                if (!omitNfFn) {
                    if (ast.name !== "(") {
                        const fnName = this.addSpan(varnode, ast.name);
                        if (ast.name.startsWith("#")) fnName.classList.add("sysfn");
                        if (this.formalSystem.fns.has(ast.name)) fnName.classList.add("fn");
                        if (this.formalSystem.verbs.has(ast.name)) fnName.classList.add("verb");
                    }
                    this.addSpan(varnode, "(");
                }
                const fonts = []; // 0 for mormal, 1 for sup, -1 for sub
                for (const [nidx, n] of ast.nodes.entries()) {
                    let subIsItem = ast.name.match(/^##match/) ? nidx === 3 : ast.name.match(/^#((v*)nf|#?rp)/) ? nidx === 0 ? isItem : true : true;
                    let font = 0;
                    const node = this.ast2HTML(idx, n, subIsItem, scopes);
                    if (ast.name.match(/^#(v*)nf/)) {
                        font = (nidx > ast.name.length - 3) ? -1 : 1;
                    }
                    if (ast.name.match(/^#(#match)?rp/)) {
                        if (nidx === 0) varnode.classList.add("rp");
                        font = nidx === 2 ? -1 : nidx === 1 ? 1 : 0;
                    }
                    if (!nidx) {
                        font = 0;
                    } else {
                        if (ast.name.match(/^#(v*)nf/)) node.setAttribute("ast-string", astStr);
                    }
                    fonts.push(font);
                    const noComma = (nidx >= 1);
                    if (nidx && !font && !fonts[nidx - 1]) this.addSpan(varnode, ", ");
                    if (omitNfFn && !nidx) varnode.classList.add("omit-nf");
                    if (font) {
                        const wrappedNode = document.createElement(font === 1 ? "sup" : "sub");
                        wrappedNode.classList.add("omit-nf");
                        varnode.appendChild(wrappedNode);
                        if (ast.name.match(/^#(v*)nf/) && nidx > ast.name.length - 3) wrappedNode.classList.add("nf");
                        if (ast.name.match(/^#(v*)nf/) && nidx === 1 && nidx <= ast.name.length - 3) {
                            wrappedNode.prepend(this.addSpan(wrappedNode, "‚àÄ"));
                        }
                        if (ast.name.match(/^#(#match)?rp/)) {
                            if (nidx === 2) {
                                const span = document.createElement("span");
                                node.before(span);
                                span.innerText = "‚Üò";
                                wrappedNode.before(span);
                            }
                        }
                        if (nidx && font === fonts[nidx - 1])
                            wrappedNode.appendChild(this.addSpan(wrappedNode, ","));
                        wrappedNode.appendChild(node);
                    } else {
                        varnode.appendChild(node);
                    }
                    if (ast.name.match(/^#(#match)?rp/)) {
                        if (nidx === 3) {
                            const span = document.createElement("span");
                            node.before(span);
                            span.innerText = ",";
                            node.classList.add("rp-nth");
                        }
                    }
                }
                if (!omitNfFn) this.addSpan(varnode, ")");
            }
        } else if (ast.type === "replvar") {
            const printForm = {
                "omega": "œâ",
                "N": "‚Ñï",
                "Z": "‚Ñ§",
                "Q": "‚Ñö",
                "R": "‚Ñù",
            }
            const el = this.addSpan(varnode, printForm[ast.name] ?? ast.name);
            if (isItem && this.italicItem) el.classList.add("item");
            const scopeStack = scopes.slice(0);
            if (this.formalSystem.assert.isConst(ast.name)) {
                el.classList.add("constant");
            } else if (ast.name.replace(/^\.\.\./, "").match(this.formalSystem.deductionReplNameRule)) {
                el.classList.add("replvar");
            } else {
                el.classList.add("freeVar");
            }
            if (scopeStack[0]?.type === "quantvar") {
                // quantvar is only aimed for mark css style
                if (!el.classList.contains("replvar")) {
                    el.classList.remove("freeVar");
                    el.classList.add("boundedVar");
                }
                scopeStack.pop();
            }
            do {
                if (scopeStack[0] && (scopeStack[0]?.nodes[0]?.name === ast.name) || (scopeStack[0]?.nodes[0]?.nodes?.[0]?.name === ast.name)) {
                    varnode.setAttribute("ast-scope", this.cmd.astparser.stringify(scopeStack[0]));
                    if (!el.classList.contains("replvar")) {
                        el.classList.remove("freeVar");
                        el.classList.add("boundedVar");
                    }
                    break;
                }
            } while (scopeStack.shift());
        } else {
            switch (ast.name) {
                case "~": case "!":
                    this.addSpan(varnode, this.prettyPrint(ast.name));
                    varnode.appendChild(this.ast2HTML(idx, ast.nodes[0], ast.name === "!", scopes));
                    break;
                case "{|":
                case "|}":
                case "V": case "E": case "E!":
                    const outterLayers: HTMLSpanElement[] = [];
                    outterLayers.push(this.addSpan(varnode, (ast.name === "{|" || ast.name === "|}") ? "{" : ("(" + this.prettyPrint(ast.name))));
                    const varast = this.ast2HTML(idx, ast.nodes[0], true, [{ type: "quantvar", name: "quantvar" }]);
                    varast.classList.add("boundedVar");
                    if (ast.name === "{|") {
                        outterLayers.push(varnode.appendChild(varast));
                        outterLayers.push(this.addSpan(varnode, this.prettyPrint("@")));
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[1], true, scopes));
                        outterLayers.push(this.addSpan(varnode, "|"));
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[2], false, [ast, ...scopes]));
                        outterLayers.push(this.addSpan(varnode, "}"));

                    } else if (ast.name === "|}") {
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[2], true, [ast, ...scopes]));
                        outterLayers.push(this.addSpan(varnode, "|"));
                        outterLayers.push(varnode.appendChild(varast));
                        outterLayers.push(this.addSpan(varnode, this.prettyPrint("@")));
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[1], true, scopes));
                        outterLayers.push(this.addSpan(varnode, "}"));
                    } else {
                        outterLayers.push(varnode.appendChild(varast));
                        outterLayers.push(this.addSpan(varnode, ":"));
                        varnode.appendChild(this.ast2HTML(idx, ast.nodes[1], false, [ast, ...scopes]));
                        outterLayers.push(this.addSpan(varnode, ")"));
                    }

                    // hightlight constrained vars

                    const constrainedVars = Array.from(varnode.querySelectorAll("span")).filter(
                        node => (node as HTMLSpanElement).getAttribute("ast-scope") === astStr
                    ) as HTMLSpanElement[];
                    for (const node of constrainedVars) {
                        node.addEventListener('mouseover', ev => {
                            for (const node of outterLayers) {
                                node.classList.add("highlighted");
                            }
                        });
                        node.addEventListener('mouseout', ev => {
                            for (const node of outterLayers) {
                                node.classList.remove("highlighted");
                            }
                        });
                    }
                    outterLayers[1].addEventListener('mouseover', ev => {
                        for (const node of constrainedVars) {
                            node.classList.add("highlighted");
                        }
                    });
                    outterLayers[1].addEventListener('mouseout', ev => {
                        for (const node of constrainedVars) {
                            node.classList.remove("highlighted");
                        }
                    });
                    break;
                default:
                    this.addSpan(varnode, "(");
                    const subIsItem = "-@<=+*UIX/\\".includes(ast.name) || ast.name === "/|" || ast.name === ">=";
                    varnode.appendChild(this.ast2HTML(idx, ast.nodes[0], subIsItem, scopes));
                    this.addSpan(varnode, ast.name.startsWith("$$") ? ` ${ast.name} ` : this.prettyPrint(ast.name));
                    varnode.appendChild(this.ast2HTML(idx, ast.nodes[1], subIsItem, scopes));
                    this.addSpan(varnode, ")");
            }
        }

        // clicks and hovers in this layer
        const spans = Array.from(varnode.childNodes).filter(
            node => ((node as HTMLSpanElement).getAttribute && !(node as HTMLSpanElement).getAttribute("ast-string"))
        ) as HTMLSpanElement[];
        for (const node of spans) {
            node.addEventListener('mouseover', ev => {
                for (const node of spans) {
                    node.classList.add("highlighted");
                }
            });
            node.addEventListener('mouseout', ev => {
                for (const node of spans) {
                    node.classList.remove("highlighted");
                }
            });
            node.addEventListener('click', ev => {
                ev.stopPropagation();
                this.cmd.onClickSubAst(idx, varnode.getAttribute("ast-string"));
            });
        }
        return varnode;
    }
    private _convert(d: Deduction) {
        let str = this.cmd.astparser.stringifyTight(d.value);
        let steps = d.steps?.map(step => [step.deductionIdx, step.conditionIdxs, step.replaceValues.map((v, i) => this.cmd.astparser.stringifyTight(
            v, this.formalSystem.assert.expand(v, d.replaceTypes[i])
        ))]);
        if (d.tempvars?.size) {
            console.log(JSON.stringify([str, "ÂÜÖÁΩÆÂÆè", steps, Array.from(d.tempvars)]));
            return [str, JSON.stringify(steps), Array.from(d.tempvars)];
        }
        console.log(JSON.stringify([str, "ÂÜÖÁΩÆÂÆè", steps]));
        return [str, JSON.stringify(steps)];
    }
    private updateGuiList<T extends { value: AST }>(
        prefix: string, logicArray: T[] | { [name: string]: T }, list: HTMLElement,
        filter: (term: T, idx: string) => boolean,
        setInfo: (term: T, itInfo: HTMLElement[], it: HTMLElement, label: string) => void,
        refresh?: boolean, customIdx?: string[]
    ) {
        this.onStateChange();
        if (refresh) {
            while (list.lastChild) {
                list.removeChild(list.lastChild);
            }
            list.setAttribute("total", "0");
        }
        let listLength = Number(list.getAttribute("total")) || 0;
        const values = Object.values(logicArray);
        const keys = Object.keys(logicArray);
        const targetLength = values.length;
        list.setAttribute("total", String(targetLength));
        for (; listLength > targetLength; listLength--) {
            const p = values[listLength];
            if (!filter(p, keys[listLength])) continue;
            for (let i = 0; i < 8; i++) list.removeChild(list.lastChild);
        }
        for (; listLength < targetLength; listLength++) {
            const p = values[listLength];
            const pname = customIdx ? customIdx[listLength] : prefix + listLength;
            if (!filter(p, keys[listLength])) continue;

            const itIdx = document.createElement("div");
            list.appendChild(itIdx);
            itIdx.classList.add("idx");
            itIdx.innerText = pname;

            const itVal = document.createElement("div");
            list.appendChild(itVal);
            itVal.classList.add("val");
            itVal.appendChild(this.ast2HTML(pname, p.value, false));

            const infoArr = [];
            for (let i = 0; i < 6; i++) {
                const itInfo = document.createElement("div");
                list.appendChild(itInfo);
                itInfo.className = "info";
                infoArr.push(itInfo);
            }
            setInfo(p, infoArr, itVal, pname);

            itVal.addEventListener("click", () => {
                const inserted = this.cmd.astparser.stringify(p.value);
                this.cmd.onClickSubAst(pname, inserted);
            });
        }
        list.scroll({ top: list.scrollHeight });
    }
    clearPListMasked() {
        this.propositionList.querySelectorAll("div.p-match-failed").forEach(e => e.classList.remove("p-match-failed"));
    }
    getProps() {
        return this.cmd.cmdBuffer[0] === "entr" ? this.cmd.cmdBuffer[2] ?? this.formalSystem.propositions : this.formalSystem.propositions
    }
    updateSysFnList() {
        if (this.skipRendering) return;
        if (this.unlockedSysRulePanel) this.sysFnList.parentElement.parentElement.classList.remove("hide");
        let i = 0;
        this.updateGuiList("m", this.sysfns.map(e => ({ value: e[0] })), this.sysFnList, (p) => true, (p, itInfo, it, pname) => {
            let node;
            let isItem = false;
            let errmsg = "";
            const [ast, info] = this.sysfns[i++];
            let sf = astmgr.clone(ast);
            try {
                this.formalSystem.assert.expand(sf, true);
                node = sf;
            } catch (e) {
                sf = astmgr.clone(ast);
                try {
                    this.formalSystem.assert.expand(sf, true);
                    isItem = true;
                    node = sf;
                } catch (e) {
                    errmsg = e;
                }
            }
            this.addSpan(it, " ‚üπ ");
            const html = node ? this.ast2HTML("d", node, isItem) : this.addSpan(it, errmsg).classList.add("error-color");
            if (html) it.appendChild(html);
            itInfo[0].innerText = info;
        }, true, this.sysfns.map(e => e[2]));
    }
    updatePropositionList(refresh?: boolean) {
        if (this.skipRendering) return;
        this.updateGuiList("p", this.formalSystem.propositions, this.propositionList, (p) => true, (p, itInfo, it, pname) => {
            itInfo[0].addEventListener("click", () => {
                if (this.cmd.cmdBuffer.length === 0) {
                    this.cmd.clearCmdBuffer();
                    this.hintText.innerText = TR("ÂëΩ‰ª§Ôºö");
                } else if (this.cmd.cmdBuffer[0] !== "entr") return;
                const from = p.from;
                const cmd = (from ?
                    ["d", from.deductionIdx, ...from.conditionIdxs,
                        ...from.replaceValues.map(v => this.cmd.astparser.stringifyTight(v))
                    ].join(" ")
                    : ("hyp " + this.cmd.astparser.stringifyTight(p.value))
                );
                this.cmd.replaceActionInputFromClick(cmd);
            });
            if (!p.from) {
                itInfo[0].innerText = TR("ÂÅáËÆæ");
                return;
            }
            this.stringifyDeductionStep(itInfo[0], p.from);
            it.addEventListener("mouseover", () => {
                p.from.conditionIdxs.forEach(idx => {
                    const el = document.querySelector(`#prop-list .idx:nth-child(${(idx + 1) * 8 - 7})`);
                    if (el) el.classList.add("p-highlighted-before");
                });
                const pidx = Number(pname.slice(1));
                for (let i = pidx + 1; i < this.formalSystem.propositions.length; i++) {
                    const from = this.formalSystem.propositions[i]?.from;
                    if (!from) continue;
                    if (!from.conditionIdxs.includes(pidx)) continue;
                    const el = document.querySelector(`#prop-list .idx:nth-child(${(i + 1) * 8 - 7})`);
                    if (el) el.classList.add("p-highlighted-after");
                }
            });
            it.addEventListener("mouseout", () => {
                for (let i = 0; i < this.formalSystem.propositions.length; i++) {
                    const el = document.querySelector(`#prop-list .idx:nth-child(${(i + 1) * 8 - 7})`);
                    if (!el) continue;
                    el.classList.remove("p-highlighted-before");
                    el.classList.remove("p-highlighted-after");
                }
            });
        }, refresh);
        const usedPs = new Set<number>();
        for (let pidx = this.deductions.length - 1; pidx >= 0; pidx--) {
            const from = this.formalSystem.propositions[pidx]?.from;
            if (!from) continue;
            for (const cidx of from.conditionIdxs) {
                usedPs.add(cidx);
            }
        }
        for (let i = 0; i < this.formalSystem.propositions.length; i++) {
            if (!usedPs.has(i)) {
                for (let j = 1; j < 8; j++) {
                    const el = document.querySelector(`#prop-list div:nth-child(${(i + 1) * 8 - 7 + j})`);
                    if (el) el.classList.add("p-unused");
                }
            } else {
                for (let j = 1; j < 8; j++) {
                    const el = document.querySelector(`#prop-list div:nth-child(${(i + 1) * 8 - 7 + j})`);
                    if (el) el.classList.remove("p-unused");
                }
            }
        }
        this.draggerP.attachIdxListener();
    }
    updateDeductionList() {
        if (this.skipRendering) return;
        const types = new Set<string>;
        const ds = this.deductions.map(d => d.startsWith('< f >') ? null : this.formalSystem.deductions[d] || this.formalSystem.generateDeduction(d));
        for (const d of ds) {
            if (!d) continue;
            types.add(d.from);
            if (d.from.endsWith("*")) types.add("Ê∑ªÂä†ÁöÑËßÑÂàô");
        }
        document.querySelectorAll("input[name='show-d']").forEach((sd: HTMLInputElement) => {
            const from = (sd.parentNode as HTMLElement).getAttribute("data-tr");
            if (types.has(from)) sd.parentElement.classList.remove("hide"); else sd.parentElement.classList.add("hide");
        });

        const from = this.deductionList.offsetHeight;

        this.drawDeductionList(ds, this.deductionList,
            (p, itInfo, it) => {
                itInfo[0].innerText = TR(p.from).replace(/s$/, "").replaceAll("<", "&lt;").replaceAll(">", "&gt;") + (p.steps?.length ? TR("[ÂÆè]") : "");
            }, this.deductions
        );

        const to = this.deductionList.offsetHeight;
        if (to > from) {
            this.deductionList.style.height = from + 'px';
            requestAnimationFrame(() => {

                this.deductionList.style.height = to ? to + 'px' : "auto";
            });
            const reset = () => {
                this.deductionList.style.height = 'auto';
                this.deductionList.removeEventListener('transitionend', reset);
            };
            this.deductionList.addEventListener('transitionend', reset);
        }
        this.draggerD.attachIdxListener();
    }
    updateMetaRuleList(refresh?: boolean) {
        if (this.skipRendering) return;
        this.updateGuiList("m", Object.fromEntries(this.metarules.map(e => [e, this.formalSystem.metaRules[e]])), this.metaRuleList, (p, idx) => this.metarules.includes(idx), (p, itInfo, it) => {
            itInfo[0].innerHTML = TR(p.from).replaceAll("<", "&lt;").replaceAll(">", "&gt;");
        }, refresh, this.metarules.map(e => "m" + e));
        this.draggerM.attachIdxListener();
    }
    private scanDeductionFolderScope(targets: string[]) {
        const fStack: [string, number, number][] = [];
        const res: { [n: string]: [string, number, number][] } = {};
        for (let i = 0; i < this.deductions.length; i++) {
            while (true) {
                const last = fStack.pop();
                if (!last) break;
                if (last[2] >= i) {
                    fStack.push(last);
                    break;
                }
            }
            const name = this.deductions[i];
            if (name.startsWith("< f >")) {
                const [fname, flength, fuuid, fstate] = name.slice(5).split("::");
                fStack.push([fuuid, Number(flength), i + Number(flength)]);
            }
            if (targets.includes(name)) {
                res[name] = fStack.slice(0);
            }

        }
        return res;
    }
    private setDeductionFolderCount(fuuid: string, count: (number) => number) {
        const idx = this.deductions.findIndex(d => d.startsWith("< f >") && d.split("::")[2] === fuuid);
        if (idx === -1) return false;
        const n = this.deductions[idx].split("::");
        n[1] = String(count(Number(n[1])));
        this.deductions[idx] = n.join("::");
    }
    private drawDeductionList(
        logicArray: Deduction[], list: HTMLElement,
        setInfo: (term: Deduction, itInfo: HTMLElement[], it: HTMLElement, label: string) => void,
        customIdx: string[]
    ) {
        this.onStateChange();
        while (list.lastChild) {
            list.removeChild(list.lastChild);
        }
        const fStack: [string, number, number][] = [];
        const values = Object.values(logicArray);
        const targetLength = values.length;
        for (let listIdx = 0; listIdx < targetLength; listIdx++) {
            const p = values[listIdx];
            const pname = customIdx[listIdx];
            let skipRendering = false;
            while (true) {
                const last = fStack.pop();
                if (!last) break;
                if (last[2] >= listIdx) {
                    fStack.push(last);
                    break;
                }
            }
            for (const s of fStack) {
                if (s[0] === "+") { skipRendering = true; break; }
            }
            if (!skipRendering) {
                const itIdx = document.createElement("div");
                list.appendChild(itIdx);
                itIdx.classList.add("idx");
                itIdx.innerText = pname;
                const itVal = document.createElement("div");
                list.appendChild(itVal);
                this.addSpan(itVal, "‚îÇ".repeat(fStack.length)).className = "dir-bar";
                if (p) {
                    itVal.classList.add("val");

                    itVal.appendChild(this.ast2HTML(pname, p.value, false));

                    const infoArr = [];
                    for (let i = 0; i < 6; i++) {
                        const itInfo = document.createElement("div");
                        list.appendChild(itInfo);
                        itInfo.className = "info";
                        infoArr.push(itInfo);
                    }
                    setInfo(p, infoArr, itVal, pname);

                    itVal.addEventListener("click", () => {
                        const inserted = this.cmd.astparser.stringify(p.value);
                        this.cmd.onClickSubAst(pname, inserted);
                    });
                } else {
                    itIdx.classList.add("dir-idx");
                    itVal.classList.add("dir-val");
                    const [fname, flength, fuuid, fstate] = pname.slice(5).split("::");
                    const dir = this.addSpan(itVal, fname.startsWith("#") ? TR(fname.slice(1)) : fname);
                    dir.classList.add(fstate === "+" ? "dir-close" : "dir-open");
                    dir.classList.add("dir-val");
                    for (let i = 0; i < 6; i++) {
                        const itInfo = document.createElement("div");
                        itInfo.classList.add("dir-val");
                        itInfo.classList.add("dir-info");
                        list.appendChild(itInfo);
                        if (i) continue;

                        this.addSpan(itInfo, " ‚ûï ").addEventListener("click", e => {
                            if (!this.cmd.cmdBuffer.length) {
                                for (let i = this.deductions.indexOf(pname), j = 0; j < Number(pname.split("::")[1]); i++, j++) {
                                    const d = this.deductions[i];
                                    if (d.startsWith("< f >") && d.endsWith("-")) {
                                        this.deductions[i] = d.slice(0, -1) + "+";
                                    }
                                }
                            }
                            this.updateDeductionList();

                        });
                        this.addSpan(itInfo, " ‚ûñ ").addEventListener("click", e => {
                            if (!this.cmd.cmdBuffer.length) {
                                for (let i = this.deductions.indexOf(pname), j = 0; j < Number(pname.split("::")[1]); i++, j++) {
                                    const d = this.deductions[i];
                                    if (d.startsWith("< f >") && d.endsWith("+")) {
                                        this.deductions[i] = d.slice(0, -1) + "-";
                                    }
                                }
                            }
                            this.updateDeductionList();

                        });
                        this.addSpan(itInfo, " ‚úèÔ∏è ").addEventListener("click", e => {
                            if (!this.cmd.cmdBuffer.length) {
                                this.cmd.cmdBuffer.push("op-dir", "rename", fuuid);
                                this.cmd.execCmdBuffer();
                            }
                        });
                        this.addSpan(itInfo, " üóëÔ∏è ").addEventListener("click", e => {
                            if (!this.cmd.cmdBuffer.length) {
                                if (!confirm(TR("ËØ•Êìç‰ΩúÂ∞ÜÂà†Èô§Êñá‰ª∂Â§πÔºåÂπ∂Â∞ÜÈáåÈù¢ÁöÑÂÜÖÂÆπÊï£ÂàóÂú®‰∏äÁ∫ßÁõÆÂΩï‰∏≠ÔºåÁ°ÆÂÆöË¶ÅÂà†Èô§<") + (pname.slice(5).split("::")[0]) + TR(">ÂêóÔºü"))) return;
                                const scope = this.scanDeductionFolderScope([pname]);
                                this.deductions.splice(this.deductions.indexOf(pname), 1);
                                for (const [uuid] of scope[pname]) {
                                    this.setDeductionFolderCount(uuid, c => c - 1);
                                }
                            }
                            this.updateDeductionList();
                        });
                    }
                    itVal.addEventListener("click", () => {
                        if (this.deductions[listIdx].endsWith("+")) {
                            this.deductions[listIdx] = this.deductions[listIdx].slice(0, -1) + "-";
                        } else {
                            this.deductions[listIdx] = this.deductions[listIdx].slice(0, -1) + "+";
                        }
                        this.updateDeductionList();
                    });
                }
            }
            if (!p) {
                const [fname, flength, fuuid, fstate] = pname.slice(5).split("::");
                fStack.push([fstate, listIdx, listIdx + Number(flength)]);
            }
        }
        list.scroll({ top: list.scrollHeight });
    }
    tree2HTML(tree: RuleTree): HTMLElement {
        const span = document.createElement("span");
        span.classList.add("rule-node");

        if (tree.length === 1) {
            span.textContent = tree[0];
            span.classList.add("rule-token");
            if (tree[0].startsWith("$$")) {
                span.classList.add("replvar");
                span.classList.remove("rule-token");
            }
        } else if (tree[0][0] === "#") {
            const hash = document.createElement("span");
            hash.textContent = tree[0];
            span.appendChild(hash);
            for (let i = 1; i < tree.length; i++) {
                const comma = document.createElement("span");
                comma.textContent = ",";
                span.appendChild(comma);
                span.appendChild(this.tree2HTML(tree[i] as RuleTree));
            }
        } else if (tree[0] === ":") {
            for (let i = 1; i < tree.length; i++) {
                const sep = document.createElement("span");
                sep.textContent = i === tree.length - 1 ? "," : ":";
                span.appendChild(sep);
                span.appendChild(this.tree2HTML(tree[i] as RuleTree));
            }
        } else if (tree.length === 2) {
            const first = document.createElement("span");
            first.textContent = tree[0];
            span.appendChild(first);
            span.appendChild(this.tree2HTML(tree[1] as RuleTree));
        }
        const spans = Array.from(span.childNodes) as HTMLSpanElement[];
        for (const node of spans.filter(n => (!n.classList) || !n.classList.contains("rule-node"))) {
            node.addEventListener('mouseover', ev => {
                for (const node of spans) {
                    node.classList.add("rule-highlighted");
                }
            });
            node.addEventListener('mouseout', ev => {
                for (const node of spans) {
                    node.classList.remove("rule-highlighted");
                }
            });
        }
        return span;
    }
    stringifyDeductionStep(dom: HTMLSpanElement, step: DeductionStep) {
        if (!dom) return `&nbsp;${step.deductionIdx} ${step.conditionIdxs.join(",")}`;
        const span = this.addSpan(dom, "&nbsp;", true);
        const didx = this.tree2HTML(this.formalSystem.getDeductionTokens(step.deductionIdx));
        span.appendChild(didx);
        this.addSpan(span, " ");
        let firstTerm = true;
        for (const p of step.conditionIdxs) {
            if (!firstTerm) this.addSpan(span, ",");
            firstTerm = false;
            const sp = this.addSpan(span, String(p));
            sp.classList.add("rule-cond");
            sp.addEventListener("mouseover", ev => {
                const el = document.querySelector(`#prop-list .idx:nth-child(${(p + 1) * 8 - 7})`);
                if (el) el.classList.add("p-highlighted-before");
            });
            sp.addEventListener("mouseout", ev => {
                const el = document.querySelector(`#prop-list .idx:nth-child(${(p + 1) * 8 - 7})`);
                if (el) el.classList.remove("p-highlighted-before");
            });
        }
    }
    addToDeductions(name: string, after?: string) {
        const oldpos = this.deductions.indexOf(name);
        // delete
        if (oldpos !== -1) {
            if (after === name) return; // x=S(x), aborted
            if (after === this.deductions[oldpos - 1]) return; // identity
            this.deductions.splice(oldpos, 1);
        }
        // insert
        if (!after) {
            this.deductions.push(name);
            this.updateDeductionList();
            return;
        }
        const pos = this.deductions.indexOf(after);
        if (pos === -1) {
            this.deductions.push(name);
        } else {
            this.deductions.splice(pos + 1, 0, name);
        }
        this.updateDeductionList();
    }
    getDeduction(id: string): Deduction {
        if (id === ".") return this.getDeduction(this.cmd.lastDeduction);
        // if cuv is locked, can't use cmp and vmp
        if ("cuv".includes(id[0]) && !this.formalSystem.fastmetarules.includes(id[0])) {
            if (id[0] === "v" && this.formalSystem.fastmetarules.includes("q")) {
                if (id.match(/^v*mp$/)) return null;
            } else return null;
        }
        const tokens = [];
        this.formalSystem.getAtomDeductionTokens(id, tokens);
        for (const it of tokens) {
            if (this.deductions.includes(it)) continue;
            // if .XX is locked, can't use it
            if (it[0] === "." && !(
                this.formalSystem.fastmetarules.includes("#") && (
                    this.formalSystem.generateNatLiteralOp(it) || this.formalSystem.generateNatLiteralIsNat(it)
                ) ||
                (this.formalSystem.fastmetarules.includes("Z") && (this.formalSystem.generateZLiteralIsZ(it) || this.formalSystem.generateZLiteralOp(it)))

            )) return null;
            if (it[0] === "a" || it[0] === "d") {
                if (!(
                    (this.formalSystem.fastmetarules.includes("#") && this.formalSystem.generateNatLiteralDef(it)) ||
                    (this.formalSystem.fastmetarules.includes("z") && this.formalSystem.generateZLiteralDef(it))  ||
                    (this.formalSystem.fastmetarules.includes("R") && this.formalSystem.generateRLiteralDef(it))  ||
                    (this.formalSystem.fastmetarules.includes("Q") && this.formalSystem.generateQLiteralDef(it)) 
                ))
                    return null;
            }
        }

        try {
            return this.formalSystem.generateDeduction(id);
        } catch (e) { return null; }
    }
}


